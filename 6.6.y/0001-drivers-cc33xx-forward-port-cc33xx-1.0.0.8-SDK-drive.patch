From e240d684836e3b7baefd0906898b767047f14899 Mon Sep 17 00:00:00 2001
From: Sabeeh Khan <sabeeh-khan@ti.com>
Date: Mon, 10 Mar 2025 12:22:42 -0500
Subject: [PATCH] drivers: cc33xx: forward port cc33xx 1.0.0.8 SDK driver

---
 arch/arm64/configs/defconfig             |    6 +-
 drivers/bluetooth/Kconfig.orig           |  482 --
 drivers/bluetooth/Makefile.orig          |   53 -
 drivers/net/wireless/ti/Makefile         |    1 +
 drivers/net/wireless/ti/Makefile.orig    |    5 -
 drivers/net/wireless/ti/Makefile.rej     |   10 -
 drivers/net/wireless/ti/cc33xx/main.c    |    2 +
 drivers/tty/serial/8250/8250_omap.c.orig | 1854 -----
 net/mac80211/mlme.c.orig                 | 7961 ----------------------
 net/mac80211/util.c.orig                 | 5168 --------------
 net/mac80211/wpa.c.orig                  | 1118 ---
 11 files changed, 7 insertions(+), 16653 deletions(-)
 delete mode 100644 drivers/bluetooth/Kconfig.orig
 delete mode 100644 drivers/bluetooth/Makefile.orig
 delete mode 100644 drivers/net/wireless/ti/Makefile.orig
 delete mode 100644 drivers/net/wireless/ti/Makefile.rej
 delete mode 100644 drivers/tty/serial/8250/8250_omap.c.orig
 delete mode 100644 net/mac80211/mlme.c.orig
 delete mode 100644 net/mac80211/util.c.orig
 delete mode 100644 net/mac80211/wpa.c.orig

diff --git a/arch/arm64/configs/defconfig b/arch/arm64/configs/defconfig
index 60af93c04b45..0198aec5f48a 100644
--- a/arch/arm64/configs/defconfig
+++ b/arch/arm64/configs/defconfig
@@ -415,8 +415,8 @@ CONFIG_MWIFIEX_SDIO=m
 CONFIG_MWIFIEX_PCIE=m
 CONFIG_MT7921E=m
 CONFIG_RSI_91X=m
-CONFIG_WL18XX=m
-CONFIG_WLCORE_SDIO=m
+CONFIG_WL18XX=n
+CONFIG_WLCORE_SDIO=n
 CONFIG_WWAN=m
 CONFIG_MHI_WWAN_CTRL=m
 CONFIG_MHI_WWAN_MBIM=m
@@ -1585,3 +1585,5 @@ CONFIG_CORESIGHT_STM=m
 CONFIG_CORESIGHT_CPU_DEBUG=m
 CONFIG_CORESIGHT_CTI=m
 CONFIG_MEMTEST=y
+CONFIG_CC33XX=m
+CONFIG_CC33XX_SDIO=m
diff --git a/drivers/bluetooth/Kconfig.orig b/drivers/bluetooth/Kconfig.orig
deleted file mode 100644
index bc211c324206..000000000000
--- a/drivers/bluetooth/Kconfig.orig
+++ /dev/null
@@ -1,482 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-
-menu "Bluetooth device drivers"
-	depends on BT
-
-config BT_INTEL
-	tristate
-	select REGMAP
-
-config BT_BCM
-	tristate
-	select FW_LOADER
-
-config BT_RTL
-	tristate
-	select FW_LOADER
-
-config BT_QCA
-	tristate
-	select FW_LOADER
-
-config BT_MTK
-	tristate
-	select FW_LOADER
-
-config BT_HCIBTUSB
-	tristate "HCI USB driver"
-	depends on USB
-	select BT_INTEL
-	help
-	  Bluetooth HCI USB driver.
-	  This driver is required if you want to use Bluetooth devices with
-	  USB interface.
-
-	  Say Y here to compile support for Bluetooth USB devices into the
-	  kernel or say M to compile it as module (btusb).
-
-config BT_HCIBTUSB_AUTOSUSPEND
-	bool "Enable USB autosuspend for Bluetooth USB devices by default"
-	depends on BT_HCIBTUSB
-	help
-	  Say Y here to enable USB autosuspend for Bluetooth USB devices by
-	  default.
-
-	  This can be overridden by passing btusb.enable_autosuspend=[y|n]
-	  on the kernel commandline.
-
-config BT_HCIBTUSB_POLL_SYNC
-	bool "Enable USB poll_sync for Bluetooth USB devices by default"
-	depends on BT_HCIBTUSB
-	default y
-	help
-	  poll_sync synchronizes the USB data and event endpoints by
-	  prioritizing the later.
-
-	  Say Y here to enable USB poll_sync for Bluetooth USB devices by
-	  default.
-
-config BT_HCIBTUSB_BCM
-	bool "Broadcom protocol support"
-	depends on BT_HCIBTUSB
-	select BT_BCM
-	default y
-	help
-	  The Broadcom protocol support enables firmware and patchram
-	  download support for Broadcom Bluetooth controllers.
-
-	  Say Y here to compile support for Broadcom protocol.
-
-config BT_HCIBTUSB_MTK
-	bool "MediaTek protocol support"
-	depends on BT_HCIBTUSB
-	select BT_MTK
-	default n
-	help
-	  The MediaTek protocol support enables firmware download
-	  support and chip initialization for MediaTek Bluetooth
-	  USB controllers.
-
-	  Say Y here to compile support for MediaTek protocol.
-
-config BT_HCIBTUSB_RTL
-	bool "Realtek protocol support"
-	depends on BT_HCIBTUSB
-	select BT_RTL
-	default y
-	help
-	  The Realtek protocol support enables firmware and configuration
-	  download support for Realtek Bluetooth controllers.
-
-	  Say Y here to compile support for Realtek protocol.
-
-config BT_HCIBTSDIO
-	tristate "HCI SDIO driver"
-	depends on MMC
-	help
-	  Bluetooth HCI SDIO driver.
-	  This driver is required if you want to use Bluetooth device with
-	  SDIO interface.
-
-	  Say Y here to compile support for Bluetooth SDIO devices into the
-	  kernel or say M to compile it as module (btsdio).
-
-config BT_HCIUART
-	tristate "HCI UART driver"
-	depends on SERIAL_DEV_BUS || !SERIAL_DEV_BUS
-	depends on NVMEM || !NVMEM
-	depends on TTY
-	help
-	  Bluetooth HCI UART driver.
-	  This driver is required if you want to use Bluetooth devices with
-	  serial port interface. You will also need this driver if you have
-	  UART based Bluetooth PCMCIA and CF devices like Xircom Credit Card
-	  adapter and BrainBoxes Bluetooth PC Card.
-
-	  Say Y here to compile support for Bluetooth UART devices into the
-	  kernel or say M to compile it as module (hci_uart).
-
-config BT_HCIUART_SERDEV
-	bool
-	depends on SERIAL_DEV_BUS && BT_HCIUART
-	default y
-
-config BT_HCIUART_H4
-	bool "UART (H4) protocol support"
-	depends on BT_HCIUART
-	help
-	  UART (H4) is serial protocol for communication between Bluetooth
-	  device and host. This protocol is required for most Bluetooth devices
-	  with UART interface, including PCMCIA and CF cards.
-
-	  Say Y here to compile support for HCI UART (H4) protocol.
-
-config BT_HCIUART_NOKIA
-	tristate "UART Nokia H4+ protocol support"
-	depends on BT_HCIUART
-	depends on BT_HCIUART_SERDEV
-	depends on GPIOLIB
-	depends on PM
-	select BT_HCIUART_H4
-	select BT_BCM
-	help
-	  Nokia H4+ is serial protocol for communication between Bluetooth
-	  device and host. This protocol is required for Bluetooth devices
-	  with UART interface in Nokia devices.
-
-	  Say Y here to compile support for Nokia's H4+ protocol.
-
-config BT_HCIUART_BCSP
-	bool "BCSP protocol support"
-	depends on BT_HCIUART
-	select BITREVERSE
-	help
-	  BCSP (BlueCore Serial Protocol) is serial protocol for communication
-	  between Bluetooth device and host. This protocol is required for non
-	  USB Bluetooth devices based on CSR BlueCore chip, including PCMCIA and
-	  CF cards.
-
-	  Say Y here to compile support for HCI BCSP protocol.
-
-config BT_HCIUART_ATH3K
-	bool "Atheros AR300x serial support"
-	depends on BT_HCIUART
-	select BT_HCIUART_H4
-	help
-	  HCIATH3K (HCI Atheros AR300x) is a serial protocol for
-	  communication between host and Atheros AR300x Bluetooth devices.
-	  This protocol enables AR300x chips to be enabled with
-	  power management support.
-	  Enable this if you have Atheros AR300x serial Bluetooth device.
-
-	  Say Y here to compile support for HCI UART ATH3K protocol.
-
-config BT_HCIUART_LL
-	bool "HCILL protocol support"
-	depends on BT_HCIUART_SERDEV
-	select BT_HCIUART_H4
-	help
-	  HCILL (HCI Low Level) is a serial protocol for communication
-	  between Bluetooth device and host. This protocol is required for
-	  serial Bluetooth devices that are based on Texas Instruments'
-	  BRF chips.
-
-	  Say Y here to compile support for HCILL protocol.
-
-config BT_HCIUART_3WIRE
-	bool "Three-wire UART (H5) protocol support"
-	depends on BT_HCIUART
-	depends on BT_HCIUART_SERDEV
-	help
-	  The HCI Three-wire UART Transport Layer makes it possible to
-	  user the Bluetooth HCI over a serial port interface. The HCI
-	  Three-wire UART Transport Layer assumes that the UART
-	  communication may have bit errors, overrun errors or burst
-	  errors and thereby making CTS/RTS lines unnecessary.
-
-	  Say Y here to compile support for Three-wire UART protocol.
-
-config BT_HCIUART_INTEL
-	bool "Intel protocol support"
-	depends on BT_HCIUART
-	depends on GPIOLIB
-	select BT_HCIUART_H4
-	select BT_INTEL
-	help
-	  The Intel protocol support enables Bluetooth HCI over serial
-	  port interface for Intel Bluetooth controllers.
-
-	  Say Y here to compile support for Intel protocol.
-
-config BT_HCIUART_BCM
-	bool "Broadcom protocol support"
-	depends on BT_HCIUART
-	depends on BT_HCIUART_SERDEV
-	depends on (!ACPI || SERIAL_DEV_CTRL_TTYPORT)
-	depends on GPIOLIB
-	select BT_HCIUART_H4
-	select BT_BCM
-	help
-	  The Broadcom protocol support enables Bluetooth HCI over serial
-	  port interface for Broadcom Bluetooth controllers.
-
-	  Say Y here to compile support for Broadcom protocol.
-
-config BT_HCIUART_RTL
-	bool "Realtek protocol support"
-	depends on BT_HCIUART
-	depends on BT_HCIUART_SERDEV
-	depends on GPIOLIB
-	depends on (ACPI || SERIAL_DEV_CTRL_TTYPORT)
-	select BT_HCIUART_3WIRE
-	select BT_RTL
-	help
-	  The Realtek protocol support enables Bluetooth HCI over 3-Wire
-	  serial port interface for Realtek Bluetooth controllers.
-
-	  Say Y here to compile support for Realtek protocol.
-
-config BT_HCIUART_QCA
-	bool "Qualcomm Atheros protocol support"
-	depends on BT_HCIUART
-	depends on BT_HCIUART_SERDEV
-	select BT_HCIUART_H4
-	select BT_QCA
-	help
-	  The Qualcomm Atheros protocol supports HCI In-Band Sleep feature
-	  over serial port interface(H4) between controller and host.
-	  This protocol is required for UART clock control for QCA Bluetooth
-	  devices.
-
-	  Say Y here to compile support for QCA protocol.
-
-config BT_HCIUART_AG6XX
-	bool "Intel AG6XX protocol support"
-	depends on BT_HCIUART
-	select BT_HCIUART_H4
-	select BT_INTEL
-	help
-	  The Intel/AG6XX protocol support enables Bluetooth HCI over serial
-	  port interface for Intel ibt 2.1 Bluetooth controllers.
-
-	  Say Y here to compile support for Intel AG6XX protocol.
-
-config BT_HCIUART_MRVL
-	bool "Marvell protocol support"
-	depends on BT_HCIUART
-	depends on BT_HCIUART_SERDEV
-	select BT_HCIUART_H4
-	help
-	  Marvell is serial protocol for communication between Bluetooth
-	  device and host. This protocol is required for most Marvell Bluetooth
-	  devices with UART interface.
-
-	  Say Y here to compile support for HCI MRVL protocol.
-
-config BT_HCIBCM203X
-	tristate "HCI BCM203x USB driver"
-	depends on USB
-	select FW_LOADER
-	help
-	  Bluetooth HCI BCM203x USB driver.
-	  This driver provides the firmware loading mechanism for the Broadcom
-	  Blutonium based devices.
-
-	  Say Y here to compile support for HCI BCM203x devices into the
-	  kernel or say M to compile it as module (bcm203x).
-
-
-config BT_HCIBCM4377
-	tristate "HCI BCM4377/4378/4387 PCIe driver"
-	depends on PCI
-	select FW_LOADER
-	help
-	  Support for Broadcom BCM4377/4378/4387 Bluetooth chipsets attached via
-	  PCIe. These are usually found in Apple machines.
-
-	  Say Y here to compile support for HCI BCM4377 family devices into the
-	  kernel or say M to compile it as module (hci_bcm4377).
-
-config BT_HCIBPA10X
-	tristate "HCI BPA10x USB driver"
-	depends on USB
-	help
-	  Bluetooth HCI BPA10x USB driver.
-	  This driver provides support for the Digianswer BPA 100/105 Bluetooth
-	  sniffer devices.
-
-	  Say Y here to compile support for HCI BPA10x devices into the
-	  kernel or say M to compile it as module (bpa10x).
-
-config BT_HCIBFUSB
-	tristate "HCI BlueFRITZ! USB driver"
-	depends on USB
-	select FW_LOADER
-	help
-	  Bluetooth HCI BlueFRITZ! USB driver.
-	  This driver provides support for Bluetooth USB devices with AVM
-	  interface:
-	     AVM BlueFRITZ! USB
-
-	  Say Y here to compile support for HCI BFUSB devices into the
-	  kernel or say M to compile it as module (bfusb).
-
-config BT_HCIDTL1
-	tristate "HCI DTL1 (PC Card) driver"
-	depends on PCMCIA
-	help
-	  Bluetooth HCI DTL1 (PC Card) driver.
-	  This driver provides support for Bluetooth PCMCIA devices with
-	  Nokia DTL1 interface:
-	     Nokia Bluetooth Card
-	     Socket Bluetooth CF Card
-
-	  Say Y here to compile support for HCI DTL1 devices into the
-	  kernel or say M to compile it as module (dtl1_cs).
-
-config BT_HCIBT3C
-	tristate "HCI BT3C (PC Card) driver"
-	depends on PCMCIA
-	select FW_LOADER
-	help
-	  Bluetooth HCI BT3C (PC Card) driver.
-	  This driver provides support for Bluetooth PCMCIA devices with
-	  3Com BT3C interface:
-	     3Com Bluetooth Card (3CRWB6096)
-	     HP Bluetooth Card
-
-	  Say Y here to compile support for HCI BT3C devices into the
-	  kernel or say M to compile it as module (bt3c_cs).
-
-config BT_HCIBLUECARD
-	tristate "HCI BlueCard (PC Card) driver"
-	depends on PCMCIA
-	help
-	  Bluetooth HCI BlueCard (PC Card) driver.
-	  This driver provides support for Bluetooth PCMCIA devices with
-	  Anycom BlueCard interface:
-	     Anycom Bluetooth PC Card
-	     Anycom Bluetooth CF Card
-
-	  Say Y here to compile support for HCI BlueCard devices into the
-	  kernel or say M to compile it as module (bluecard_cs).
-
-config BT_HCIVHCI
-	tristate "HCI VHCI (Virtual HCI device) driver"
-	select WANT_DEV_COREDUMP
-	help
-	  Bluetooth Virtual HCI device driver.
-	  This driver is required if you want to use HCI Emulation software.
-
-	  Say Y here to compile support for virtual HCI devices into the
-	  kernel or say M to compile it as module (hci_vhci).
-
-config BT_MRVL
-	tristate "Marvell Bluetooth driver support"
-	help
-	  The core driver to support Marvell Bluetooth devices.
-
-	  This driver is required if you want to support
-	  Marvell Bluetooth devices, such as 8688/8787/8797/8887/8897/8977/8987/8997.
-
-	  Say Y here to compile Marvell Bluetooth driver
-	  into the kernel or say M to compile it as module.
-
-config BT_MRVL_SDIO
-	tristate "Marvell BT-over-SDIO driver"
-	depends on BT_MRVL && MMC
-	select FW_LOADER
-	select WANT_DEV_COREDUMP
-	help
-	  The driver for Marvell Bluetooth chipsets with SDIO interface.
-
-	  This driver is required if you want to use Marvell Bluetooth
-	  devices with SDIO interface. Currently SD8688/SD8787/SD8797/SD8887/SD8897/SD8977/SD8987/SD8997
-	  chipsets are supported.
-
-	  Say Y here to compile support for Marvell BT-over-SDIO driver
-	  into the kernel or say M to compile it as module.
-
-config BT_ATH3K
-	tristate "Atheros firmware download driver"
-	depends on BT_HCIBTUSB
-	select FW_LOADER
-	help
-	  Bluetooth firmware download driver.
-	  This driver loads the firmware into the Atheros Bluetooth
-	  chipset.
-
-	  Say Y here to compile support for "Atheros firmware download driver"
-	  into the kernel or say M to compile it as module (ath3k).
-
-config BT_MTKSDIO
-	tristate "MediaTek HCI SDIO driver"
-	depends on MMC
-	select BT_MTK
-	help
-	  MediaTek Bluetooth HCI SDIO driver.
-	  This driver is required if you want to use MediaTek Bluetooth
-	  with SDIO interface.
-
-	  Say Y here to compile support for MediaTek Bluetooth SDIO devices
-	  into the kernel or say M to compile it as module (btmtksdio).
-
-config BT_MTKUART
-	tristate "MediaTek HCI UART driver"
-	depends on SERIAL_DEV_BUS
-	select BT_MTK
-	help
-	  MediaTek Bluetooth HCI UART driver.
-	  This driver is required if you want to use MediaTek Bluetooth
-	  with serial interface.
-
-	  Say Y here to compile support for MediaTek Bluetooth UART devices
-	  into the kernel or say M to compile it as module (btmtkuart).
-
-config BT_QCOMSMD
-	tristate "Qualcomm SMD based HCI support"
-	depends on RPMSG || (COMPILE_TEST && RPMSG=n)
-	depends on QCOM_WCNSS_CTRL || (COMPILE_TEST && QCOM_WCNSS_CTRL=n)
-	select BT_QCA
-	help
-	  Qualcomm SMD based HCI driver.
-	  This driver is used to bridge HCI data onto the shared memory
-	  channels to the WCNSS core.
-
-	  Say Y here to compile support for HCI over Qualcomm SMD into the
-	  kernel or say M to compile as a module.
-
-config BT_HCIRSI
-	tristate
-	help
-	  Redpine BT driver.
-	  This driver handles BT traffic from upper layers and pass
-	  to the RSI_91x coex module for further scheduling to device
-
-	  Say Y here to compile support for HCI over Redpine into the
-	  kernel or say M to compile as a module.
-
-config BT_VIRTIO
-	tristate "Virtio Bluetooth driver"
-	depends on VIRTIO
-	help
-	  Virtio Bluetooth support driver.
-	  This driver supports Virtio Bluetooth devices.
-
-	  Say Y here to compile support for HCI over Virtio into the
-	  kernel or say M to compile as a module.
-
-config BT_NXPUART
-	tristate "NXP protocol support"
-	depends on SERIAL_DEV_BUS
-	select CRC32
-	select CRC8
-	help
-	  NXP is serial driver required for NXP Bluetooth
-	  devices with UART interface.
-
-	  Say Y here to compile support for NXP Bluetooth UART device into
-	  the kernel, or say M here to compile as a module (btnxpuart).
-
-
-endmenu
diff --git a/drivers/bluetooth/Makefile.orig b/drivers/bluetooth/Makefile.orig
deleted file mode 100644
index 7a5967e9ac48..000000000000
--- a/drivers/bluetooth/Makefile.orig
+++ /dev/null
@@ -1,53 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for the Linux Bluetooth HCI device drivers.
-#
-
-obj-$(CONFIG_BT_HCIVHCI)	+= hci_vhci.o
-obj-$(CONFIG_BT_HCIUART)	+= hci_uart.o
-obj-$(CONFIG_BT_HCIBCM203X)	+= bcm203x.o
-obj-$(CONFIG_BT_HCIBCM4377)	+= hci_bcm4377.o
-obj-$(CONFIG_BT_HCIBPA10X)	+= bpa10x.o
-obj-$(CONFIG_BT_HCIBFUSB)	+= bfusb.o
-obj-$(CONFIG_BT_HCIDTL1)	+= dtl1_cs.o
-obj-$(CONFIG_BT_HCIBT3C)	+= bt3c_cs.o
-obj-$(CONFIG_BT_HCIBLUECARD)	+= bluecard_cs.o
-
-obj-$(CONFIG_BT_HCIBTUSB)	+= btusb.o
-obj-$(CONFIG_BT_HCIBTSDIO)	+= btsdio.o
-
-obj-$(CONFIG_BT_INTEL)		+= btintel.o
-obj-$(CONFIG_BT_ATH3K)		+= ath3k.o
-obj-$(CONFIG_BT_MRVL)		+= btmrvl.o
-obj-$(CONFIG_BT_MRVL_SDIO)	+= btmrvl_sdio.o
-obj-$(CONFIG_BT_MTKSDIO)	+= btmtksdio.o
-obj-$(CONFIG_BT_MTKUART)	+= btmtkuart.o
-obj-$(CONFIG_BT_QCOMSMD)	+= btqcomsmd.o
-obj-$(CONFIG_BT_BCM)		+= btbcm.o
-obj-$(CONFIG_BT_RTL)		+= btrtl.o
-obj-$(CONFIG_BT_QCA)		+= btqca.o
-obj-$(CONFIG_BT_MTK)		+= btmtk.o
-
-obj-$(CONFIG_BT_VIRTIO)		+= virtio_bt.o
-obj-$(CONFIG_BT_NXPUART)	+= btnxpuart.o
-
-obj-$(CONFIG_BT_HCIUART_NOKIA)	+= hci_nokia.o
-
-obj-$(CONFIG_BT_HCIRSI)		+= btrsi.o
-
-btmrvl-y			:= btmrvl_main.o
-btmrvl-$(CONFIG_DEBUG_FS)	+= btmrvl_debugfs.o
-
-hci_uart-y				:= hci_ldisc.o
-hci_uart-$(CONFIG_BT_HCIUART_SERDEV)	+= hci_serdev.o
-hci_uart-$(CONFIG_BT_HCIUART_H4)	+= hci_h4.o
-hci_uart-$(CONFIG_BT_HCIUART_BCSP)	+= hci_bcsp.o
-hci_uart-$(CONFIG_BT_HCIUART_LL)	+= hci_ll.o
-hci_uart-$(CONFIG_BT_HCIUART_ATH3K)	+= hci_ath.o
-hci_uart-$(CONFIG_BT_HCIUART_3WIRE)	+= hci_h5.o
-hci_uart-$(CONFIG_BT_HCIUART_INTEL)	+= hci_intel.o
-hci_uart-$(CONFIG_BT_HCIUART_BCM)	+= hci_bcm.o
-hci_uart-$(CONFIG_BT_HCIUART_QCA)	+= hci_qca.o
-hci_uart-$(CONFIG_BT_HCIUART_AG6XX)	+= hci_ag6xx.o
-hci_uart-$(CONFIG_BT_HCIUART_MRVL)	+= hci_mrvl.o
-hci_uart-objs				:= $(hci_uart-y)
diff --git a/drivers/net/wireless/ti/Makefile b/drivers/net/wireless/ti/Makefile
index 05ee016594f8..4356f58b4b98 100644
--- a/drivers/net/wireless/ti/Makefile
+++ b/drivers/net/wireless/ti/Makefile
@@ -3,3 +3,4 @@ obj-$(CONFIG_WLCORE)			+= wlcore/
 obj-$(CONFIG_WL12XX)			+= wl12xx/
 obj-$(CONFIG_WL1251)			+= wl1251/
 obj-$(CONFIG_WL18XX)			+= wl18xx/
+obj-$(CONFIG_CC33XX)			+= cc33xx/
diff --git a/drivers/net/wireless/ti/Makefile.orig b/drivers/net/wireless/ti/Makefile.orig
deleted file mode 100644
index 05ee016594f8..000000000000
--- a/drivers/net/wireless/ti/Makefile.orig
+++ /dev/null
@@ -1,5 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-obj-$(CONFIG_WLCORE)			+= wlcore/
-obj-$(CONFIG_WL12XX)			+= wl12xx/
-obj-$(CONFIG_WL1251)			+= wl1251/
-obj-$(CONFIG_WL18XX)			+= wl18xx/
diff --git a/drivers/net/wireless/ti/Makefile.rej b/drivers/net/wireless/ti/Makefile.rej
deleted file mode 100644
index 7ea384992ee8..000000000000
--- a/drivers/net/wireless/ti/Makefile.rej
+++ /dev/null
@@ -1,10 +0,0 @@
---- drivers/net/wireless/ti/Makefile
-+++ drivers/net/wireless/ti/Makefile
-@@ -3,6 +3,7 @@ obj-$(CONFIG_WLCORE)			+= wlcore/
- obj-$(CONFIG_WL12XX)			+= wl12xx/
- obj-$(CONFIG_WL1251)			+= wl1251/
- obj-$(CONFIG_WL18XX)			+= wl18xx/
-+obj-$(CONFIG_CC33XX)			+= cc33xx/
- 
- # small builtin driver bit
- obj-$(CONFIG_WILINK_PLATFORM_DATA)	+= wilink_platform_data.o
diff --git a/drivers/net/wireless/ti/cc33xx/main.c b/drivers/net/wireless/ti/cc33xx/main.c
index 66fc129f5578..5a6b289f08f7 100644
--- a/drivers/net/wireless/ti/cc33xx/main.c
+++ b/drivers/net/wireless/ti/cc33xx/main.c
@@ -5136,6 +5136,7 @@ static const struct ieee80211_ops cc33xx_ops = {
 	.prepare_multicast = cc33xx_op_prepare_multicast,
 	.configure_filter = cc33xx_op_configure_filter,
 	.tx = cc33xx_op_tx,
+	.wake_tx_queue = ieee80211_handle_wake_tx_queue,
 	.set_key = cc33xx_op_set_key,
 	.hw_scan = cc33xx_op_hw_scan,
 	.cancel_hw_scan = cc33xx_op_cancel_hw_scan,
@@ -5212,6 +5213,7 @@ static const struct ieee80211_ops cc33xx_ops = {
 	.prepare_multicast = cc33xx_op_prepare_multicast,
 	.configure_filter = cc33xx_op_configure_filter,
 	.tx = cc33xx_op_tx,
+	.wake_tx_queue = ieee80211_handle_wake_tx_queue,
 	.set_key = cc33xx_op_set_key,
 	.hw_scan = cc33xx_op_hw_scan,
 	.cancel_hw_scan = cc33xx_op_cancel_hw_scan,
diff --git a/drivers/tty/serial/8250/8250_omap.c.orig b/drivers/tty/serial/8250/8250_omap.c.orig
deleted file mode 100644
index 9ed62bc7cdd8..000000000000
--- a/drivers/tty/serial/8250/8250_omap.c.orig
+++ /dev/null
@@ -1,1854 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * 8250-core based driver for the OMAP internal UART
- *
- * based on omap-serial.c, Copyright (C) 2010 Texas Instruments.
- *
- * Copyright (C) 2014 Sebastian Andrzej Siewior
- *
- */
-
-#include <linux/clk.h>
-#include <linux/device.h>
-#include <linux/io.h>
-#include <linux/module.h>
-#include <linux/serial_8250.h>
-#include <linux/serial_reg.h>
-#include <linux/tty_flip.h>
-#include <linux/platform_device.h>
-#include <linux/slab.h>
-#include <linux/of.h>
-#include <linux/of_gpio.h>
-#include <linux/of_irq.h>
-#include <linux/delay.h>
-#include <linux/pm_runtime.h>
-#include <linux/console.h>
-#include <linux/pm_qos.h>
-#include <linux/pm_wakeirq.h>
-#include <linux/dma-mapping.h>
-#include <linux/sys_soc.h>
-
-#include "8250.h"
-
-#define DEFAULT_CLK_SPEED	48000000
-#define OMAP_UART_REGSHIFT	2
-
-#define UART_ERRATA_i202_MDR1_ACCESS	(1 << 0)
-#define OMAP_UART_WER_HAS_TX_WAKEUP	(1 << 1)
-#define OMAP_DMA_TX_KICK		(1 << 2)
-/*
- * See Advisory 21 in AM437x errata SPRZ408B, updated April 2015.
- * The same errata is applicable to AM335x and DRA7x processors too.
- */
-#define UART_ERRATA_CLOCK_DISABLE	(1 << 3)
-#define	UART_HAS_EFR2			BIT(4)
-#define UART_HAS_RHR_IT_DIS		BIT(5)
-#define UART_RX_TIMEOUT_QUIRK		BIT(6)
-#define UART_HAS_NATIVE_RS485		BIT(7)
-
-#define OMAP_UART_FCR_RX_TRIG		6
-#define OMAP_UART_FCR_TX_TRIG		4
-
-/* SCR register bitmasks */
-#define OMAP_UART_SCR_RX_TRIG_GRANU1_MASK	(1 << 7)
-#define OMAP_UART_SCR_TX_TRIG_GRANU1_MASK	(1 << 6)
-#define OMAP_UART_SCR_TX_EMPTY			(1 << 3)
-#define OMAP_UART_SCR_DMAMODE_MASK		(3 << 1)
-#define OMAP_UART_SCR_DMAMODE_1			(1 << 1)
-#define OMAP_UART_SCR_DMAMODE_CTL		(1 << 0)
-
-/* MVR register bitmasks */
-#define OMAP_UART_MVR_SCHEME_SHIFT	30
-#define OMAP_UART_LEGACY_MVR_MAJ_MASK	0xf0
-#define OMAP_UART_LEGACY_MVR_MAJ_SHIFT	4
-#define OMAP_UART_LEGACY_MVR_MIN_MASK	0x0f
-#define OMAP_UART_MVR_MAJ_MASK		0x700
-#define OMAP_UART_MVR_MAJ_SHIFT		8
-#define OMAP_UART_MVR_MIN_MASK		0x3f
-
-/* SYSC register bitmasks */
-#define OMAP_UART_SYSC_SOFTRESET	(1 << 1)
-
-/* SYSS register bitmasks */
-#define OMAP_UART_SYSS_RESETDONE	(1 << 0)
-
-#define UART_TI752_TLR_TX	0
-#define UART_TI752_TLR_RX	4
-
-#define TRIGGER_TLR_MASK(x)	((x & 0x3c) >> 2)
-#define TRIGGER_FCR_MASK(x)	(x & 3)
-
-/* Enable XON/XOFF flow control on output */
-#define OMAP_UART_SW_TX		0x08
-/* Enable XON/XOFF flow control on input */
-#define OMAP_UART_SW_RX		0x02
-
-#define OMAP_UART_WER_MOD_WKUP	0x7f
-#define OMAP_UART_TX_WAKEUP_EN	(1 << 7)
-
-#define TX_TRIGGER	1
-#define RX_TRIGGER	48
-
-#define OMAP_UART_TCR_RESTORE(x)	((x / 4) << 4)
-#define OMAP_UART_TCR_HALT(x)		((x / 4) << 0)
-
-#define UART_BUILD_REVISION(x, y)	(((x) << 8) | (y))
-
-#define OMAP_UART_REV_46 0x0406
-#define OMAP_UART_REV_52 0x0502
-#define OMAP_UART_REV_63 0x0603
-
-/* Interrupt Enable Register 2 */
-#define UART_OMAP_IER2			0x1B
-#define UART_OMAP_IER2_RHR_IT_DIS	BIT(2)
-
-/* Mode Definition Register 3 */
-#define UART_OMAP_MDR3			0x20
-#define UART_OMAP_MDR3_DIR_POL		BIT(3)
-#define UART_OMAP_MDR3_DIR_EN		BIT(4)
-
-/* Enhanced features register 2 */
-#define UART_OMAP_EFR2			0x23
-#define UART_OMAP_EFR2_TIMEOUT_BEHAVE	BIT(6)
-
-/* RX FIFO occupancy indicator */
-#define UART_OMAP_RX_LVL		0x19
-
-struct omap8250_priv {
-	void __iomem *membase;
-	int line;
-	u8 habit;
-	u8 mdr1;
-	u8 mdr3;
-	u8 efr;
-	u8 scr;
-	u8 wer;
-	u8 xon;
-	u8 xoff;
-	u8 delayed_restore;
-	u16 quot;
-
-	u8 tx_trigger;
-	u8 rx_trigger;
-	bool is_suspending;
-	int wakeirq;
-	int wakeups_enabled;
-	u32 latency;
-	u32 calc_latency;
-	struct pm_qos_request pm_qos_request;
-	struct work_struct qos_work;
-	struct uart_8250_dma omap8250_dma;
-	spinlock_t rx_dma_lock;
-	bool rx_dma_broken;
-	bool throttled;
-};
-
-struct omap8250_dma_params {
-	u32 rx_size;
-	u8 rx_trigger;
-	u8 tx_trigger;
-};
-
-struct omap8250_platdata {
-	struct omap8250_dma_params *dma_params;
-	u8 habit;
-};
-
-#ifdef CONFIG_SERIAL_8250_DMA
-static void omap_8250_rx_dma_flush(struct uart_8250_port *p);
-#else
-static inline void omap_8250_rx_dma_flush(struct uart_8250_port *p) { }
-#endif
-
-static u32 uart_read(struct omap8250_priv *priv, u32 reg)
-{
-	return readl(priv->membase + (reg << OMAP_UART_REGSHIFT));
-}
-
-/* Timeout low and High */
-#define UART_OMAP_TO_L                 0x26
-#define UART_OMAP_TO_H                 0x27
-
-/*
- * Called on runtime PM resume path from omap8250_restore_regs(), and
- * omap8250_set_mctrl().
- */
-static void __omap8250_set_mctrl(struct uart_port *port, unsigned int mctrl)
-{
-	struct uart_8250_port *up = up_to_u8250p(port);
-	struct omap8250_priv *priv = up->port.private_data;
-	u8 lcr;
-
-	serial8250_do_set_mctrl(port, mctrl);
-
-	if (!mctrl_gpio_to_gpiod(up->gpios, UART_GPIO_RTS)) {
-		/*
-		 * Turn off autoRTS if RTS is lowered and restore autoRTS
-		 * setting if RTS is raised
-		 */
-		lcr = serial_in(up, UART_LCR);
-		serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
-		if ((mctrl & TIOCM_RTS) && (port->status & UPSTAT_AUTORTS))
-			priv->efr |= UART_EFR_RTS;
-		else
-			priv->efr &= ~UART_EFR_RTS;
-		serial_out(up, UART_EFR, priv->efr);
-		serial_out(up, UART_LCR, lcr);
-	}
-}
-
-static void omap8250_set_mctrl(struct uart_port *port, unsigned int mctrl)
-{
-	int err;
-
-	err = pm_runtime_resume_and_get(port->dev);
-	if (err)
-		return;
-
-	__omap8250_set_mctrl(port, mctrl);
-
-	pm_runtime_mark_last_busy(port->dev);
-	pm_runtime_put_autosuspend(port->dev);
-}
-
-/*
- * Work Around for Errata i202 (2430, 3430, 3630, 4430 and 4460)
- * The access to uart register after MDR1 Access
- * causes UART to corrupt data.
- *
- * Need a delay =
- * 5 L4 clock cycles + 5 UART functional clock cycle (@48MHz = ~0.2uS)
- * give 10 times as much
- */
-static void omap_8250_mdr1_errataset(struct uart_8250_port *up,
-				     struct omap8250_priv *priv)
-{
-	serial_out(up, UART_OMAP_MDR1, priv->mdr1);
-	udelay(2);
-	serial_out(up, UART_FCR, up->fcr | UART_FCR_CLEAR_XMIT |
-			UART_FCR_CLEAR_RCVR);
-}
-
-static void omap_8250_get_divisor(struct uart_port *port, unsigned int baud,
-				  struct omap8250_priv *priv)
-{
-	unsigned int uartclk = port->uartclk;
-	unsigned int div_13, div_16;
-	unsigned int abs_d13, abs_d16;
-
-	/*
-	 * Old custom speed handling.
-	 */
-	if (baud == 38400 && (port->flags & UPF_SPD_MASK) == UPF_SPD_CUST) {
-		priv->quot = port->custom_divisor & UART_DIV_MAX;
-		/*
-		 * I assume that nobody is using this. But hey, if somebody
-		 * would like to specify the divisor _and_ the mode then the
-		 * driver is ready and waiting for it.
-		 */
-		if (port->custom_divisor & (1 << 16))
-			priv->mdr1 = UART_OMAP_MDR1_13X_MODE;
-		else
-			priv->mdr1 = UART_OMAP_MDR1_16X_MODE;
-		return;
-	}
-	div_13 = DIV_ROUND_CLOSEST(uartclk, 13 * baud);
-	div_16 = DIV_ROUND_CLOSEST(uartclk, 16 * baud);
-
-	if (!div_13)
-		div_13 = 1;
-	if (!div_16)
-		div_16 = 1;
-
-	abs_d13 = abs(baud - uartclk / 13 / div_13);
-	abs_d16 = abs(baud - uartclk / 16 / div_16);
-
-	if (abs_d13 >= abs_d16) {
-		priv->mdr1 = UART_OMAP_MDR1_16X_MODE;
-		priv->quot = div_16;
-	} else {
-		priv->mdr1 = UART_OMAP_MDR1_13X_MODE;
-		priv->quot = div_13;
-	}
-}
-
-static void omap8250_update_scr(struct uart_8250_port *up,
-				struct omap8250_priv *priv)
-{
-	u8 old_scr;
-
-	old_scr = serial_in(up, UART_OMAP_SCR);
-	if (old_scr == priv->scr)
-		return;
-
-	/*
-	 * The manual recommends not to enable the DMA mode selector in the SCR
-	 * (instead of the FCR) register _and_ selecting the DMA mode as one
-	 * register write because this may lead to malfunction.
-	 */
-	if (priv->scr & OMAP_UART_SCR_DMAMODE_MASK)
-		serial_out(up, UART_OMAP_SCR,
-			   priv->scr & ~OMAP_UART_SCR_DMAMODE_MASK);
-	serial_out(up, UART_OMAP_SCR, priv->scr);
-}
-
-static void omap8250_update_mdr1(struct uart_8250_port *up,
-				 struct omap8250_priv *priv)
-{
-	if (priv->habit & UART_ERRATA_i202_MDR1_ACCESS)
-		omap_8250_mdr1_errataset(up, priv);
-	else
-		serial_out(up, UART_OMAP_MDR1, priv->mdr1);
-}
-
-static void omap8250_restore_regs(struct uart_8250_port *up)
-{
-	struct omap8250_priv *priv = up->port.private_data;
-	struct uart_8250_dma	*dma = up->dma;
-	u8 mcr = serial8250_in_MCR(up);
-
-	/* Port locked to synchronize UART_IER access against the console. */
-	lockdep_assert_held_once(&up->port.lock);
-
-	if (dma && dma->tx_running) {
-		/*
-		 * TCSANOW requests the change to occur immediately however if
-		 * we have a TX-DMA operation in progress then it has been
-		 * observed that it might stall and never complete. Therefore we
-		 * delay DMA completes to prevent this hang from happen.
-		 */
-		priv->delayed_restore = 1;
-		return;
-	}
-
-	serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
-	serial_out(up, UART_EFR, UART_EFR_ECB);
-
-	serial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);
-	serial8250_out_MCR(up, mcr | UART_MCR_TCRTLR);
-	serial_out(up, UART_FCR, up->fcr);
-
-	omap8250_update_scr(up, priv);
-
-	serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
-
-	serial_out(up, UART_TI752_TCR, OMAP_UART_TCR_RESTORE(16) |
-			OMAP_UART_TCR_HALT(52));
-	serial_out(up, UART_TI752_TLR,
-		   TRIGGER_TLR_MASK(priv->tx_trigger) << UART_TI752_TLR_TX |
-		   TRIGGER_TLR_MASK(priv->rx_trigger) << UART_TI752_TLR_RX);
-
-	serial_out(up, UART_LCR, 0);
-
-	/* drop TCR + TLR access, we setup XON/XOFF later */
-	serial8250_out_MCR(up, mcr);
-
-	serial_out(up, UART_IER, up->ier);
-
-	serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
-	serial_dl_write(up, priv->quot);
-
-	serial_out(up, UART_EFR, priv->efr);
-
-	/* Configure flow control */
-	serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
-	serial_out(up, UART_XON1, priv->xon);
-	serial_out(up, UART_XOFF1, priv->xoff);
-
-	serial_out(up, UART_LCR, up->lcr);
-
-	omap8250_update_mdr1(up, priv);
-
-	__omap8250_set_mctrl(&up->port, up->port.mctrl);
-
-	serial_out(up, UART_OMAP_MDR3, priv->mdr3);
-
-	if (up->port.rs485.flags & SER_RS485_ENABLED &&
-	    up->port.rs485_config == serial8250_em485_config)
-		serial8250_em485_stop_tx(up);
-}
-
-/*
- * OMAP can use "CLK / (16 or 13) / div" for baud rate. And then we have have
- * some differences in how we want to handle flow control.
- */
-static void omap_8250_set_termios(struct uart_port *port,
-				  struct ktermios *termios,
-				  const struct ktermios *old)
-{
-	struct uart_8250_port *up = up_to_u8250p(port);
-	struct omap8250_priv *priv = up->port.private_data;
-	unsigned char cval = 0;
-	unsigned int baud;
-
-	cval = UART_LCR_WLEN(tty_get_char_size(termios->c_cflag));
-
-	if (termios->c_cflag & CSTOPB)
-		cval |= UART_LCR_STOP;
-	if (termios->c_cflag & PARENB)
-		cval |= UART_LCR_PARITY;
-	if (!(termios->c_cflag & PARODD))
-		cval |= UART_LCR_EPAR;
-	if (termios->c_cflag & CMSPAR)
-		cval |= UART_LCR_SPAR;
-
-	/*
-	 * Ask the core to calculate the divisor for us.
-	 */
-	baud = uart_get_baud_rate(port, termios, old,
-				  port->uartclk / 16 / UART_DIV_MAX,
-				  port->uartclk / 13);
-	omap_8250_get_divisor(port, baud, priv);
-
-	/*
-	 * Ok, we're now changing the port state. Do it with
-	 * interrupts disabled.
-	 */
-	pm_runtime_get_sync(port->dev);
-	spin_lock_irq(&port->lock);
-
-	/*
-	 * Update the per-port timeout.
-	 */
-	uart_update_timeout(port, termios->c_cflag, baud);
-
-	up->port.read_status_mask = UART_LSR_OE | UART_LSR_THRE | UART_LSR_DR;
-	if (termios->c_iflag & INPCK)
-		up->port.read_status_mask |= UART_LSR_FE | UART_LSR_PE;
-	if (termios->c_iflag & (IGNBRK | PARMRK))
-		up->port.read_status_mask |= UART_LSR_BI;
-
-	/*
-	 * Characters to ignore
-	 */
-	up->port.ignore_status_mask = 0;
-	if (termios->c_iflag & IGNPAR)
-		up->port.ignore_status_mask |= UART_LSR_PE | UART_LSR_FE;
-	if (termios->c_iflag & IGNBRK) {
-		up->port.ignore_status_mask |= UART_LSR_BI;
-		/*
-		 * If we're ignoring parity and break indicators,
-		 * ignore overruns too (for real raw support).
-		 */
-		if (termios->c_iflag & IGNPAR)
-			up->port.ignore_status_mask |= UART_LSR_OE;
-	}
-
-	/*
-	 * ignore all characters if CREAD is not set
-	 */
-	if ((termios->c_cflag & CREAD) == 0)
-		up->port.ignore_status_mask |= UART_LSR_DR;
-
-	/*
-	 * Modem status interrupts
-	 */
-	up->ier &= ~UART_IER_MSI;
-	if (UART_ENABLE_MS(&up->port, termios->c_cflag))
-		up->ier |= UART_IER_MSI;
-
-	up->lcr = cval;
-	/* Up to here it was mostly serial8250_do_set_termios() */
-
-	/*
-	 * We enable TRIG_GRANU for RX and TX and additionally we set
-	 * SCR_TX_EMPTY bit. The result is the following:
-	 * - RX_TRIGGER amount of bytes in the FIFO will cause an interrupt.
-	 * - less than RX_TRIGGER number of bytes will also cause an interrupt
-	 *   once the UART decides that there no new bytes arriving.
-	 * - Once THRE is enabled, the interrupt will be fired once the FIFO is
-	 *   empty - the trigger level is ignored here.
-	 *
-	 * Once DMA is enabled:
-	 * - UART will assert the TX DMA line once there is room for TX_TRIGGER
-	 *   bytes in the TX FIFO. On each assert the DMA engine will move
-	 *   TX_TRIGGER bytes into the FIFO.
-	 * - UART will assert the RX DMA line once there are RX_TRIGGER bytes in
-	 *   the FIFO and move RX_TRIGGER bytes.
-	 * This is because threshold and trigger values are the same.
-	 */
-	up->fcr = UART_FCR_ENABLE_FIFO;
-	up->fcr |= TRIGGER_FCR_MASK(priv->tx_trigger) << OMAP_UART_FCR_TX_TRIG;
-	up->fcr |= TRIGGER_FCR_MASK(priv->rx_trigger) << OMAP_UART_FCR_RX_TRIG;
-
-	priv->scr = OMAP_UART_SCR_RX_TRIG_GRANU1_MASK | OMAP_UART_SCR_TX_EMPTY |
-		OMAP_UART_SCR_TX_TRIG_GRANU1_MASK;
-
-	if (up->dma)
-		priv->scr |= OMAP_UART_SCR_DMAMODE_1 |
-			OMAP_UART_SCR_DMAMODE_CTL;
-
-	priv->xon = termios->c_cc[VSTART];
-	priv->xoff = termios->c_cc[VSTOP];
-
-	priv->efr = 0;
-	up->port.status &= ~(UPSTAT_AUTOCTS | UPSTAT_AUTORTS | UPSTAT_AUTOXOFF);
-
-	if (termios->c_cflag & CRTSCTS && up->port.flags & UPF_HARD_FLOW &&
-	    !mctrl_gpio_to_gpiod(up->gpios, UART_GPIO_RTS) &&
-	    !mctrl_gpio_to_gpiod(up->gpios, UART_GPIO_CTS)) {
-		/* Enable AUTOCTS (autoRTS is enabled when RTS is raised) */
-		up->port.status |= UPSTAT_AUTOCTS | UPSTAT_AUTORTS;
-		priv->efr |= UART_EFR_CTS;
-	} else	if (up->port.flags & UPF_SOFT_FLOW) {
-		/*
-		 * OMAP rx s/w flow control is borked; the transmitter remains
-		 * stuck off even if rx flow control is subsequently disabled
-		 */
-
-		/*
-		 * IXOFF Flag:
-		 * Enable XON/XOFF flow control on output.
-		 * Transmit XON1, XOFF1
-		 */
-		if (termios->c_iflag & IXOFF) {
-			up->port.status |= UPSTAT_AUTOXOFF;
-			priv->efr |= OMAP_UART_SW_TX;
-		}
-	}
-	omap8250_restore_regs(up);
-
-	spin_unlock_irq(&up->port.lock);
-	pm_runtime_mark_last_busy(port->dev);
-	pm_runtime_put_autosuspend(port->dev);
-
-	/* calculate wakeup latency constraint */
-	priv->calc_latency = USEC_PER_SEC * 64 * 8 / baud;
-	priv->latency = priv->calc_latency;
-
-	schedule_work(&priv->qos_work);
-
-	/* Don't rewrite B0 */
-	if (tty_termios_baud_rate(termios))
-		tty_termios_encode_baud_rate(termios, baud, baud);
-}
-
-/* same as 8250 except that we may have extra flow bits set in EFR */
-static void omap_8250_pm(struct uart_port *port, unsigned int state,
-			 unsigned int oldstate)
-{
-	struct uart_8250_port *up = up_to_u8250p(port);
-	u8 efr;
-
-	pm_runtime_get_sync(port->dev);
-
-	/* Synchronize UART_IER access against the console. */
-	spin_lock_irq(&port->lock);
-
-	serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
-	efr = serial_in(up, UART_EFR);
-	serial_out(up, UART_EFR, efr | UART_EFR_ECB);
-	serial_out(up, UART_LCR, 0);
-
-	serial_out(up, UART_IER, (state != 0) ? UART_IERX_SLEEP : 0);
-	serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
-	serial_out(up, UART_EFR, efr);
-	serial_out(up, UART_LCR, 0);
-
-	spin_unlock_irq(&port->lock);
-
-	pm_runtime_mark_last_busy(port->dev);
-	pm_runtime_put_autosuspend(port->dev);
-}
-
-static void omap_serial_fill_features_erratas(struct uart_8250_port *up,
-					      struct omap8250_priv *priv)
-{
-	static const struct soc_device_attribute k3_soc_devices[] = {
-		{ .family = "AM65X",  },
-		{ .family = "J721E", .revision = "SR1.0" },
-		{ /* sentinel */ }
-	};
-	u32 mvr, scheme;
-	u16 revision, major, minor;
-
-	mvr = uart_read(priv, UART_OMAP_MVER);
-
-	/* Check revision register scheme */
-	scheme = mvr >> OMAP_UART_MVR_SCHEME_SHIFT;
-
-	switch (scheme) {
-	case 0: /* Legacy Scheme: OMAP2/3 */
-		/* MINOR_REV[0:4], MAJOR_REV[4:7] */
-		major = (mvr & OMAP_UART_LEGACY_MVR_MAJ_MASK) >>
-			OMAP_UART_LEGACY_MVR_MAJ_SHIFT;
-		minor = (mvr & OMAP_UART_LEGACY_MVR_MIN_MASK);
-		break;
-	case 1:
-		/* New Scheme: OMAP4+ */
-		/* MINOR_REV[0:5], MAJOR_REV[8:10] */
-		major = (mvr & OMAP_UART_MVR_MAJ_MASK) >>
-			OMAP_UART_MVR_MAJ_SHIFT;
-		minor = (mvr & OMAP_UART_MVR_MIN_MASK);
-		break;
-	default:
-		dev_warn(up->port.dev,
-			 "Unknown revision, defaulting to highest\n");
-		/* highest possible revision */
-		major = 0xff;
-		minor = 0xff;
-	}
-	/* normalize revision for the driver */
-	revision = UART_BUILD_REVISION(major, minor);
-
-	switch (revision) {
-	case OMAP_UART_REV_46:
-		priv->habit |= UART_ERRATA_i202_MDR1_ACCESS;
-		break;
-	case OMAP_UART_REV_52:
-		priv->habit |= UART_ERRATA_i202_MDR1_ACCESS |
-				OMAP_UART_WER_HAS_TX_WAKEUP;
-		break;
-	case OMAP_UART_REV_63:
-		priv->habit |= UART_ERRATA_i202_MDR1_ACCESS |
-			OMAP_UART_WER_HAS_TX_WAKEUP;
-		break;
-	default:
-		break;
-	}
-
-	/*
-	 * AM65x SR1.0, AM65x SR2.0 and J721e SR1.0 don't
-	 * don't have RHR_IT_DIS bit in IER2 register. So drop to flag
-	 * to enable errata workaround.
-	 */
-	if (soc_device_match(k3_soc_devices))
-		priv->habit &= ~UART_HAS_RHR_IT_DIS;
-}
-
-static void omap8250_uart_qos_work(struct work_struct *work)
-{
-	struct omap8250_priv *priv;
-
-	priv = container_of(work, struct omap8250_priv, qos_work);
-	cpu_latency_qos_update_request(&priv->pm_qos_request, priv->latency);
-}
-
-#ifdef CONFIG_SERIAL_8250_DMA
-static int omap_8250_dma_handle_irq(struct uart_port *port);
-#endif
-
-static irqreturn_t omap8250_irq(int irq, void *dev_id)
-{
-	struct omap8250_priv *priv = dev_id;
-	struct uart_8250_port *up = serial8250_get_port(priv->line);
-	struct uart_port *port = &up->port;
-	unsigned int iir, lsr;
-	int ret;
-
-#ifdef CONFIG_SERIAL_8250_DMA
-	if (up->dma) {
-		ret = omap_8250_dma_handle_irq(port);
-		return IRQ_RETVAL(ret);
-	}
-#endif
-
-	serial8250_rpm_get(up);
-	lsr = serial_port_in(port, UART_LSR);
-	iir = serial_port_in(port, UART_IIR);
-	ret = serial8250_handle_irq(port, iir);
-
-	/*
-	 * On K3 SoCs, it is observed that RX TIMEOUT is signalled after
-	 * FIFO has been drained or erroneously.
-	 * So apply solution of Errata i2310 as mentioned in
-	 * https://www.ti.com/lit/pdf/sprz536
-	 */
-	if (priv->habit & UART_RX_TIMEOUT_QUIRK &&
-	    (iir & UART_IIR_RX_TIMEOUT) == UART_IIR_RX_TIMEOUT &&
-	    serial_port_in(port, UART_OMAP_RX_LVL) == 0) {
-		unsigned char efr2, timeout_h, timeout_l;
-
-		efr2 = serial_in(up, UART_OMAP_EFR2);
-		timeout_h = serial_in(up, UART_OMAP_TO_H);
-		timeout_l = serial_in(up, UART_OMAP_TO_L);
-		serial_out(up, UART_OMAP_TO_H, 0xFF);
-		serial_out(up, UART_OMAP_TO_L, 0xFF);
-		serial_out(up, UART_OMAP_EFR2, UART_OMAP_EFR2_TIMEOUT_BEHAVE);
-		serial_in(up, UART_IIR);
-		serial_out(up, UART_OMAP_EFR2, efr2);
-		serial_out(up, UART_OMAP_TO_H, timeout_h);
-		serial_out(up, UART_OMAP_TO_L, timeout_l);
-	}
-
-	/* Stop processing interrupts on input overrun */
-	if ((lsr & UART_LSR_OE) && up->overrun_backoff_time_ms > 0) {
-		unsigned long delay;
-
-		/* Synchronize UART_IER access against the console. */
-		spin_lock(&port->lock);
-		up->ier = port->serial_in(port, UART_IER);
-		if (up->ier & (UART_IER_RLSI | UART_IER_RDI)) {
-			port->ops->stop_rx(port);
-		} else {
-			/* Keep restarting the timer until
-			 * the input overrun subsides.
-			 */
-			cancel_delayed_work(&up->overrun_backoff);
-		}
-		spin_unlock(&port->lock);
-
-		delay = msecs_to_jiffies(up->overrun_backoff_time_ms);
-		schedule_delayed_work(&up->overrun_backoff, delay);
-	}
-
-	serial8250_rpm_put(up);
-
-	return IRQ_RETVAL(ret);
-}
-
-static int omap_8250_startup(struct uart_port *port)
-{
-	struct uart_8250_port *up = up_to_u8250p(port);
-	struct omap8250_priv *priv = port->private_data;
-	struct uart_8250_dma *dma = &priv->omap8250_dma;
-	int ret;
-
-	if (priv->wakeirq) {
-		ret = dev_pm_set_dedicated_wake_irq(port->dev, priv->wakeirq);
-		if (ret)
-			return ret;
-	}
-
-	pm_runtime_get_sync(port->dev);
-
-	serial_out(up, UART_FCR, UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);
-
-	serial_out(up, UART_LCR, UART_LCR_WLEN8);
-
-	up->lsr_saved_flags = 0;
-	up->msr_saved_flags = 0;
-
-	/* Disable DMA for console UART */
-	if (dma->fn && !uart_console(port)) {
-		up->dma = &priv->omap8250_dma;
-		ret = serial8250_request_dma(up);
-		if (ret) {
-			dev_warn_ratelimited(port->dev,
-					     "failed to request DMA\n");
-			up->dma = NULL;
-		}
-	} else {
-		up->dma = NULL;
-	}
-
-	/* Synchronize UART_IER access against the console. */
-	spin_lock_irq(&port->lock);
-	up->ier = UART_IER_RLSI | UART_IER_RDI;
-	serial_out(up, UART_IER, up->ier);
-	spin_unlock_irq(&port->lock);
-
-#ifdef CONFIG_PM
-	up->capabilities |= UART_CAP_RPM;
-#endif
-
-	/* Enable module level wake up */
-	priv->wer = OMAP_UART_WER_MOD_WKUP;
-	if (priv->habit & OMAP_UART_WER_HAS_TX_WAKEUP)
-		priv->wer |= OMAP_UART_TX_WAKEUP_EN;
-	serial_out(up, UART_OMAP_WER, priv->wer);
-
-	if (up->dma && !(priv->habit & UART_HAS_EFR2)) {
-		spin_lock_irq(&port->lock);
-		up->dma->rx_dma(up);
-		spin_unlock_irq(&port->lock);
-	}
-
-	enable_irq(up->port.irq);
-
-	pm_runtime_mark_last_busy(port->dev);
-	pm_runtime_put_autosuspend(port->dev);
-	return 0;
-}
-
-static void omap_8250_shutdown(struct uart_port *port)
-{
-	struct uart_8250_port *up = up_to_u8250p(port);
-	struct omap8250_priv *priv = port->private_data;
-
-	pm_runtime_get_sync(port->dev);
-
-	flush_work(&priv->qos_work);
-	if (up->dma)
-		omap_8250_rx_dma_flush(up);
-
-	serial_out(up, UART_OMAP_WER, 0);
-	if (priv->habit & UART_HAS_EFR2)
-		serial_out(up, UART_OMAP_EFR2, 0x0);
-
-	/* Synchronize UART_IER access against the console. */
-	spin_lock_irq(&port->lock);
-	up->ier = 0;
-	serial_out(up, UART_IER, 0);
-	spin_unlock_irq(&port->lock);
-	disable_irq_nosync(up->port.irq);
-	dev_pm_clear_wake_irq(port->dev);
-
-	serial8250_release_dma(up);
-	up->dma = NULL;
-
-	/*
-	 * Disable break condition and FIFOs
-	 */
-	if (up->lcr & UART_LCR_SBC)
-		serial_out(up, UART_LCR, up->lcr & ~UART_LCR_SBC);
-	serial_out(up, UART_FCR, UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);
-
-	pm_runtime_mark_last_busy(port->dev);
-	pm_runtime_put_autosuspend(port->dev);
-}
-
-static void omap_8250_throttle(struct uart_port *port)
-{
-	struct omap8250_priv *priv = port->private_data;
-	unsigned long flags;
-
-	pm_runtime_get_sync(port->dev);
-
-	spin_lock_irqsave(&port->lock, flags);
-	port->ops->stop_rx(port);
-	priv->throttled = true;
-	spin_unlock_irqrestore(&port->lock, flags);
-
-	pm_runtime_mark_last_busy(port->dev);
-	pm_runtime_put_autosuspend(port->dev);
-}
-
-static void omap_8250_unthrottle(struct uart_port *port)
-{
-	struct omap8250_priv *priv = port->private_data;
-	struct uart_8250_port *up = up_to_u8250p(port);
-	unsigned long flags;
-
-	pm_runtime_get_sync(port->dev);
-
-	/* Synchronize UART_IER access against the console. */
-	spin_lock_irqsave(&port->lock, flags);
-	priv->throttled = false;
-	if (up->dma)
-		up->dma->rx_dma(up);
-	up->ier |= UART_IER_RLSI | UART_IER_RDI;
-	port->read_status_mask |= UART_LSR_DR;
-	serial_out(up, UART_IER, up->ier);
-	spin_unlock_irqrestore(&port->lock, flags);
-
-	pm_runtime_mark_last_busy(port->dev);
-	pm_runtime_put_autosuspend(port->dev);
-}
-
-static int omap8250_rs485_config(struct uart_port *port,
-				 struct ktermios *termios,
-				 struct serial_rs485 *rs485)
-{
-	struct omap8250_priv *priv = port->private_data;
-	struct uart_8250_port *up = up_to_u8250p(port);
-	u32 fixed_delay_rts_before_send = 0;
-	u32 fixed_delay_rts_after_send = 0;
-	unsigned int baud;
-
-	/*
-	 * There is a fixed delay of 3 bit clock cycles after the TX shift
-	 * register is going empty to allow time for the stop bit to transition
-	 * through the transceiver before direction is changed to receive.
-	 *
-	 * Additionally there appears to be a 1 bit clock delay between writing
-	 * to the THR register and transmission of the start bit, per page 8783
-	 * of the AM65 TRM:  https://www.ti.com/lit/ug/spruid7e/spruid7e.pdf
-	 */
-	if (priv->quot) {
-		if (priv->mdr1 == UART_OMAP_MDR1_16X_MODE)
-			baud = port->uartclk / (16 * priv->quot);
-		else
-			baud = port->uartclk / (13 * priv->quot);
-
-		fixed_delay_rts_after_send  = 3 * MSEC_PER_SEC / baud;
-		fixed_delay_rts_before_send = 1 * MSEC_PER_SEC / baud;
-	}
-
-	/*
-	 * Fall back to RS485 software emulation if the UART is missing
-	 * hardware support, if the device tree specifies an mctrl_gpio
-	 * (indicates that RTS is unavailable due to a pinmux conflict)
-	 * or if the requested delays exceed the fixed hardware delays.
-	 */
-	if (!(priv->habit & UART_HAS_NATIVE_RS485) ||
-	    mctrl_gpio_to_gpiod(up->gpios, UART_GPIO_RTS) ||
-	    rs485->delay_rts_after_send  > fixed_delay_rts_after_send ||
-	    rs485->delay_rts_before_send > fixed_delay_rts_before_send) {
-		priv->mdr3 &= ~UART_OMAP_MDR3_DIR_EN;
-		serial_out(up, UART_OMAP_MDR3, priv->mdr3);
-
-		port->rs485_config = serial8250_em485_config;
-		return serial8250_em485_config(port, termios, rs485);
-	}
-
-	rs485->delay_rts_after_send  = fixed_delay_rts_after_send;
-	rs485->delay_rts_before_send = fixed_delay_rts_before_send;
-
-	if (rs485->flags & SER_RS485_ENABLED)
-		priv->mdr3 |= UART_OMAP_MDR3_DIR_EN;
-	else
-		priv->mdr3 &= ~UART_OMAP_MDR3_DIR_EN;
-
-	/*
-	 * Retain same polarity semantics as RS485 software emulation,
-	 * i.e. SER_RS485_RTS_ON_SEND means driving RTS low on send.
-	 */
-	if (rs485->flags & SER_RS485_RTS_ON_SEND)
-		priv->mdr3 &= ~UART_OMAP_MDR3_DIR_POL;
-	else
-		priv->mdr3 |= UART_OMAP_MDR3_DIR_POL;
-
-	serial_out(up, UART_OMAP_MDR3, priv->mdr3);
-
-	return 0;
-}
-
-#ifdef CONFIG_SERIAL_8250_DMA
-static int omap_8250_rx_dma(struct uart_8250_port *p);
-
-/* Must be called while priv->rx_dma_lock is held */
-static void __dma_rx_do_complete(struct uart_8250_port *p)
-{
-	struct uart_8250_dma    *dma = p->dma;
-	struct tty_port         *tty_port = &p->port.state->port;
-	struct omap8250_priv	*priv = p->port.private_data;
-	struct dma_chan		*rxchan = dma->rxchan;
-	dma_cookie_t		cookie;
-	struct dma_tx_state     state;
-	int                     count;
-	int			ret;
-	u32			reg;
-
-	if (!dma->rx_running)
-		goto out;
-
-	cookie = dma->rx_cookie;
-	dma->rx_running = 0;
-
-	/* Re-enable RX FIFO interrupt now that transfer is complete */
-	if (priv->habit & UART_HAS_RHR_IT_DIS) {
-		reg = serial_in(p, UART_OMAP_IER2);
-		reg &= ~UART_OMAP_IER2_RHR_IT_DIS;
-		serial_out(p, UART_OMAP_IER2, reg);
-	}
-
-	dmaengine_tx_status(rxchan, cookie, &state);
-
-	count = dma->rx_size - state.residue + state.in_flight_bytes;
-	if (count < dma->rx_size) {
-		dmaengine_terminate_async(rxchan);
-
-		/*
-		 * Poll for teardown to complete which guarantees in
-		 * flight data is drained.
-		 */
-		if (state.in_flight_bytes) {
-			int poll_count = 25;
-
-			while (dmaengine_tx_status(rxchan, cookie, NULL) &&
-			       poll_count--)
-				cpu_relax();
-
-			if (poll_count == -1)
-				dev_err(p->port.dev, "teardown incomplete\n");
-		}
-	}
-	if (!count)
-		goto out;
-	ret = tty_insert_flip_string(tty_port, dma->rx_buf, count);
-
-	p->port.icount.rx += ret;
-	p->port.icount.buf_overrun += count - ret;
-out:
-
-	tty_flip_buffer_push(tty_port);
-}
-
-static void __dma_rx_complete(void *param)
-{
-	struct uart_8250_port *p = param;
-	struct omap8250_priv *priv = p->port.private_data;
-	struct uart_8250_dma *dma = p->dma;
-	struct dma_tx_state     state;
-	unsigned long flags;
-
-	/* Synchronize UART_IER access against the console. */
-	spin_lock_irqsave(&p->port.lock, flags);
-
-	/*
-	 * If the tx status is not DMA_COMPLETE, then this is a delayed
-	 * completion callback. A previous RX timeout flush would have
-	 * already pushed the data, so exit.
-	 */
-	if (dmaengine_tx_status(dma->rxchan, dma->rx_cookie, &state) !=
-			DMA_COMPLETE) {
-		spin_unlock_irqrestore(&p->port.lock, flags);
-		return;
-	}
-	__dma_rx_do_complete(p);
-	if (!priv->throttled) {
-		p->ier |= UART_IER_RLSI | UART_IER_RDI;
-		serial_out(p, UART_IER, p->ier);
-		if (!(priv->habit & UART_HAS_EFR2))
-			omap_8250_rx_dma(p);
-	}
-
-	spin_unlock_irqrestore(&p->port.lock, flags);
-}
-
-static void omap_8250_rx_dma_flush(struct uart_8250_port *p)
-{
-	struct omap8250_priv	*priv = p->port.private_data;
-	struct uart_8250_dma	*dma = p->dma;
-	struct dma_tx_state     state;
-	unsigned long		flags;
-	int ret;
-
-	spin_lock_irqsave(&priv->rx_dma_lock, flags);
-
-	if (!dma->rx_running) {
-		spin_unlock_irqrestore(&priv->rx_dma_lock, flags);
-		return;
-	}
-
-	ret = dmaengine_tx_status(dma->rxchan, dma->rx_cookie, &state);
-	if (ret == DMA_IN_PROGRESS) {
-		ret = dmaengine_pause(dma->rxchan);
-		if (WARN_ON_ONCE(ret))
-			priv->rx_dma_broken = true;
-	}
-	__dma_rx_do_complete(p);
-	spin_unlock_irqrestore(&priv->rx_dma_lock, flags);
-}
-
-static int omap_8250_rx_dma(struct uart_8250_port *p)
-{
-	struct omap8250_priv		*priv = p->port.private_data;
-	struct uart_8250_dma            *dma = p->dma;
-	int				err = 0;
-	struct dma_async_tx_descriptor  *desc;
-	unsigned long			flags;
-	u32				reg;
-
-	/* Port locked to synchronize UART_IER access against the console. */
-	lockdep_assert_held_once(&p->port.lock);
-
-	if (priv->rx_dma_broken)
-		return -EINVAL;
-
-	spin_lock_irqsave(&priv->rx_dma_lock, flags);
-
-	if (dma->rx_running) {
-		enum dma_status state;
-
-		state = dmaengine_tx_status(dma->rxchan, dma->rx_cookie, NULL);
-		if (state == DMA_COMPLETE) {
-			/*
-			 * Disable RX interrupts to allow RX DMA completion
-			 * callback to run.
-			 */
-			p->ier &= ~(UART_IER_RLSI | UART_IER_RDI);
-			serial_out(p, UART_IER, p->ier);
-		}
-		goto out;
-	}
-
-	desc = dmaengine_prep_slave_single(dma->rxchan, dma->rx_addr,
-					   dma->rx_size, DMA_DEV_TO_MEM,
-					   DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
-	if (!desc) {
-		err = -EBUSY;
-		goto out;
-	}
-
-	dma->rx_running = 1;
-	desc->callback = __dma_rx_complete;
-	desc->callback_param = p;
-
-	dma->rx_cookie = dmaengine_submit(desc);
-
-	/*
-	 * Disable RX FIFO interrupt while RX DMA is enabled, else
-	 * spurious interrupt may be raised when data is in the RX FIFO
-	 * but is yet to be drained by DMA.
-	 */
-	if (priv->habit & UART_HAS_RHR_IT_DIS) {
-		reg = serial_in(p, UART_OMAP_IER2);
-		reg |= UART_OMAP_IER2_RHR_IT_DIS;
-		serial_out(p, UART_OMAP_IER2, reg);
-	}
-
-	dma_async_issue_pending(dma->rxchan);
-out:
-	spin_unlock_irqrestore(&priv->rx_dma_lock, flags);
-	return err;
-}
-
-static int omap_8250_tx_dma(struct uart_8250_port *p);
-
-static void omap_8250_dma_tx_complete(void *param)
-{
-	struct uart_8250_port	*p = param;
-	struct uart_8250_dma	*dma = p->dma;
-	struct circ_buf		*xmit = &p->port.state->xmit;
-	unsigned long		flags;
-	bool			en_thri = false;
-	struct omap8250_priv	*priv = p->port.private_data;
-
-	dma_sync_single_for_cpu(dma->txchan->device->dev, dma->tx_addr,
-				UART_XMIT_SIZE, DMA_TO_DEVICE);
-
-	spin_lock_irqsave(&p->port.lock, flags);
-
-	dma->tx_running = 0;
-
-	uart_xmit_advance(&p->port, dma->tx_size);
-
-	if (priv->delayed_restore) {
-		priv->delayed_restore = 0;
-		omap8250_restore_regs(p);
-	}
-
-	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
-		uart_write_wakeup(&p->port);
-
-	if (!uart_circ_empty(xmit) && !uart_tx_stopped(&p->port)) {
-		int ret;
-
-		ret = omap_8250_tx_dma(p);
-		if (ret)
-			en_thri = true;
-	} else if (p->capabilities & UART_CAP_RPM) {
-		en_thri = true;
-	}
-
-	if (en_thri) {
-		dma->tx_err = 1;
-		serial8250_set_THRI(p);
-	}
-
-	spin_unlock_irqrestore(&p->port.lock, flags);
-}
-
-static int omap_8250_tx_dma(struct uart_8250_port *p)
-{
-	struct uart_8250_dma		*dma = p->dma;
-	struct omap8250_priv		*priv = p->port.private_data;
-	struct circ_buf			*xmit = &p->port.state->xmit;
-	struct dma_async_tx_descriptor	*desc;
-	unsigned int	skip_byte = 0;
-	int ret;
-
-	if (dma->tx_running)
-		return 0;
-	if (uart_tx_stopped(&p->port) || uart_circ_empty(xmit)) {
-
-		/*
-		 * Even if no data, we need to return an error for the two cases
-		 * below so serial8250_tx_chars() is invoked and properly clears
-		 * THRI and/or runtime suspend.
-		 */
-		if (dma->tx_err || p->capabilities & UART_CAP_RPM) {
-			ret = -EBUSY;
-			goto err;
-		}
-		serial8250_clear_THRI(p);
-		return 0;
-	}
-
-	dma->tx_size = CIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE);
-	if (priv->habit & OMAP_DMA_TX_KICK) {
-		u8 tx_lvl;
-
-		/*
-		 * We need to put the first byte into the FIFO in order to start
-		 * the DMA transfer. For transfers smaller than four bytes we
-		 * don't bother doing DMA at all. It seem not matter if there
-		 * are still bytes in the FIFO from the last transfer (in case
-		 * we got here directly from omap_8250_dma_tx_complete()). Bytes
-		 * leaving the FIFO seem not to trigger the DMA transfer. It is
-		 * really the byte that we put into the FIFO.
-		 * If the FIFO is already full then we most likely got here from
-		 * omap_8250_dma_tx_complete(). And this means the DMA engine
-		 * just completed its work. We don't have to wait the complete
-		 * 86us at 115200,8n1 but around 60us (not to mention lower
-		 * baudrates). So in that case we take the interrupt and try
-		 * again with an empty FIFO.
-		 */
-		tx_lvl = serial_in(p, UART_OMAP_TX_LVL);
-		if (tx_lvl == p->tx_loadsz) {
-			ret = -EBUSY;
-			goto err;
-		}
-		if (dma->tx_size < 4) {
-			ret = -EINVAL;
-			goto err;
-		}
-		skip_byte = 1;
-	}
-
-	desc = dmaengine_prep_slave_single(dma->txchan,
-			dma->tx_addr + xmit->tail + skip_byte,
-			dma->tx_size - skip_byte, DMA_MEM_TO_DEV,
-			DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
-	if (!desc) {
-		ret = -EBUSY;
-		goto err;
-	}
-
-	dma->tx_running = 1;
-
-	desc->callback = omap_8250_dma_tx_complete;
-	desc->callback_param = p;
-
-	dma->tx_cookie = dmaengine_submit(desc);
-
-	dma_sync_single_for_device(dma->txchan->device->dev, dma->tx_addr,
-				   UART_XMIT_SIZE, DMA_TO_DEVICE);
-
-	dma_async_issue_pending(dma->txchan);
-	if (dma->tx_err)
-		dma->tx_err = 0;
-
-	serial8250_clear_THRI(p);
-	if (skip_byte)
-		serial_out(p, UART_TX, xmit->buf[xmit->tail]);
-	return 0;
-err:
-	dma->tx_err = 1;
-	return ret;
-}
-
-static bool handle_rx_dma(struct uart_8250_port *up, unsigned int iir)
-{
-	switch (iir & 0x3f) {
-	case UART_IIR_RLSI:
-	case UART_IIR_RX_TIMEOUT:
-	case UART_IIR_RDI:
-		omap_8250_rx_dma_flush(up);
-		return true;
-	}
-	return omap_8250_rx_dma(up);
-}
-
-static u16 omap_8250_handle_rx_dma(struct uart_8250_port *up, u8 iir, u16 status)
-{
-	if ((status & (UART_LSR_DR | UART_LSR_BI)) &&
-	    (iir & UART_IIR_RDI)) {
-		if (handle_rx_dma(up, iir)) {
-			status = serial8250_rx_chars(up, status);
-			omap_8250_rx_dma(up);
-		}
-	}
-
-	return status;
-}
-
-static void am654_8250_handle_rx_dma(struct uart_8250_port *up, u8 iir,
-				     u16 status)
-{
-	/* Port locked to synchronize UART_IER access against the console. */
-	lockdep_assert_held_once(&up->port.lock);
-
-	/*
-	 * Queue a new transfer if FIFO has data.
-	 */
-	if ((status & (UART_LSR_DR | UART_LSR_BI)) &&
-	    (up->ier & UART_IER_RDI)) {
-		omap_8250_rx_dma(up);
-		serial_out(up, UART_OMAP_EFR2, UART_OMAP_EFR2_TIMEOUT_BEHAVE);
-	} else if ((iir & 0x3f) == UART_IIR_RX_TIMEOUT) {
-		/*
-		 * Disable RX timeout, read IIR to clear
-		 * current timeout condition, clear EFR2 to
-		 * periodic timeouts, re-enable interrupts.
-		 */
-		up->ier &= ~(UART_IER_RLSI | UART_IER_RDI);
-		serial_out(up, UART_IER, up->ier);
-		omap_8250_rx_dma_flush(up);
-		serial_in(up, UART_IIR);
-		serial_out(up, UART_OMAP_EFR2, 0x0);
-		up->ier |= UART_IER_RLSI | UART_IER_RDI;
-		serial_out(up, UART_IER, up->ier);
-	}
-}
-
-/*
- * This is mostly serial8250_handle_irq(). We have a slightly different DMA
- * hoook for RX/TX and need different logic for them in the ISR. Therefore we
- * use the default routine in the non-DMA case and this one for with DMA.
- */
-static int omap_8250_dma_handle_irq(struct uart_port *port)
-{
-	struct uart_8250_port *up = up_to_u8250p(port);
-	struct omap8250_priv *priv = up->port.private_data;
-	u16 status;
-	u8 iir;
-
-	serial8250_rpm_get(up);
-
-	iir = serial_port_in(port, UART_IIR);
-	if (iir & UART_IIR_NO_INT) {
-		serial8250_rpm_put(up);
-		return IRQ_HANDLED;
-	}
-
-	spin_lock(&port->lock);
-
-	status = serial_port_in(port, UART_LSR);
-
-	if ((iir & 0x3f) != UART_IIR_THRI) {
-		if (priv->habit & UART_HAS_EFR2)
-			am654_8250_handle_rx_dma(up, iir, status);
-		else
-			status = omap_8250_handle_rx_dma(up, iir, status);
-	}
-
-	serial8250_modem_status(up);
-	if (status & UART_LSR_THRE && up->dma->tx_err) {
-		if (uart_tx_stopped(&up->port) ||
-		    uart_circ_empty(&up->port.state->xmit)) {
-			up->dma->tx_err = 0;
-			serial8250_tx_chars(up);
-		} else  {
-			/*
-			 * try again due to an earlier failer which
-			 * might have been resolved by now.
-			 */
-			if (omap_8250_tx_dma(up))
-				serial8250_tx_chars(up);
-		}
-	}
-
-	uart_unlock_and_check_sysrq(port);
-
-	serial8250_rpm_put(up);
-	return 1;
-}
-
-static bool the_no_dma_filter_fn(struct dma_chan *chan, void *param)
-{
-	return false;
-}
-
-#else
-
-static inline int omap_8250_rx_dma(struct uart_8250_port *p)
-{
-	return -EINVAL;
-}
-#endif
-
-static int omap8250_no_handle_irq(struct uart_port *port)
-{
-	/* IRQ has not been requested but handling irq? */
-	WARN_ONCE(1, "Unexpected irq handling before port startup\n");
-	return 0;
-}
-
-static struct omap8250_dma_params am654_dma = {
-	.rx_size = SZ_2K,
-	.rx_trigger = 1,
-	.tx_trigger = TX_TRIGGER,
-};
-
-static struct omap8250_dma_params am33xx_dma = {
-	.rx_size = RX_TRIGGER,
-	.rx_trigger = RX_TRIGGER,
-	.tx_trigger = TX_TRIGGER,
-};
-
-static struct omap8250_platdata am654_platdata = {
-	.dma_params	= &am654_dma,
-	.habit		= UART_HAS_EFR2 | UART_HAS_RHR_IT_DIS |
-			  UART_RX_TIMEOUT_QUIRK | UART_HAS_NATIVE_RS485,
-};
-
-static struct omap8250_platdata am33xx_platdata = {
-	.dma_params	= &am33xx_dma,
-	.habit		= OMAP_DMA_TX_KICK | UART_ERRATA_CLOCK_DISABLE,
-};
-
-static struct omap8250_platdata omap4_platdata = {
-	.dma_params	= &am33xx_dma,
-	.habit		= UART_ERRATA_CLOCK_DISABLE,
-};
-
-static const struct of_device_id omap8250_dt_ids[] = {
-	{ .compatible = "ti,am654-uart", .data = &am654_platdata, },
-	{ .compatible = "ti,omap2-uart" },
-	{ .compatible = "ti,omap3-uart" },
-	{ .compatible = "ti,omap4-uart", .data = &omap4_platdata, },
-	{ .compatible = "ti,am3352-uart", .data = &am33xx_platdata, },
-	{ .compatible = "ti,am4372-uart", .data = &am33xx_platdata, },
-	{ .compatible = "ti,dra742-uart", .data = &omap4_platdata, },
-	{},
-};
-MODULE_DEVICE_TABLE(of, omap8250_dt_ids);
-
-static int omap8250_probe(struct platform_device *pdev)
-{
-	struct device_node *np = pdev->dev.of_node;
-	struct omap8250_priv *priv;
-	const struct omap8250_platdata *pdata;
-	struct uart_8250_port up;
-	struct resource *regs;
-	void __iomem *membase;
-	int irq, ret;
-
-	irq = platform_get_irq(pdev, 0);
-	if (irq < 0)
-		return irq;
-
-	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!regs) {
-		dev_err(&pdev->dev, "missing registers\n");
-		return -EINVAL;
-	}
-
-	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-
-	membase = devm_ioremap(&pdev->dev, regs->start,
-				       resource_size(regs));
-	if (!membase)
-		return -ENODEV;
-
-	memset(&up, 0, sizeof(up));
-	up.port.dev = &pdev->dev;
-	up.port.mapbase = regs->start;
-	up.port.membase = membase;
-	up.port.irq = irq;
-	/*
-	 * It claims to be 16C750 compatible however it is a little different.
-	 * It has EFR and has no FCR7_64byte bit. The AFE (which it claims to
-	 * have) is enabled via EFR instead of MCR. The type is set here 8250
-	 * just to get things going. UNKNOWN does not work for a few reasons and
-	 * we don't need our own type since we don't use 8250's set_termios()
-	 * or pm callback.
-	 */
-	up.port.type = PORT_8250;
-	up.port.iotype = UPIO_MEM;
-	up.port.flags = UPF_FIXED_PORT | UPF_FIXED_TYPE | UPF_SOFT_FLOW |
-		UPF_HARD_FLOW;
-	up.port.private_data = priv;
-
-	up.port.regshift = OMAP_UART_REGSHIFT;
-	up.port.fifosize = 64;
-	up.tx_loadsz = 64;
-	up.capabilities = UART_CAP_FIFO;
-#ifdef CONFIG_PM
-	/*
-	 * Runtime PM is mostly transparent. However to do it right we need to a
-	 * TX empty interrupt before we can put the device to auto idle. So if
-	 * PM is not enabled we don't add that flag and can spare that one extra
-	 * interrupt in the TX path.
-	 */
-	up.capabilities |= UART_CAP_RPM;
-#endif
-	up.port.set_termios = omap_8250_set_termios;
-	up.port.set_mctrl = omap8250_set_mctrl;
-	up.port.pm = omap_8250_pm;
-	up.port.startup = omap_8250_startup;
-	up.port.shutdown = omap_8250_shutdown;
-	up.port.throttle = omap_8250_throttle;
-	up.port.unthrottle = omap_8250_unthrottle;
-	up.port.rs485_config = omap8250_rs485_config;
-	/* same rs485_supported for software emulation and native RS485 */
-	up.port.rs485_supported = serial8250_em485_supported;
-	up.rs485_start_tx = serial8250_em485_start_tx;
-	up.rs485_stop_tx = serial8250_em485_stop_tx;
-	up.port.has_sysrq = IS_ENABLED(CONFIG_SERIAL_8250_CONSOLE);
-
-	ret = of_alias_get_id(np, "serial");
-	if (ret < 0) {
-		dev_err(&pdev->dev, "failed to get alias\n");
-		return ret;
-	}
-	up.port.line = ret;
-
-	if (of_property_read_u32(np, "clock-frequency", &up.port.uartclk)) {
-		struct clk *clk;
-
-		clk = devm_clk_get(&pdev->dev, NULL);
-		if (IS_ERR(clk)) {
-			if (PTR_ERR(clk) == -EPROBE_DEFER)
-				return -EPROBE_DEFER;
-		} else {
-			up.port.uartclk = clk_get_rate(clk);
-		}
-	}
-
-	if (of_property_read_u32(np, "overrun-throttle-ms",
-				 &up.overrun_backoff_time_ms) != 0)
-		up.overrun_backoff_time_ms = 0;
-
-	pdata = of_device_get_match_data(&pdev->dev);
-	if (pdata)
-		priv->habit |= pdata->habit;
-
-	if (!up.port.uartclk) {
-		up.port.uartclk = DEFAULT_CLK_SPEED;
-		dev_warn(&pdev->dev,
-			 "No clock speed specified: using default: %d\n",
-			 DEFAULT_CLK_SPEED);
-	}
-
-	priv->membase = membase;
-	priv->line = -ENODEV;
-	priv->latency = PM_QOS_CPU_LATENCY_DEFAULT_VALUE;
-	priv->calc_latency = PM_QOS_CPU_LATENCY_DEFAULT_VALUE;
-	cpu_latency_qos_add_request(&priv->pm_qos_request, priv->latency);
-	INIT_WORK(&priv->qos_work, omap8250_uart_qos_work);
-
-	spin_lock_init(&priv->rx_dma_lock);
-
-	platform_set_drvdata(pdev, priv);
-
-	device_init_wakeup(&pdev->dev, true);
-	pm_runtime_enable(&pdev->dev);
-	pm_runtime_use_autosuspend(&pdev->dev);
-
-	/*
-	 * Disable runtime PM until autosuspend delay unless specifically
-	 * enabled by the user via sysfs. This is the historic way to
-	 * prevent an unsafe default policy with lossy characters on wake-up.
-	 * For serdev devices this is not needed, the policy can be managed by
-	 * the serdev driver.
-	 */
-	if (!of_get_available_child_count(pdev->dev.of_node))
-		pm_runtime_set_autosuspend_delay(&pdev->dev, -1);
-
-	pm_runtime_irq_safe(&pdev->dev);
-
-	pm_runtime_get_sync(&pdev->dev);
-
-	omap_serial_fill_features_erratas(&up, priv);
-	up.port.handle_irq = omap8250_no_handle_irq;
-	priv->rx_trigger = RX_TRIGGER;
-	priv->tx_trigger = TX_TRIGGER;
-#ifdef CONFIG_SERIAL_8250_DMA
-	/*
-	 * Oh DMA support. If there are no DMA properties in the DT then
-	 * we will fall back to a generic DMA channel which does not
-	 * really work here. To ensure that we do not get a generic DMA
-	 * channel assigned, we have the the_no_dma_filter_fn() here.
-	 * To avoid "failed to request DMA" messages we check for DMA
-	 * properties in DT.
-	 */
-	ret = of_property_count_strings(np, "dma-names");
-	if (ret == 2) {
-		struct omap8250_dma_params *dma_params = NULL;
-		struct uart_8250_dma *dma = &priv->omap8250_dma;
-
-		dma->fn = the_no_dma_filter_fn;
-		dma->tx_dma = omap_8250_tx_dma;
-		dma->rx_dma = omap_8250_rx_dma;
-		if (pdata)
-			dma_params = pdata->dma_params;
-
-		if (dma_params) {
-			dma->rx_size = dma_params->rx_size;
-			dma->rxconf.src_maxburst = dma_params->rx_trigger;
-			dma->txconf.dst_maxburst = dma_params->tx_trigger;
-			priv->rx_trigger = dma_params->rx_trigger;
-			priv->tx_trigger = dma_params->tx_trigger;
-		} else {
-			dma->rx_size = RX_TRIGGER;
-			dma->rxconf.src_maxburst = RX_TRIGGER;
-			dma->txconf.dst_maxburst = TX_TRIGGER;
-		}
-	}
-#endif
-
-	irq_set_status_flags(irq, IRQ_NOAUTOEN);
-	ret = devm_request_irq(&pdev->dev, irq, omap8250_irq, 0,
-			       dev_name(&pdev->dev), priv);
-	if (ret < 0)
-		goto err;
-
-	priv->wakeirq = irq_of_parse_and_map(np, 1);
-
-	ret = serial8250_register_8250_port(&up);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "unable to register 8250 port\n");
-		goto err;
-	}
-	priv->line = ret;
-	pm_runtime_mark_last_busy(&pdev->dev);
-	pm_runtime_put_autosuspend(&pdev->dev);
-	return 0;
-err:
-	pm_runtime_dont_use_autosuspend(&pdev->dev);
-	pm_runtime_put_sync(&pdev->dev);
-	flush_work(&priv->qos_work);
-	pm_runtime_disable(&pdev->dev);
-	cpu_latency_qos_remove_request(&priv->pm_qos_request);
-	return ret;
-}
-
-static int omap8250_remove(struct platform_device *pdev)
-{
-	struct omap8250_priv *priv = platform_get_drvdata(pdev);
-	struct uart_8250_port *up;
-	int err;
-
-	err = pm_runtime_resume_and_get(&pdev->dev);
-	if (err)
-		dev_err(&pdev->dev, "Failed to resume hardware\n");
-
-	up = serial8250_get_port(priv->line);
-	omap_8250_shutdown(&up->port);
-	serial8250_unregister_port(priv->line);
-	priv->line = -ENODEV;
-	pm_runtime_dont_use_autosuspend(&pdev->dev);
-	pm_runtime_put_sync(&pdev->dev);
-	flush_work(&priv->qos_work);
-	pm_runtime_disable(&pdev->dev);
-	cpu_latency_qos_remove_request(&priv->pm_qos_request);
-	device_init_wakeup(&pdev->dev, false);
-	return 0;
-}
-
-static int omap8250_prepare(struct device *dev)
-{
-	struct omap8250_priv *priv = dev_get_drvdata(dev);
-
-	if (!priv)
-		return 0;
-	priv->is_suspending = true;
-	return 0;
-}
-
-static void omap8250_complete(struct device *dev)
-{
-	struct omap8250_priv *priv = dev_get_drvdata(dev);
-
-	if (!priv)
-		return;
-	priv->is_suspending = false;
-}
-
-static int omap8250_suspend(struct device *dev)
-{
-	struct omap8250_priv *priv = dev_get_drvdata(dev);
-	struct uart_8250_port *up = serial8250_get_port(priv->line);
-	int err = 0;
-
-	serial8250_suspend_port(priv->line);
-
-	err = pm_runtime_resume_and_get(dev);
-	if (err)
-		return err;
-	if (!device_may_wakeup(dev))
-		priv->wer = 0;
-	serial_out(up, UART_OMAP_WER, priv->wer);
-	if (uart_console(&up->port) && console_suspend_enabled)
-		err = pm_runtime_force_suspend(dev);
-	flush_work(&priv->qos_work);
-
-	return err;
-}
-
-static int omap8250_resume(struct device *dev)
-{
-	struct omap8250_priv *priv = dev_get_drvdata(dev);
-	struct uart_8250_port *up = serial8250_get_port(priv->line);
-	int err;
-
-	if (uart_console(&up->port) && console_suspend_enabled) {
-		err = pm_runtime_force_resume(dev);
-		if (err)
-			return err;
-	}
-
-	serial8250_resume_port(priv->line);
-	/* Paired with pm_runtime_resume_and_get() in omap8250_suspend() */
-	pm_runtime_mark_last_busy(dev);
-	pm_runtime_put_autosuspend(dev);
-
-	return 0;
-}
-
-static int omap8250_lost_context(struct uart_8250_port *up)
-{
-	u32 val;
-
-	val = serial_in(up, UART_OMAP_SCR);
-	/*
-	 * If we lose context, then SCR is set to its reset value of zero.
-	 * After set_termios() we set bit 3 of SCR (TX_EMPTY_CTL_IT) to 1,
-	 * among other bits, to never set the register back to zero again.
-	 */
-	if (!val)
-		return 1;
-	return 0;
-}
-
-static void uart_write(struct omap8250_priv *priv, u32 reg, u32 val)
-{
-	writel(val, priv->membase + (reg << OMAP_UART_REGSHIFT));
-}
-
-/* TODO: in future, this should happen via API in drivers/reset/ */
-static int omap8250_soft_reset(struct device *dev)
-{
-	struct omap8250_priv *priv = dev_get_drvdata(dev);
-	int timeout = 100;
-	int sysc;
-	int syss;
-
-	/*
-	 * At least on omap4, unused uarts may not idle after reset without
-	 * a basic scr dma configuration even with no dma in use. The
-	 * module clkctrl status bits will be 1 instead of 3 blocking idle
-	 * for the whole clockdomain. The softreset below will clear scr,
-	 * and we restore it on resume so this is safe to do on all SoCs
-	 * needing omap8250_soft_reset() quirk. Do it in two writes as
-	 * recommended in the comment for omap8250_update_scr().
-	 */
-	uart_write(priv, UART_OMAP_SCR, OMAP_UART_SCR_DMAMODE_1);
-	uart_write(priv, UART_OMAP_SCR,
-		   OMAP_UART_SCR_DMAMODE_1 | OMAP_UART_SCR_DMAMODE_CTL);
-
-	sysc = uart_read(priv, UART_OMAP_SYSC);
-
-	/* softreset the UART */
-	sysc |= OMAP_UART_SYSC_SOFTRESET;
-	uart_write(priv, UART_OMAP_SYSC, sysc);
-
-	/* By experiments, 1us enough for reset complete on AM335x */
-	do {
-		udelay(1);
-		syss = uart_read(priv, UART_OMAP_SYSS);
-	} while (--timeout && !(syss & OMAP_UART_SYSS_RESETDONE));
-
-	if (!timeout) {
-		dev_err(dev, "timed out waiting for reset done\n");
-		return -ETIMEDOUT;
-	}
-
-	return 0;
-}
-
-static int omap8250_runtime_suspend(struct device *dev)
-{
-	struct omap8250_priv *priv = dev_get_drvdata(dev);
-	struct uart_8250_port *up = NULL;
-
-	if (priv->line >= 0)
-		up = serial8250_get_port(priv->line);
-
-	if (priv->habit & UART_ERRATA_CLOCK_DISABLE) {
-		int ret;
-
-		ret = omap8250_soft_reset(dev);
-		if (ret)
-			return ret;
-
-		if (up) {
-			/* Restore to UART mode after reset (for wakeup) */
-			omap8250_update_mdr1(up, priv);
-			/* Restore wakeup enable register */
-			serial_out(up, UART_OMAP_WER, priv->wer);
-		}
-	}
-
-	if (up && up->dma && up->dma->rxchan)
-		omap_8250_rx_dma_flush(up);
-
-	priv->latency = PM_QOS_CPU_LATENCY_DEFAULT_VALUE;
-	schedule_work(&priv->qos_work);
-
-	return 0;
-}
-
-static int omap8250_runtime_resume(struct device *dev)
-{
-	struct omap8250_priv *priv = dev_get_drvdata(dev);
-	struct uart_8250_port *up = NULL;
-
-	if (priv->line >= 0)
-		up = serial8250_get_port(priv->line);
-
-	if (up && omap8250_lost_context(up)) {
-		spin_lock_irq(&up->port.lock);
-		omap8250_restore_regs(up);
-		spin_unlock_irq(&up->port.lock);
-	}
-
-	if (up && up->dma && up->dma->rxchan && !(priv->habit & UART_HAS_EFR2)) {
-		spin_lock_irq(&up->port.lock);
-		omap_8250_rx_dma(up);
-		spin_unlock_irq(&up->port.lock);
-	}
-
-	priv->latency = priv->calc_latency;
-	schedule_work(&priv->qos_work);
-	return 0;
-}
-
-#ifdef CONFIG_SERIAL_8250_OMAP_TTYO_FIXUP
-static int __init omap8250_console_fixup(void)
-{
-	char *omap_str;
-	char *options;
-	u8 idx;
-
-	if (strstr(boot_command_line, "console=ttyS"))
-		/* user set a ttyS based name for the console */
-		return 0;
-
-	omap_str = strstr(boot_command_line, "console=ttyO");
-	if (!omap_str)
-		/* user did not set ttyO based console, so we don't care */
-		return 0;
-
-	omap_str += 12;
-	if ('0' <= *omap_str && *omap_str <= '9')
-		idx = *omap_str - '0';
-	else
-		return 0;
-
-	omap_str++;
-	if (omap_str[0] == ',') {
-		omap_str++;
-		options = omap_str;
-	} else {
-		options = NULL;
-	}
-
-	add_preferred_console("ttyS", idx, options);
-	pr_err("WARNING: Your 'console=ttyO%d' has been replaced by 'ttyS%d'\n",
-	       idx, idx);
-	pr_err("This ensures that you still see kernel messages. Please\n");
-	pr_err("update your kernel commandline.\n");
-	return 0;
-}
-console_initcall(omap8250_console_fixup);
-#endif
-
-static const struct dev_pm_ops omap8250_dev_pm_ops = {
-	SYSTEM_SLEEP_PM_OPS(omap8250_suspend, omap8250_resume)
-	RUNTIME_PM_OPS(omap8250_runtime_suspend,
-			   omap8250_runtime_resume, NULL)
-	.prepare        = pm_sleep_ptr(omap8250_prepare),
-	.complete       = pm_sleep_ptr(omap8250_complete),
-};
-
-static struct platform_driver omap8250_platform_driver = {
-	.driver = {
-		.name		= "omap8250",
-		.pm		= pm_ptr(&omap8250_dev_pm_ops),
-		.of_match_table = omap8250_dt_ids,
-	},
-	.probe			= omap8250_probe,
-	.remove			= omap8250_remove,
-};
-module_platform_driver(omap8250_platform_driver);
-
-MODULE_AUTHOR("Sebastian Andrzej Siewior");
-MODULE_DESCRIPTION("OMAP 8250 Driver");
-MODULE_LICENSE("GPL v2");
diff --git a/net/mac80211/mlme.c.orig b/net/mac80211/mlme.c.orig
deleted file mode 100644
index 42e2c84ed248..000000000000
--- a/net/mac80211/mlme.c.orig
+++ /dev/null
@@ -1,7961 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * BSS client mode implementation
- * Copyright 2003-2008, Jouni Malinen <j@w1.fi>
- * Copyright 2004, Instant802 Networks, Inc.
- * Copyright 2005, Devicescape Software, Inc.
- * Copyright 2006-2007	Jiri Benc <jbenc@suse.cz>
- * Copyright 2007, Michael Wu <flamingice@sourmilk.net>
- * Copyright 2013-2014  Intel Mobile Communications GmbH
- * Copyright (C) 2015 - 2017 Intel Deutschland GmbH
- * Copyright (C) 2018 - 2023 Intel Corporation
- */
-
-#include <linux/delay.h>
-#include <linux/fips.h>
-#include <linux/if_ether.h>
-#include <linux/skbuff.h>
-#include <linux/if_arp.h>
-#include <linux/etherdevice.h>
-#include <linux/moduleparam.h>
-#include <linux/rtnetlink.h>
-#include <linux/crc32.h>
-#include <linux/slab.h>
-#include <linux/export.h>
-#include <net/mac80211.h>
-#include <asm/unaligned.h>
-
-#include "ieee80211_i.h"
-#include "driver-ops.h"
-#include "rate.h"
-#include "led.h"
-#include "fils_aead.h"
-
-#define IEEE80211_AUTH_TIMEOUT		(HZ / 5)
-#define IEEE80211_AUTH_TIMEOUT_LONG	(HZ / 2)
-#define IEEE80211_AUTH_TIMEOUT_SHORT	(HZ / 10)
-#define IEEE80211_AUTH_TIMEOUT_SAE	(HZ * 2)
-#define IEEE80211_AUTH_MAX_TRIES	3
-#define IEEE80211_AUTH_WAIT_ASSOC	(HZ * 5)
-#define IEEE80211_AUTH_WAIT_SAE_RETRY	(HZ * 2)
-#define IEEE80211_ASSOC_TIMEOUT		(HZ / 5)
-#define IEEE80211_ASSOC_TIMEOUT_LONG	(HZ / 2)
-#define IEEE80211_ASSOC_TIMEOUT_SHORT	(HZ / 10)
-#define IEEE80211_ASSOC_MAX_TRIES	3
-
-static int max_nullfunc_tries = 2;
-module_param(max_nullfunc_tries, int, 0644);
-MODULE_PARM_DESC(max_nullfunc_tries,
-		 "Maximum nullfunc tx tries before disconnecting (reason 4).");
-
-static int max_probe_tries = 5;
-module_param(max_probe_tries, int, 0644);
-MODULE_PARM_DESC(max_probe_tries,
-		 "Maximum probe tries before disconnecting (reason 4).");
-
-/*
- * Beacon loss timeout is calculated as N frames times the
- * advertised beacon interval.  This may need to be somewhat
- * higher than what hardware might detect to account for
- * delays in the host processing frames. But since we also
- * probe on beacon miss before declaring the connection lost
- * default to what we want.
- */
-static int beacon_loss_count = 7;
-module_param(beacon_loss_count, int, 0644);
-MODULE_PARM_DESC(beacon_loss_count,
-		 "Number of beacon intervals before we decide beacon was lost.");
-
-/*
- * Time the connection can be idle before we probe
- * it to see if we can still talk to the AP.
- */
-#define IEEE80211_CONNECTION_IDLE_TIME	(30 * HZ)
-/*
- * Time we wait for a probe response after sending
- * a probe request because of beacon loss or for
- * checking the connection still works.
- */
-static int probe_wait_ms = 500;
-module_param(probe_wait_ms, int, 0644);
-MODULE_PARM_DESC(probe_wait_ms,
-		 "Maximum time(ms) to wait for probe response"
-		 " before disconnecting (reason 4).");
-
-/*
- * How many Beacon frames need to have been used in average signal strength
- * before starting to indicate signal change events.
- */
-#define IEEE80211_SIGNAL_AVE_MIN_COUNT	4
-
-/*
- * Extract from the given disabled subchannel bitmap (raw format
- * from the EHT Operation Element) the bits for the subchannel
- * we're using right now.
- */
-static u16
-ieee80211_extract_dis_subch_bmap(const struct ieee80211_eht_operation *eht_oper,
-				 struct cfg80211_chan_def *chandef, u16 bitmap)
-{
-	struct ieee80211_eht_operation_info *info = (void *)eht_oper->optional;
-	struct cfg80211_chan_def ap_chandef = *chandef;
-	u32 ap_center_freq, local_center_freq;
-	u32 ap_bw, local_bw;
-	int ap_start_freq, local_start_freq;
-	u16 shift, mask;
-
-	if (!(eht_oper->params & IEEE80211_EHT_OPER_INFO_PRESENT) ||
-	    !(eht_oper->params &
-	      IEEE80211_EHT_OPER_DISABLED_SUBCHANNEL_BITMAP_PRESENT))
-		return 0;
-
-	/* set 160/320 supported to get the full AP definition */
-	ieee80211_chandef_eht_oper(eht_oper, true, true, &ap_chandef);
-	ap_center_freq = ap_chandef.center_freq1;
-	ap_bw = 20 * BIT(u8_get_bits(info->control,
-				     IEEE80211_EHT_OPER_CHAN_WIDTH));
-	ap_start_freq = ap_center_freq - ap_bw / 2;
-	local_center_freq = chandef->center_freq1;
-	local_bw = 20 * BIT(ieee80211_chan_width_to_rx_bw(chandef->width));
-	local_start_freq = local_center_freq - local_bw / 2;
-	shift = (local_start_freq - ap_start_freq) / 20;
-	mask = BIT(local_bw / 20) - 1;
-
-	return (bitmap >> shift) & mask;
-}
-
-/*
- * Handle the puncturing bitmap, possibly downgrading bandwidth to get a
- * valid bitmap.
- */
-static void
-ieee80211_handle_puncturing_bitmap(struct ieee80211_link_data *link,
-				   const struct ieee80211_eht_operation *eht_oper,
-				   u16 bitmap, u64 *changed)
-{
-	struct cfg80211_chan_def *chandef = &link->conf->chandef;
-	u16 extracted;
-	u64 _changed = 0;
-
-	if (!changed)
-		changed = &_changed;
-
-	while (chandef->width > NL80211_CHAN_WIDTH_40) {
-		extracted =
-			ieee80211_extract_dis_subch_bmap(eht_oper, chandef,
-							 bitmap);
-
-		if (cfg80211_valid_disable_subchannel_bitmap(&bitmap,
-							     chandef))
-			break;
-		link->u.mgd.conn_flags |=
-			ieee80211_chandef_downgrade(chandef);
-		*changed |= BSS_CHANGED_BANDWIDTH;
-	}
-
-	if (chandef->width <= NL80211_CHAN_WIDTH_40)
-		extracted = 0;
-
-	if (link->conf->eht_puncturing != extracted) {
-		link->conf->eht_puncturing = extracted;
-		*changed |= BSS_CHANGED_EHT_PUNCTURING;
-	}
-}
-
-/*
- * We can have multiple work items (and connection probing)
- * scheduling this timer, but we need to take care to only
- * reschedule it when it should fire _earlier_ than it was
- * asked for before, or if it's not pending right now. This
- * function ensures that. Note that it then is required to
- * run this function for all timeouts after the first one
- * has happened -- the work that runs from this timer will
- * do that.
- */
-static void run_again(struct ieee80211_sub_if_data *sdata,
-		      unsigned long timeout)
-{
-	sdata_assert_lock(sdata);
-
-	if (!timer_pending(&sdata->u.mgd.timer) ||
-	    time_before(timeout, sdata->u.mgd.timer.expires))
-		mod_timer(&sdata->u.mgd.timer, timeout);
-}
-
-void ieee80211_sta_reset_beacon_monitor(struct ieee80211_sub_if_data *sdata)
-{
-	if (sdata->vif.driver_flags & IEEE80211_VIF_BEACON_FILTER)
-		return;
-
-	if (ieee80211_hw_check(&sdata->local->hw, CONNECTION_MONITOR))
-		return;
-
-	mod_timer(&sdata->u.mgd.bcn_mon_timer,
-		  round_jiffies_up(jiffies + sdata->u.mgd.beacon_timeout));
-}
-
-void ieee80211_sta_reset_conn_monitor(struct ieee80211_sub_if_data *sdata)
-{
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-
-	if (unlikely(!ifmgd->associated))
-		return;
-
-	if (ifmgd->probe_send_count)
-		ifmgd->probe_send_count = 0;
-
-	if (ieee80211_hw_check(&sdata->local->hw, CONNECTION_MONITOR))
-		return;
-
-	mod_timer(&ifmgd->conn_mon_timer,
-		  round_jiffies_up(jiffies + IEEE80211_CONNECTION_IDLE_TIME));
-}
-
-static int ecw2cw(int ecw)
-{
-	return (1 << ecw) - 1;
-}
-
-static ieee80211_conn_flags_t
-ieee80211_determine_chantype(struct ieee80211_sub_if_data *sdata,
-			     struct ieee80211_link_data *link,
-			     ieee80211_conn_flags_t conn_flags,
-			     struct ieee80211_supported_band *sband,
-			     struct ieee80211_channel *channel,
-			     u32 vht_cap_info,
-			     const struct ieee80211_ht_operation *ht_oper,
-			     const struct ieee80211_vht_operation *vht_oper,
-			     const struct ieee80211_he_operation *he_oper,
-			     const struct ieee80211_eht_operation *eht_oper,
-			     const struct ieee80211_s1g_oper_ie *s1g_oper,
-			     struct cfg80211_chan_def *chandef, bool tracking)
-{
-	struct cfg80211_chan_def vht_chandef;
-	struct ieee80211_sta_ht_cap sta_ht_cap;
-	ieee80211_conn_flags_t ret;
-	u32 ht_cfreq;
-
-	memset(chandef, 0, sizeof(struct cfg80211_chan_def));
-	chandef->chan = channel;
-	chandef->width = NL80211_CHAN_WIDTH_20_NOHT;
-	chandef->center_freq1 = channel->center_freq;
-	chandef->freq1_offset = channel->freq_offset;
-
-	if (channel->band == NL80211_BAND_6GHZ) {
-		if (!ieee80211_chandef_he_6ghz_oper(sdata, he_oper, eht_oper,
-						    chandef)) {
-			mlme_dbg(sdata,
-				 "bad 6 GHz operation, disabling HT/VHT/HE/EHT\n");
-			ret = IEEE80211_CONN_DISABLE_HT |
-			      IEEE80211_CONN_DISABLE_VHT |
-			      IEEE80211_CONN_DISABLE_HE |
-			      IEEE80211_CONN_DISABLE_EHT;
-		} else {
-			ret = 0;
-		}
-		vht_chandef = *chandef;
-		goto out;
-	} else if (sband->band == NL80211_BAND_S1GHZ) {
-		if (!ieee80211_chandef_s1g_oper(s1g_oper, chandef)) {
-			sdata_info(sdata,
-				   "Missing S1G Operation Element? Trying operating == primary\n");
-			chandef->width = ieee80211_s1g_channel_width(channel);
-		}
-
-		ret = IEEE80211_CONN_DISABLE_HT | IEEE80211_CONN_DISABLE_40MHZ |
-		      IEEE80211_CONN_DISABLE_VHT |
-		      IEEE80211_CONN_DISABLE_80P80MHZ |
-		      IEEE80211_CONN_DISABLE_160MHZ;
-		goto out;
-	}
-
-	memcpy(&sta_ht_cap, &sband->ht_cap, sizeof(sta_ht_cap));
-	ieee80211_apply_htcap_overrides(sdata, &sta_ht_cap);
-
-	if (!ht_oper || !sta_ht_cap.ht_supported) {
-		mlme_dbg(sdata, "HT operation missing / HT not supported\n");
-		ret = IEEE80211_CONN_DISABLE_HT |
-		      IEEE80211_CONN_DISABLE_VHT |
-		      IEEE80211_CONN_DISABLE_HE |
-		      IEEE80211_CONN_DISABLE_EHT;
-		goto out;
-	}
-
-	chandef->width = NL80211_CHAN_WIDTH_20;
-
-	ht_cfreq = ieee80211_channel_to_frequency(ht_oper->primary_chan,
-						  channel->band);
-	/* check that channel matches the right operating channel */
-	if (!tracking && channel->center_freq != ht_cfreq) {
-		/*
-		 * It's possible that some APs are confused here;
-		 * Netgear WNDR3700 sometimes reports 4 higher than
-		 * the actual channel in association responses, but
-		 * since we look at probe response/beacon data here
-		 * it should be OK.
-		 */
-		sdata_info(sdata,
-			   "Wrong control channel: center-freq: %d ht-cfreq: %d ht->primary_chan: %d band: %d - Disabling HT\n",
-			   channel->center_freq, ht_cfreq,
-			   ht_oper->primary_chan, channel->band);
-		ret = IEEE80211_CONN_DISABLE_HT |
-		      IEEE80211_CONN_DISABLE_VHT |
-		      IEEE80211_CONN_DISABLE_HE |
-		      IEEE80211_CONN_DISABLE_EHT;
-		goto out;
-	}
-
-	/* check 40 MHz support, if we have it */
-	if (sta_ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40) {
-		ieee80211_chandef_ht_oper(ht_oper, chandef);
-	} else {
-		mlme_dbg(sdata, "40 MHz not supported\n");
-		/* 40 MHz (and 80 MHz) must be supported for VHT */
-		ret = IEEE80211_CONN_DISABLE_VHT;
-		/* also mark 40 MHz disabled */
-		ret |= IEEE80211_CONN_DISABLE_40MHZ;
-		goto out;
-	}
-
-	if (!vht_oper || !sband->vht_cap.vht_supported) {
-		mlme_dbg(sdata, "VHT operation missing / VHT not supported\n");
-		ret = IEEE80211_CONN_DISABLE_VHT;
-		goto out;
-	}
-
-	vht_chandef = *chandef;
-	if (!(conn_flags & IEEE80211_CONN_DISABLE_HE) &&
-	    he_oper &&
-	    (le32_to_cpu(he_oper->he_oper_params) &
-	     IEEE80211_HE_OPERATION_VHT_OPER_INFO)) {
-		struct ieee80211_vht_operation he_oper_vht_cap;
-
-		/*
-		 * Set only first 3 bytes (other 2 aren't used in
-		 * ieee80211_chandef_vht_oper() anyway)
-		 */
-		memcpy(&he_oper_vht_cap, he_oper->optional, 3);
-		he_oper_vht_cap.basic_mcs_set = cpu_to_le16(0);
-
-		if (!ieee80211_chandef_vht_oper(&sdata->local->hw, vht_cap_info,
-						&he_oper_vht_cap, ht_oper,
-						&vht_chandef)) {
-			if (!(conn_flags & IEEE80211_CONN_DISABLE_HE))
-				sdata_info(sdata,
-					   "HE AP VHT information is invalid, disabling HE\n");
-			ret = IEEE80211_CONN_DISABLE_HE | IEEE80211_CONN_DISABLE_EHT;
-			goto out;
-		}
-	} else if (!ieee80211_chandef_vht_oper(&sdata->local->hw,
-					       vht_cap_info,
-					       vht_oper, ht_oper,
-					       &vht_chandef)) {
-		if (!(conn_flags & IEEE80211_CONN_DISABLE_VHT))
-			sdata_info(sdata,
-				   "AP VHT information is invalid, disabling VHT\n");
-		ret = IEEE80211_CONN_DISABLE_VHT;
-		goto out;
-	}
-
-	if (!cfg80211_chandef_valid(&vht_chandef)) {
-		if (!(conn_flags & IEEE80211_CONN_DISABLE_VHT))
-			sdata_info(sdata,
-				   "AP VHT information is invalid, disabling VHT\n");
-		ret = IEEE80211_CONN_DISABLE_VHT;
-		goto out;
-	}
-
-	if (cfg80211_chandef_identical(chandef, &vht_chandef)) {
-		ret = 0;
-		goto out;
-	}
-
-	if (!cfg80211_chandef_compatible(chandef, &vht_chandef)) {
-		if (!(conn_flags & IEEE80211_CONN_DISABLE_VHT))
-			sdata_info(sdata,
-				   "AP VHT information doesn't match HT, disabling VHT\n");
-		ret = IEEE80211_CONN_DISABLE_VHT;
-		goto out;
-	}
-
-	*chandef = vht_chandef;
-
-	/*
-	 * handle the case that the EHT operation indicates that it holds EHT
-	 * operation information (in case that the channel width differs from
-	 * the channel width reported in HT/VHT/HE).
-	 */
-	if (eht_oper && (eht_oper->params & IEEE80211_EHT_OPER_INFO_PRESENT)) {
-		struct cfg80211_chan_def eht_chandef = *chandef;
-
-		ieee80211_chandef_eht_oper(eht_oper,
-					   eht_chandef.width ==
-					   NL80211_CHAN_WIDTH_160,
-					   false, &eht_chandef);
-
-		if (!cfg80211_chandef_valid(&eht_chandef)) {
-			if (!(conn_flags & IEEE80211_CONN_DISABLE_EHT))
-				sdata_info(sdata,
-					   "AP EHT information is invalid, disabling EHT\n");
-			ret = IEEE80211_CONN_DISABLE_EHT;
-			goto out;
-		}
-
-		if (!cfg80211_chandef_compatible(chandef, &eht_chandef)) {
-			if (!(conn_flags & IEEE80211_CONN_DISABLE_EHT))
-				sdata_info(sdata,
-					   "AP EHT information is incompatible, disabling EHT\n");
-			ret = IEEE80211_CONN_DISABLE_EHT;
-			goto out;
-		}
-
-		*chandef = eht_chandef;
-	}
-
-	ret = 0;
-
-out:
-	/*
-	 * When tracking the current AP, don't do any further checks if the
-	 * new chandef is identical to the one we're currently using for the
-	 * connection. This keeps us from playing ping-pong with regulatory,
-	 * without it the following can happen (for example):
-	 *  - connect to an AP with 80 MHz, world regdom allows 80 MHz
-	 *  - AP advertises regdom US
-	 *  - CRDA loads regdom US with 80 MHz prohibited (old database)
-	 *  - the code below detects an unsupported channel, downgrades, and
-	 *    we disconnect from the AP in the caller
-	 *  - disconnect causes CRDA to reload world regdomain and the game
-	 *    starts anew.
-	 * (see https://bugzilla.kernel.org/show_bug.cgi?id=70881)
-	 *
-	 * It seems possible that there are still scenarios with CSA or real
-	 * bandwidth changes where a this could happen, but those cases are
-	 * less common and wouldn't completely prevent using the AP.
-	 */
-	if (tracking &&
-	    cfg80211_chandef_identical(chandef, &link->conf->chandef))
-		return ret;
-
-	/* don't print the message below for VHT mismatch if VHT is disabled */
-	if (ret & IEEE80211_CONN_DISABLE_VHT)
-		vht_chandef = *chandef;
-
-	/*
-	 * Ignore the DISABLED flag when we're already connected and only
-	 * tracking the APs beacon for bandwidth changes - otherwise we
-	 * might get disconnected here if we connect to an AP, update our
-	 * regulatory information based on the AP's country IE and the
-	 * information we have is wrong/outdated and disables the channel
-	 * that we're actually using for the connection to the AP.
-	 */
-	while (!cfg80211_chandef_usable(sdata->local->hw.wiphy, chandef,
-					tracking ? 0 :
-						   IEEE80211_CHAN_DISABLED)) {
-		if (WARN_ON(chandef->width == NL80211_CHAN_WIDTH_20_NOHT)) {
-			ret = IEEE80211_CONN_DISABLE_HT |
-			      IEEE80211_CONN_DISABLE_VHT |
-			      IEEE80211_CONN_DISABLE_HE |
-			      IEEE80211_CONN_DISABLE_EHT;
-			break;
-		}
-
-		ret |= ieee80211_chandef_downgrade(chandef);
-	}
-
-	if (!he_oper || !cfg80211_chandef_usable(sdata->wdev.wiphy, chandef,
-						 IEEE80211_CHAN_NO_HE))
-		ret |= IEEE80211_CONN_DISABLE_HE | IEEE80211_CONN_DISABLE_EHT;
-
-	if (!eht_oper || !cfg80211_chandef_usable(sdata->wdev.wiphy, chandef,
-						  IEEE80211_CHAN_NO_EHT))
-		ret |= IEEE80211_CONN_DISABLE_EHT;
-
-	if (chandef->width != vht_chandef.width && !tracking)
-		sdata_info(sdata,
-			   "capabilities/regulatory prevented using AP HT/VHT configuration, downgraded\n");
-
-	WARN_ON_ONCE(!cfg80211_chandef_valid(chandef));
-	return ret;
-}
-
-static int ieee80211_config_bw(struct ieee80211_link_data *link,
-			       const struct ieee80211_ht_cap *ht_cap,
-			       const struct ieee80211_vht_cap *vht_cap,
-			       const struct ieee80211_ht_operation *ht_oper,
-			       const struct ieee80211_vht_operation *vht_oper,
-			       const struct ieee80211_he_operation *he_oper,
-			       const struct ieee80211_eht_operation *eht_oper,
-			       const struct ieee80211_s1g_oper_ie *s1g_oper,
-			       const u8 *bssid, u64 *changed)
-{
-	struct ieee80211_sub_if_data *sdata = link->sdata;
-	struct ieee80211_local *local = sdata->local;
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-	struct ieee80211_channel *chan = link->conf->chandef.chan;
-	struct ieee80211_supported_band *sband =
-		local->hw.wiphy->bands[chan->band];
-	struct cfg80211_chan_def chandef;
-	u16 ht_opmode;
-	ieee80211_conn_flags_t flags;
-	u32 vht_cap_info = 0;
-	int ret;
-
-	/* if HT was/is disabled, don't track any bandwidth changes */
-	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT || !ht_oper)
-		return 0;
-
-	/* don't check VHT if we associated as non-VHT station */
-	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT)
-		vht_oper = NULL;
-
-	/* don't check HE if we associated as non-HE station */
-	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HE ||
-	    !ieee80211_get_he_iftype_cap_vif(sband, &sdata->vif)) {
-		he_oper = NULL;
-		eht_oper = NULL;
-	}
-
-	/* don't check EHT if we associated as non-EHT station */
-	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_EHT ||
-	    !ieee80211_get_eht_iftype_cap_vif(sband, &sdata->vif))
-		eht_oper = NULL;
-
-	/*
-	 * if bss configuration changed store the new one -
-	 * this may be applicable even if channel is identical
-	 */
-	ht_opmode = le16_to_cpu(ht_oper->operation_mode);
-	if (link->conf->ht_operation_mode != ht_opmode) {
-		*changed |= BSS_CHANGED_HT;
-		link->conf->ht_operation_mode = ht_opmode;
-	}
-
-	if (vht_cap)
-		vht_cap_info = le32_to_cpu(vht_cap->vht_cap_info);
-
-	/* calculate new channel (type) based on HT/VHT/HE operation IEs */
-	flags = ieee80211_determine_chantype(sdata, link,
-					     link->u.mgd.conn_flags,
-					     sband, chan, vht_cap_info,
-					     ht_oper, vht_oper,
-					     he_oper, eht_oper,
-					     s1g_oper, &chandef, true);
-
-	/*
-	 * Downgrade the new channel if we associated with restricted
-	 * capabilities. For example, if we associated as a 20 MHz STA
-	 * to a 40 MHz AP (due to regulatory, capabilities or config
-	 * reasons) then switching to a 40 MHz channel now won't do us
-	 * any good -- we couldn't use it with the AP.
-	 */
-	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_80P80MHZ &&
-	    chandef.width == NL80211_CHAN_WIDTH_80P80)
-		flags |= ieee80211_chandef_downgrade(&chandef);
-	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_160MHZ &&
-	    chandef.width == NL80211_CHAN_WIDTH_160)
-		flags |= ieee80211_chandef_downgrade(&chandef);
-	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_40MHZ &&
-	    chandef.width > NL80211_CHAN_WIDTH_20)
-		flags |= ieee80211_chandef_downgrade(&chandef);
-
-	if (cfg80211_chandef_identical(&chandef, &link->conf->chandef))
-		return 0;
-
-	link_info(link,
-		  "AP %pM changed bandwidth, new config is %d.%03d MHz, width %d (%d.%03d/%d MHz)\n",
-		  link->u.mgd.bssid, chandef.chan->center_freq,
-		  chandef.chan->freq_offset, chandef.width,
-		  chandef.center_freq1, chandef.freq1_offset,
-		  chandef.center_freq2);
-
-	if (flags != (link->u.mgd.conn_flags &
-				(IEEE80211_CONN_DISABLE_HT |
-				 IEEE80211_CONN_DISABLE_VHT |
-				 IEEE80211_CONN_DISABLE_HE |
-				 IEEE80211_CONN_DISABLE_EHT |
-				 IEEE80211_CONN_DISABLE_40MHZ |
-				 IEEE80211_CONN_DISABLE_80P80MHZ |
-				 IEEE80211_CONN_DISABLE_160MHZ |
-				 IEEE80211_CONN_DISABLE_320MHZ)) ||
-	    !cfg80211_chandef_valid(&chandef)) {
-		sdata_info(sdata,
-			   "AP %pM changed caps/bw in a way we can't support (0x%x/0x%x) - disconnect\n",
-			   link->u.mgd.bssid, flags, ifmgd->flags);
-		return -EINVAL;
-	}
-
-	ret = ieee80211_link_change_bandwidth(link, &chandef, changed);
-
-	if (ret) {
-		sdata_info(sdata,
-			   "AP %pM changed bandwidth to incompatible one - disconnect\n",
-			   link->u.mgd.bssid);
-		return ret;
-	}
-
-	return 0;
-}
-
-/* frame sending functions */
-
-static void ieee80211_add_ht_ie(struct ieee80211_sub_if_data *sdata,
-				struct sk_buff *skb, u8 ap_ht_param,
-				struct ieee80211_supported_band *sband,
-				struct ieee80211_channel *channel,
-				enum ieee80211_smps_mode smps,
-				ieee80211_conn_flags_t conn_flags)
-{
-	u8 *pos;
-	u32 flags = channel->flags;
-	u16 cap;
-	struct ieee80211_sta_ht_cap ht_cap;
-
-	BUILD_BUG_ON(sizeof(ht_cap) != sizeof(sband->ht_cap));
-
-	memcpy(&ht_cap, &sband->ht_cap, sizeof(ht_cap));
-	ieee80211_apply_htcap_overrides(sdata, &ht_cap);
-
-	/* determine capability flags */
-	cap = ht_cap.cap;
-
-	switch (ap_ht_param & IEEE80211_HT_PARAM_CHA_SEC_OFFSET) {
-	case IEEE80211_HT_PARAM_CHA_SEC_ABOVE:
-		if (flags & IEEE80211_CHAN_NO_HT40PLUS) {
-			cap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;
-			cap &= ~IEEE80211_HT_CAP_SGI_40;
-		}
-		break;
-	case IEEE80211_HT_PARAM_CHA_SEC_BELOW:
-		if (flags & IEEE80211_CHAN_NO_HT40MINUS) {
-			cap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;
-			cap &= ~IEEE80211_HT_CAP_SGI_40;
-		}
-		break;
-	}
-
-	/*
-	 * If 40 MHz was disabled associate as though we weren't
-	 * capable of 40 MHz -- some broken APs will never fall
-	 * back to trying to transmit in 20 MHz.
-	 */
-	if (conn_flags & IEEE80211_CONN_DISABLE_40MHZ) {
-		cap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;
-		cap &= ~IEEE80211_HT_CAP_SGI_40;
-	}
-
-	/* set SM PS mode properly */
-	cap &= ~IEEE80211_HT_CAP_SM_PS;
-	switch (smps) {
-	case IEEE80211_SMPS_AUTOMATIC:
-	case IEEE80211_SMPS_NUM_MODES:
-		WARN_ON(1);
-		fallthrough;
-	case IEEE80211_SMPS_OFF:
-		cap |= WLAN_HT_CAP_SM_PS_DISABLED <<
-			IEEE80211_HT_CAP_SM_PS_SHIFT;
-		break;
-	case IEEE80211_SMPS_STATIC:
-		cap |= WLAN_HT_CAP_SM_PS_STATIC <<
-			IEEE80211_HT_CAP_SM_PS_SHIFT;
-		break;
-	case IEEE80211_SMPS_DYNAMIC:
-		cap |= WLAN_HT_CAP_SM_PS_DYNAMIC <<
-			IEEE80211_HT_CAP_SM_PS_SHIFT;
-		break;
-	}
-
-	/* reserve and fill IE */
-	pos = skb_put(skb, sizeof(struct ieee80211_ht_cap) + 2);
-	ieee80211_ie_build_ht_cap(pos, &ht_cap, cap);
-}
-
-/* This function determines vht capability flags for the association
- * and builds the IE.
- * Note - the function returns true to own the MU-MIMO capability
- */
-static bool ieee80211_add_vht_ie(struct ieee80211_sub_if_data *sdata,
-				 struct sk_buff *skb,
-				 struct ieee80211_supported_band *sband,
-				 struct ieee80211_vht_cap *ap_vht_cap,
-				 ieee80211_conn_flags_t conn_flags)
-{
-	struct ieee80211_local *local = sdata->local;
-	u8 *pos;
-	u32 cap;
-	struct ieee80211_sta_vht_cap vht_cap;
-	u32 mask, ap_bf_sts, our_bf_sts;
-	bool mu_mimo_owner = false;
-
-	BUILD_BUG_ON(sizeof(vht_cap) != sizeof(sband->vht_cap));
-
-	memcpy(&vht_cap, &sband->vht_cap, sizeof(vht_cap));
-	ieee80211_apply_vhtcap_overrides(sdata, &vht_cap);
-
-	/* determine capability flags */
-	cap = vht_cap.cap;
-
-	if (conn_flags & IEEE80211_CONN_DISABLE_80P80MHZ) {
-		u32 bw = cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK;
-
-		cap &= ~IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK;
-		if (bw == IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ ||
-		    bw == IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ)
-			cap |= IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ;
-	}
-
-	if (conn_flags & IEEE80211_CONN_DISABLE_160MHZ) {
-		cap &= ~IEEE80211_VHT_CAP_SHORT_GI_160;
-		cap &= ~IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK;
-	}
-
-	/*
-	 * Some APs apparently get confused if our capabilities are better
-	 * than theirs, so restrict what we advertise in the assoc request.
-	 */
-	if (!(ap_vht_cap->vht_cap_info &
-			cpu_to_le32(IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE)))
-		cap &= ~(IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE |
-			 IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE);
-	else if (!(ap_vht_cap->vht_cap_info &
-			cpu_to_le32(IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE)))
-		cap &= ~IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE;
-
-	/*
-	 * If some other vif is using the MU-MIMO capability we cannot associate
-	 * using MU-MIMO - this will lead to contradictions in the group-id
-	 * mechanism.
-	 * Ownership is defined since association request, in order to avoid
-	 * simultaneous associations with MU-MIMO.
-	 */
-	if (cap & IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE) {
-		bool disable_mu_mimo = false;
-		struct ieee80211_sub_if_data *other;
-
-		list_for_each_entry_rcu(other, &local->interfaces, list) {
-			if (other->vif.bss_conf.mu_mimo_owner) {
-				disable_mu_mimo = true;
-				break;
-			}
-		}
-		if (disable_mu_mimo)
-			cap &= ~IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE;
-		else
-			mu_mimo_owner = true;
-	}
-
-	mask = IEEE80211_VHT_CAP_BEAMFORMEE_STS_MASK;
-
-	ap_bf_sts = le32_to_cpu(ap_vht_cap->vht_cap_info) & mask;
-	our_bf_sts = cap & mask;
-
-	if (ap_bf_sts < our_bf_sts) {
-		cap &= ~mask;
-		cap |= ap_bf_sts;
-	}
-
-	/* reserve and fill IE */
-	pos = skb_put(skb, sizeof(struct ieee80211_vht_cap) + 2);
-	ieee80211_ie_build_vht_cap(pos, &vht_cap, cap);
-
-	return mu_mimo_owner;
-}
-
-/* This function determines HE capability flags for the association
- * and builds the IE.
- */
-static void ieee80211_add_he_ie(struct ieee80211_sub_if_data *sdata,
-				struct sk_buff *skb,
-				struct ieee80211_supported_band *sband,
-				enum ieee80211_smps_mode smps_mode,
-				ieee80211_conn_flags_t conn_flags)
-{
-	u8 *pos, *pre_he_pos;
-	const struct ieee80211_sta_he_cap *he_cap;
-	u8 he_cap_size;
-
-	he_cap = ieee80211_get_he_iftype_cap_vif(sband, &sdata->vif);
-	if (WARN_ON(!he_cap))
-		return;
-
-	/* get a max size estimate */
-	he_cap_size =
-		2 + 1 + sizeof(he_cap->he_cap_elem) +
-		ieee80211_he_mcs_nss_size(&he_cap->he_cap_elem) +
-		ieee80211_he_ppe_size(he_cap->ppe_thres[0],
-				      he_cap->he_cap_elem.phy_cap_info);
-	pos = skb_put(skb, he_cap_size);
-	pre_he_pos = pos;
-	pos = ieee80211_ie_build_he_cap(conn_flags,
-					pos, he_cap, pos + he_cap_size);
-	/* trim excess if any */
-	skb_trim(skb, skb->len - (pre_he_pos + he_cap_size - pos));
-
-	ieee80211_ie_build_he_6ghz_cap(sdata, smps_mode, skb);
-}
-
-static void ieee80211_add_eht_ie(struct ieee80211_sub_if_data *sdata,
-				 struct sk_buff *skb,
-				 struct ieee80211_supported_band *sband)
-{
-	u8 *pos;
-	const struct ieee80211_sta_he_cap *he_cap;
-	const struct ieee80211_sta_eht_cap *eht_cap;
-	u8 eht_cap_size;
-
-	he_cap = ieee80211_get_he_iftype_cap_vif(sband, &sdata->vif);
-	eht_cap = ieee80211_get_eht_iftype_cap_vif(sband, &sdata->vif);
-
-	/*
-	 * EHT capabilities element is only added if the HE capabilities element
-	 * was added so assume that 'he_cap' is valid and don't check it.
-	 */
-	if (WARN_ON(!he_cap || !eht_cap))
-		return;
-
-	eht_cap_size =
-		2 + 1 + sizeof(eht_cap->eht_cap_elem) +
-		ieee80211_eht_mcs_nss_size(&he_cap->he_cap_elem,
-					   &eht_cap->eht_cap_elem,
-					   false) +
-		ieee80211_eht_ppe_size(eht_cap->eht_ppe_thres[0],
-				       eht_cap->eht_cap_elem.phy_cap_info);
-	pos = skb_put(skb, eht_cap_size);
-	ieee80211_ie_build_eht_cap(pos, he_cap, eht_cap, pos + eht_cap_size,
-				   false);
-}
-
-static void ieee80211_assoc_add_rates(struct sk_buff *skb,
-				      enum nl80211_chan_width width,
-				      struct ieee80211_supported_band *sband,
-				      struct ieee80211_mgd_assoc_data *assoc_data)
-{
-	unsigned int shift = ieee80211_chanwidth_get_shift(width);
-	unsigned int rates_len, supp_rates_len;
-	u32 rates = 0;
-	int i, count;
-	u8 *pos;
-
-	if (assoc_data->supp_rates_len) {
-		/*
-		 * Get all rates supported by the device and the AP as
-		 * some APs don't like getting a superset of their rates
-		 * in the association request (e.g. D-Link DAP 1353 in
-		 * b-only mode)...
-		 */
-		rates_len = ieee80211_parse_bitrates(width, sband,
-						     assoc_data->supp_rates,
-						     assoc_data->supp_rates_len,
-						     &rates);
-	} else {
-		/*
-		 * In case AP not provide any supported rates information
-		 * before association, we send information element(s) with
-		 * all rates that we support.
-		 */
-		rates_len = sband->n_bitrates;
-		for (i = 0; i < sband->n_bitrates; i++)
-			rates |= BIT(i);
-	}
-
-	supp_rates_len = rates_len;
-	if (supp_rates_len > 8)
-		supp_rates_len = 8;
-
-	pos = skb_put(skb, supp_rates_len + 2);
-	*pos++ = WLAN_EID_SUPP_RATES;
-	*pos++ = supp_rates_len;
-
-	count = 0;
-	for (i = 0; i < sband->n_bitrates; i++) {
-		if (BIT(i) & rates) {
-			int rate = DIV_ROUND_UP(sband->bitrates[i].bitrate,
-						5 * (1 << shift));
-			*pos++ = (u8)rate;
-			if (++count == 8)
-				break;
-		}
-	}
-
-	if (rates_len > count) {
-		pos = skb_put(skb, rates_len - count + 2);
-		*pos++ = WLAN_EID_EXT_SUPP_RATES;
-		*pos++ = rates_len - count;
-
-		for (i++; i < sband->n_bitrates; i++) {
-			if (BIT(i) & rates) {
-				int rate;
-
-				rate = DIV_ROUND_UP(sband->bitrates[i].bitrate,
-						    5 * (1 << shift));
-				*pos++ = (u8)rate;
-			}
-		}
-	}
-}
-
-static size_t ieee80211_add_before_ht_elems(struct sk_buff *skb,
-					    const u8 *elems,
-					    size_t elems_len,
-					    size_t offset)
-{
-	size_t noffset;
-
-	static const u8 before_ht[] = {
-		WLAN_EID_SSID,
-		WLAN_EID_SUPP_RATES,
-		WLAN_EID_EXT_SUPP_RATES,
-		WLAN_EID_PWR_CAPABILITY,
-		WLAN_EID_SUPPORTED_CHANNELS,
-		WLAN_EID_RSN,
-		WLAN_EID_QOS_CAPA,
-		WLAN_EID_RRM_ENABLED_CAPABILITIES,
-		WLAN_EID_MOBILITY_DOMAIN,
-		WLAN_EID_FAST_BSS_TRANSITION,	/* reassoc only */
-		WLAN_EID_RIC_DATA,		/* reassoc only */
-		WLAN_EID_SUPPORTED_REGULATORY_CLASSES,
-	};
-	static const u8 after_ric[] = {
-		WLAN_EID_SUPPORTED_REGULATORY_CLASSES,
-		WLAN_EID_HT_CAPABILITY,
-		WLAN_EID_BSS_COEX_2040,
-		/* luckily this is almost always there */
-		WLAN_EID_EXT_CAPABILITY,
-		WLAN_EID_QOS_TRAFFIC_CAPA,
-		WLAN_EID_TIM_BCAST_REQ,
-		WLAN_EID_INTERWORKING,
-		/* 60 GHz (Multi-band, DMG, MMS) can't happen */
-		WLAN_EID_VHT_CAPABILITY,
-		WLAN_EID_OPMODE_NOTIF,
-	};
-
-	if (!elems_len)
-		return offset;
-
-	noffset = ieee80211_ie_split_ric(elems, elems_len,
-					 before_ht,
-					 ARRAY_SIZE(before_ht),
-					 after_ric,
-					 ARRAY_SIZE(after_ric),
-					 offset);
-	skb_put_data(skb, elems + offset, noffset - offset);
-
-	return noffset;
-}
-
-static size_t ieee80211_add_before_vht_elems(struct sk_buff *skb,
-					     const u8 *elems,
-					     size_t elems_len,
-					     size_t offset)
-{
-	static const u8 before_vht[] = {
-		/*
-		 * no need to list the ones split off before HT
-		 * or generated here
-		 */
-		WLAN_EID_BSS_COEX_2040,
-		WLAN_EID_EXT_CAPABILITY,
-		WLAN_EID_QOS_TRAFFIC_CAPA,
-		WLAN_EID_TIM_BCAST_REQ,
-		WLAN_EID_INTERWORKING,
-		/* 60 GHz (Multi-band, DMG, MMS) can't happen */
-	};
-	size_t noffset;
-
-	if (!elems_len)
-		return offset;
-
-	/* RIC already taken care of in ieee80211_add_before_ht_elems() */
-	noffset = ieee80211_ie_split(elems, elems_len,
-				     before_vht, ARRAY_SIZE(before_vht),
-				     offset);
-	skb_put_data(skb, elems + offset, noffset - offset);
-
-	return noffset;
-}
-
-static size_t ieee80211_add_before_he_elems(struct sk_buff *skb,
-					    const u8 *elems,
-					    size_t elems_len,
-					    size_t offset)
-{
-	static const u8 before_he[] = {
-		/*
-		 * no need to list the ones split off before VHT
-		 * or generated here
-		 */
-		WLAN_EID_OPMODE_NOTIF,
-		WLAN_EID_EXTENSION, WLAN_EID_EXT_FUTURE_CHAN_GUIDANCE,
-		/* 11ai elements */
-		WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_SESSION,
-		WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_PUBLIC_KEY,
-		WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_KEY_CONFIRM,
-		WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_HLP_CONTAINER,
-		WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_IP_ADDR_ASSIGN,
-		/* TODO: add 11ah/11aj/11ak elements */
-	};
-	size_t noffset;
-
-	if (!elems_len)
-		return offset;
-
-	/* RIC already taken care of in ieee80211_add_before_ht_elems() */
-	noffset = ieee80211_ie_split(elems, elems_len,
-				     before_he, ARRAY_SIZE(before_he),
-				     offset);
-	skb_put_data(skb, elems + offset, noffset - offset);
-
-	return noffset;
-}
-
-#define PRESENT_ELEMS_MAX	8
-#define PRESENT_ELEM_EXT_OFFS	0x100
-
-static void ieee80211_assoc_add_ml_elem(struct ieee80211_sub_if_data *sdata,
-					struct sk_buff *skb, u16 capab,
-					const struct element *ext_capa,
-					const u16 *present_elems);
-
-static size_t ieee80211_assoc_link_elems(struct ieee80211_sub_if_data *sdata,
-					 struct sk_buff *skb, u16 *capab,
-					 const struct element *ext_capa,
-					 const u8 *extra_elems,
-					 size_t extra_elems_len,
-					 unsigned int link_id,
-					 struct ieee80211_link_data *link,
-					 u16 *present_elems)
-{
-	enum nl80211_iftype iftype = ieee80211_vif_type_p2p(&sdata->vif);
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-	struct ieee80211_mgd_assoc_data *assoc_data = ifmgd->assoc_data;
-	struct cfg80211_bss *cbss = assoc_data->link[link_id].bss;
-	struct ieee80211_channel *chan = cbss->channel;
-	const struct ieee80211_sband_iftype_data *iftd;
-	struct ieee80211_local *local = sdata->local;
-	struct ieee80211_supported_band *sband;
-	enum nl80211_chan_width width = NL80211_CHAN_WIDTH_20;
-	struct ieee80211_chanctx_conf *chanctx_conf;
-	enum ieee80211_smps_mode smps_mode;
-	u16 orig_capab = *capab;
-	size_t offset = 0;
-	int present_elems_len = 0;
-	u8 *pos;
-	int i;
-
-#define ADD_PRESENT_ELEM(id) do {					\
-	/* need a last for termination - we use 0 == SSID */		\
-	if (!WARN_ON(present_elems_len >= PRESENT_ELEMS_MAX - 1))	\
-		present_elems[present_elems_len++] = (id);		\
-} while (0)
-#define ADD_PRESENT_EXT_ELEM(id) ADD_PRESENT_ELEM(PRESENT_ELEM_EXT_OFFS | (id))
-
-	if (link)
-		smps_mode = link->smps_mode;
-	else if (sdata->u.mgd.powersave)
-		smps_mode = IEEE80211_SMPS_DYNAMIC;
-	else
-		smps_mode = IEEE80211_SMPS_OFF;
-
-	if (link) {
-		/*
-		 * 5/10 MHz scenarios are only viable without MLO, in which
-		 * case this pointer should be used ... All of this is a bit
-		 * unclear though, not sure this even works at all.
-		 */
-		rcu_read_lock();
-		chanctx_conf = rcu_dereference(link->conf->chanctx_conf);
-		if (chanctx_conf)
-			width = chanctx_conf->def.width;
-		rcu_read_unlock();
-	}
-
-	sband = local->hw.wiphy->bands[chan->band];
-	iftd = ieee80211_get_sband_iftype_data(sband, iftype);
-
-	if (sband->band == NL80211_BAND_2GHZ) {
-		*capab |= WLAN_CAPABILITY_SHORT_SLOT_TIME;
-		*capab |= WLAN_CAPABILITY_SHORT_PREAMBLE;
-	}
-
-	if ((cbss->capability & WLAN_CAPABILITY_SPECTRUM_MGMT) &&
-	    ieee80211_hw_check(&local->hw, SPECTRUM_MGMT))
-		*capab |= WLAN_CAPABILITY_SPECTRUM_MGMT;
-
-	if (sband->band != NL80211_BAND_S1GHZ)
-		ieee80211_assoc_add_rates(skb, width, sband, assoc_data);
-
-	if (*capab & WLAN_CAPABILITY_SPECTRUM_MGMT ||
-	    *capab & WLAN_CAPABILITY_RADIO_MEASURE) {
-		struct cfg80211_chan_def chandef = {
-			.width = width,
-			.chan = chan,
-		};
-
-		pos = skb_put(skb, 4);
-		*pos++ = WLAN_EID_PWR_CAPABILITY;
-		*pos++ = 2;
-		*pos++ = 0; /* min tx power */
-		 /* max tx power */
-		*pos++ = ieee80211_chandef_max_power(&chandef);
-		ADD_PRESENT_ELEM(WLAN_EID_PWR_CAPABILITY);
-	}
-
-	/*
-	 * Per spec, we shouldn't include the list of channels if we advertise
-	 * support for extended channel switching, but we've always done that;
-	 * (for now?) apply this restriction only on the (new) 6 GHz band.
-	 */
-	if (*capab & WLAN_CAPABILITY_SPECTRUM_MGMT &&
-	    (sband->band != NL80211_BAND_6GHZ ||
-	     !ext_capa || ext_capa->datalen < 1 ||
-	     !(ext_capa->data[0] & WLAN_EXT_CAPA1_EXT_CHANNEL_SWITCHING))) {
-		/* TODO: get this in reg domain format */
-		pos = skb_put(skb, 2 * sband->n_channels + 2);
-		*pos++ = WLAN_EID_SUPPORTED_CHANNELS;
-		*pos++ = 2 * sband->n_channels;
-		for (i = 0; i < sband->n_channels; i++) {
-			int cf = sband->channels[i].center_freq;
-
-			*pos++ = ieee80211_frequency_to_channel(cf);
-			*pos++ = 1; /* one channel in the subband*/
-		}
-		ADD_PRESENT_ELEM(WLAN_EID_SUPPORTED_CHANNELS);
-	}
-
-	/* if present, add any custom IEs that go before HT */
-	offset = ieee80211_add_before_ht_elems(skb, extra_elems,
-					       extra_elems_len,
-					       offset);
-
-	if (sband->band != NL80211_BAND_6GHZ &&
-	    !(assoc_data->link[link_id].conn_flags & IEEE80211_CONN_DISABLE_HT)) {
-		ieee80211_add_ht_ie(sdata, skb,
-				    assoc_data->link[link_id].ap_ht_param,
-				    sband, chan, smps_mode,
-				    assoc_data->link[link_id].conn_flags);
-		ADD_PRESENT_ELEM(WLAN_EID_HT_CAPABILITY);
-	}
-
-	/* if present, add any custom IEs that go before VHT */
-	offset = ieee80211_add_before_vht_elems(skb, extra_elems,
-						extra_elems_len,
-						offset);
-
-	if (sband->band != NL80211_BAND_6GHZ &&
-	    !(assoc_data->link[link_id].conn_flags & IEEE80211_CONN_DISABLE_VHT)) {
-		bool mu_mimo_owner =
-			ieee80211_add_vht_ie(sdata, skb, sband,
-					     &assoc_data->link[link_id].ap_vht_cap,
-					     assoc_data->link[link_id].conn_flags);
-
-		if (link)
-			link->conf->mu_mimo_owner = mu_mimo_owner;
-		ADD_PRESENT_ELEM(WLAN_EID_VHT_CAPABILITY);
-	}
-
-	/*
-	 * If AP doesn't support HT, mark HE and EHT as disabled.
-	 * If on the 5GHz band, make sure it supports VHT.
-	 */
-	if (assoc_data->link[link_id].conn_flags & IEEE80211_CONN_DISABLE_HT ||
-	    (sband->band == NL80211_BAND_5GHZ &&
-	     assoc_data->link[link_id].conn_flags & IEEE80211_CONN_DISABLE_VHT))
-		assoc_data->link[link_id].conn_flags |=
-			IEEE80211_CONN_DISABLE_HE |
-			IEEE80211_CONN_DISABLE_EHT;
-
-	/* if present, add any custom IEs that go before HE */
-	offset = ieee80211_add_before_he_elems(skb, extra_elems,
-					       extra_elems_len,
-					       offset);
-
-	if (!(assoc_data->link[link_id].conn_flags & IEEE80211_CONN_DISABLE_HE)) {
-		ieee80211_add_he_ie(sdata, skb, sband, smps_mode,
-				    assoc_data->link[link_id].conn_flags);
-		ADD_PRESENT_EXT_ELEM(WLAN_EID_EXT_HE_CAPABILITY);
-	}
-
-	/*
-	 * careful - need to know about all the present elems before
-	 * calling ieee80211_assoc_add_ml_elem(), so add this one if
-	 * we're going to put it after the ML element
-	 */
-	if (!(assoc_data->link[link_id].conn_flags & IEEE80211_CONN_DISABLE_EHT))
-		ADD_PRESENT_EXT_ELEM(WLAN_EID_EXT_EHT_CAPABILITY);
-
-	if (link_id == assoc_data->assoc_link_id)
-		ieee80211_assoc_add_ml_elem(sdata, skb, orig_capab, ext_capa,
-					    present_elems);
-
-	/* crash if somebody gets it wrong */
-	present_elems = NULL;
-
-	if (!(assoc_data->link[link_id].conn_flags & IEEE80211_CONN_DISABLE_EHT))
-		ieee80211_add_eht_ie(sdata, skb, sband);
-
-	if (sband->band == NL80211_BAND_S1GHZ) {
-		ieee80211_add_aid_request_ie(sdata, skb);
-		ieee80211_add_s1g_capab_ie(sdata, &sband->s1g_cap, skb);
-	}
-
-	if (iftd && iftd->vendor_elems.data && iftd->vendor_elems.len)
-		skb_put_data(skb, iftd->vendor_elems.data, iftd->vendor_elems.len);
-
-	if (link)
-		link->u.mgd.conn_flags = assoc_data->link[link_id].conn_flags;
-
-	return offset;
-}
-
-static void ieee80211_add_non_inheritance_elem(struct sk_buff *skb,
-					       const u16 *outer,
-					       const u16 *inner)
-{
-	unsigned int skb_len = skb->len;
-	bool at_extension = false;
-	bool added = false;
-	int i, j;
-	u8 *len, *list_len = NULL;
-
-	skb_put_u8(skb, WLAN_EID_EXTENSION);
-	len = skb_put(skb, 1);
-	skb_put_u8(skb, WLAN_EID_EXT_NON_INHERITANCE);
-
-	for (i = 0; i < PRESENT_ELEMS_MAX && outer[i]; i++) {
-		u16 elem = outer[i];
-		bool have_inner = false;
-
-		/* should at least be sorted in the sense of normal -> ext */
-		WARN_ON(at_extension && elem < PRESENT_ELEM_EXT_OFFS);
-
-		/* switch to extension list */
-		if (!at_extension && elem >= PRESENT_ELEM_EXT_OFFS) {
-			at_extension = true;
-			if (!list_len)
-				skb_put_u8(skb, 0);
-			list_len = NULL;
-		}
-
-		for (j = 0; j < PRESENT_ELEMS_MAX && inner[j]; j++) {
-			if (elem == inner[j]) {
-				have_inner = true;
-				break;
-			}
-		}
-
-		if (have_inner)
-			continue;
-
-		if (!list_len) {
-			list_len = skb_put(skb, 1);
-			*list_len = 0;
-		}
-		*list_len += 1;
-		skb_put_u8(skb, (u8)elem);
-		added = true;
-	}
-
-	/* if we added a list but no extension list, make a zero-len one */
-	if (added && (!at_extension || !list_len))
-		skb_put_u8(skb, 0);
-
-	/* if nothing added remove extension element completely */
-	if (!added)
-		skb_trim(skb, skb_len);
-	else
-		*len = skb->len - skb_len - 2;
-}
-
-static void ieee80211_assoc_add_ml_elem(struct ieee80211_sub_if_data *sdata,
-					struct sk_buff *skb, u16 capab,
-					const struct element *ext_capa,
-					const u16 *outer_present_elems)
-{
-	struct ieee80211_local *local = sdata->local;
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-	struct ieee80211_mgd_assoc_data *assoc_data = ifmgd->assoc_data;
-	struct ieee80211_multi_link_elem *ml_elem;
-	struct ieee80211_mle_basic_common_info *common;
-	const struct wiphy_iftype_ext_capab *ift_ext_capa;
-	__le16 eml_capa = 0, mld_capa_ops = 0;
-	unsigned int link_id;
-	u8 *ml_elem_len;
-	void *capab_pos;
-
-	if (!ieee80211_vif_is_mld(&sdata->vif))
-		return;
-
-	ift_ext_capa = cfg80211_get_iftype_ext_capa(local->hw.wiphy,
-						    ieee80211_vif_type_p2p(&sdata->vif));
-	if (ift_ext_capa) {
-		eml_capa = cpu_to_le16(ift_ext_capa->eml_capabilities);
-		mld_capa_ops = cpu_to_le16(ift_ext_capa->mld_capa_and_ops);
-	}
-
-	skb_put_u8(skb, WLAN_EID_EXTENSION);
-	ml_elem_len = skb_put(skb, 1);
-	skb_put_u8(skb, WLAN_EID_EXT_EHT_MULTI_LINK);
-	ml_elem = skb_put(skb, sizeof(*ml_elem));
-	ml_elem->control =
-		cpu_to_le16(IEEE80211_ML_CONTROL_TYPE_BASIC |
-			    IEEE80211_MLC_BASIC_PRES_MLD_CAPA_OP);
-	common = skb_put(skb, sizeof(*common));
-	common->len = sizeof(*common) +
-		      2;  /* MLD capa/ops */
-	memcpy(common->mld_mac_addr, sdata->vif.addr, ETH_ALEN);
-
-	/* add EML_CAPA only if needed, see Draft P802.11be_D2.1, 35.3.17 */
-	if (eml_capa &
-	    cpu_to_le16((IEEE80211_EML_CAP_EMLSR_SUPP |
-			 IEEE80211_EML_CAP_EMLMR_SUPPORT))) {
-		common->len += 2; /* EML capabilities */
-		ml_elem->control |=
-			cpu_to_le16(IEEE80211_MLC_BASIC_PRES_EML_CAPA);
-		skb_put_data(skb, &eml_capa, sizeof(eml_capa));
-	}
-	/* need indication from userspace to support this */
-	mld_capa_ops &= ~cpu_to_le16(IEEE80211_MLD_CAP_OP_TID_TO_LINK_MAP_NEG_SUPP);
-	skb_put_data(skb, &mld_capa_ops, sizeof(mld_capa_ops));
-
-	for (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {
-		u16 link_present_elems[PRESENT_ELEMS_MAX] = {};
-		const u8 *extra_elems;
-		size_t extra_elems_len;
-		size_t extra_used;
-		u8 *subelem_len = NULL;
-		__le16 ctrl;
-
-		if (!assoc_data->link[link_id].bss ||
-		    link_id == assoc_data->assoc_link_id)
-			continue;
-
-		extra_elems = assoc_data->link[link_id].elems;
-		extra_elems_len = assoc_data->link[link_id].elems_len;
-
-		skb_put_u8(skb, IEEE80211_MLE_SUBELEM_PER_STA_PROFILE);
-		subelem_len = skb_put(skb, 1);
-
-		ctrl = cpu_to_le16(link_id |
-				   IEEE80211_MLE_STA_CONTROL_COMPLETE_PROFILE |
-				   IEEE80211_MLE_STA_CONTROL_STA_MAC_ADDR_PRESENT);
-		skb_put_data(skb, &ctrl, sizeof(ctrl));
-		skb_put_u8(skb, 1 + ETH_ALEN); /* STA Info Length */
-		skb_put_data(skb, assoc_data->link[link_id].addr,
-			     ETH_ALEN);
-		/*
-		 * Now add the contents of the (re)association request,
-		 * but the "listen interval" and "current AP address"
-		 * (if applicable) are skipped. So we only have
-		 * the capability field (remember the position and fill
-		 * later), followed by the elements added below by
-		 * calling ieee80211_assoc_link_elems().
-		 */
-		capab_pos = skb_put(skb, 2);
-
-		extra_used = ieee80211_assoc_link_elems(sdata, skb, &capab,
-							ext_capa,
-							extra_elems,
-							extra_elems_len,
-							link_id, NULL,
-							link_present_elems);
-		if (extra_elems)
-			skb_put_data(skb, extra_elems + extra_used,
-				     extra_elems_len - extra_used);
-
-		put_unaligned_le16(capab, capab_pos);
-
-		ieee80211_add_non_inheritance_elem(skb, outer_present_elems,
-						   link_present_elems);
-
-		ieee80211_fragment_element(skb, subelem_len,
-					   IEEE80211_MLE_SUBELEM_FRAGMENT);
-	}
-
-	ieee80211_fragment_element(skb, ml_elem_len, WLAN_EID_FRAGMENT);
-}
-
-static int ieee80211_send_assoc(struct ieee80211_sub_if_data *sdata)
-{
-	struct ieee80211_local *local = sdata->local;
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-	struct ieee80211_mgd_assoc_data *assoc_data = ifmgd->assoc_data;
-	struct ieee80211_link_data *link;
-	struct sk_buff *skb;
-	struct ieee80211_mgmt *mgmt;
-	u8 *pos, qos_info, *ie_start;
-	size_t offset, noffset;
-	u16 capab = WLAN_CAPABILITY_ESS, link_capab;
-	__le16 listen_int;
-	struct element *ext_capa = NULL;
-	enum nl80211_iftype iftype = ieee80211_vif_type_p2p(&sdata->vif);
-	struct ieee80211_prep_tx_info info = {};
-	unsigned int link_id, n_links = 0;
-	u16 present_elems[PRESENT_ELEMS_MAX] = {};
-	void *capab_pos;
-	size_t size;
-	int ret;
-
-	/* we know it's writable, cast away the const */
-	if (assoc_data->ie_len)
-		ext_capa = (void *)cfg80211_find_elem(WLAN_EID_EXT_CAPABILITY,
-						      assoc_data->ie,
-						      assoc_data->ie_len);
-
-	sdata_assert_lock(sdata);
-
-	size = local->hw.extra_tx_headroom +
-	       sizeof(*mgmt) + /* bit too much but doesn't matter */
-	       2 + assoc_data->ssid_len + /* SSID */
-	       assoc_data->ie_len + /* extra IEs */
-	       (assoc_data->fils_kek_len ? 16 /* AES-SIV */ : 0) +
-	       9; /* WMM */
-
-	for (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {
-		struct cfg80211_bss *cbss = assoc_data->link[link_id].bss;
-		const struct ieee80211_sband_iftype_data *iftd;
-		struct ieee80211_supported_band *sband;
-
-		if (!cbss)
-			continue;
-
-		sband = local->hw.wiphy->bands[cbss->channel->band];
-
-		n_links++;
-		/* add STA profile elements length */
-		size += assoc_data->link[link_id].elems_len;
-		/* and supported rates length */
-		size += 4 + sband->n_bitrates;
-		/* supported channels */
-		size += 2 + 2 * sband->n_channels;
-
-		iftd = ieee80211_get_sband_iftype_data(sband, iftype);
-		if (iftd)
-			size += iftd->vendor_elems.len;
-
-		/* power capability */
-		size += 4;
-
-		/* HT, VHT, HE, EHT */
-		size += 2 + sizeof(struct ieee80211_ht_cap);
-		size += 2 + sizeof(struct ieee80211_vht_cap);
-		size += 2 + 1 + sizeof(struct ieee80211_he_cap_elem) +
-			sizeof(struct ieee80211_he_mcs_nss_supp) +
-			IEEE80211_HE_PPE_THRES_MAX_LEN;
-
-		if (sband->band == NL80211_BAND_6GHZ)
-			size += 2 + 1 + sizeof(struct ieee80211_he_6ghz_capa);
-
-		size += 2 + 1 + sizeof(struct ieee80211_eht_cap_elem) +
-			sizeof(struct ieee80211_eht_mcs_nss_supp) +
-			IEEE80211_EHT_PPE_THRES_MAX_LEN;
-
-		/* non-inheritance element */
-		size += 2 + 2 + PRESENT_ELEMS_MAX;
-
-		/* should be the same across all BSSes */
-		if (cbss->capability & WLAN_CAPABILITY_PRIVACY)
-			capab |= WLAN_CAPABILITY_PRIVACY;
-	}
-
-	if (ieee80211_vif_is_mld(&sdata->vif)) {
-		/* consider the multi-link element with STA profile */
-		size += sizeof(struct ieee80211_multi_link_elem);
-		/* max common info field in basic multi-link element */
-		size += sizeof(struct ieee80211_mle_basic_common_info) +
-			2 + /* capa & op */
-			2; /* EML capa */
-
-		/*
-		 * The capability elements were already considered above;
-		 * note this over-estimates a bit because there's no
-		 * STA profile for the assoc link.
-		 */
-		size += (n_links - 1) *
-			(1 + 1 + /* subelement ID/length */
-			 2 + /* STA control */
-			 1 + ETH_ALEN + 2 /* STA Info field */);
-	}
-
-	link = sdata_dereference(sdata->link[assoc_data->assoc_link_id], sdata);
-	if (WARN_ON(!link))
-		return -EINVAL;
-
-	if (WARN_ON(!assoc_data->link[assoc_data->assoc_link_id].bss))
-		return -EINVAL;
-
-	skb = alloc_skb(size, GFP_KERNEL);
-	if (!skb)
-		return -ENOMEM;
-
-	skb_reserve(skb, local->hw.extra_tx_headroom);
-
-	if (ifmgd->flags & IEEE80211_STA_ENABLE_RRM)
-		capab |= WLAN_CAPABILITY_RADIO_MEASURE;
-
-	/* Set MBSSID support for HE AP if needed */
-	if (ieee80211_hw_check(&local->hw, SUPPORTS_ONLY_HE_MULTI_BSSID) &&
-	    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HE) &&
-	    ext_capa && ext_capa->datalen >= 3)
-		ext_capa->data[2] |= WLAN_EXT_CAPA3_MULTI_BSSID_SUPPORT;
-
-	mgmt = skb_put_zero(skb, 24);
-	memcpy(mgmt->da, sdata->vif.cfg.ap_addr, ETH_ALEN);
-	memcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);
-	memcpy(mgmt->bssid, sdata->vif.cfg.ap_addr, ETH_ALEN);
-
-	listen_int = cpu_to_le16(assoc_data->s1g ?
-			ieee80211_encode_usf(local->hw.conf.listen_interval) :
-			local->hw.conf.listen_interval);
-	if (!is_zero_ether_addr(assoc_data->prev_ap_addr)) {
-		skb_put(skb, 10);
-		mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
-						  IEEE80211_STYPE_REASSOC_REQ);
-		capab_pos = &mgmt->u.reassoc_req.capab_info;
-		mgmt->u.reassoc_req.listen_interval = listen_int;
-		memcpy(mgmt->u.reassoc_req.current_ap,
-		       assoc_data->prev_ap_addr, ETH_ALEN);
-		info.subtype = IEEE80211_STYPE_REASSOC_REQ;
-	} else {
-		skb_put(skb, 4);
-		mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
-						  IEEE80211_STYPE_ASSOC_REQ);
-		capab_pos = &mgmt->u.assoc_req.capab_info;
-		mgmt->u.assoc_req.listen_interval = listen_int;
-		info.subtype = IEEE80211_STYPE_ASSOC_REQ;
-	}
-
-	/* SSID */
-	pos = skb_put(skb, 2 + assoc_data->ssid_len);
-	ie_start = pos;
-	*pos++ = WLAN_EID_SSID;
-	*pos++ = assoc_data->ssid_len;
-	memcpy(pos, assoc_data->ssid, assoc_data->ssid_len);
-
-	/* add the elements for the assoc (main) link */
-	link_capab = capab;
-	offset = ieee80211_assoc_link_elems(sdata, skb, &link_capab,
-					    ext_capa,
-					    assoc_data->ie,
-					    assoc_data->ie_len,
-					    assoc_data->assoc_link_id, link,
-					    present_elems);
-	put_unaligned_le16(link_capab, capab_pos);
-
-	/* if present, add any custom non-vendor IEs */
-	if (assoc_data->ie_len) {
-		noffset = ieee80211_ie_split_vendor(assoc_data->ie,
-						    assoc_data->ie_len,
-						    offset);
-		skb_put_data(skb, assoc_data->ie + offset, noffset - offset);
-		offset = noffset;
-	}
-
-	if (assoc_data->wmm) {
-		if (assoc_data->uapsd) {
-			qos_info = ifmgd->uapsd_queues;
-			qos_info |= (ifmgd->uapsd_max_sp_len <<
-				     IEEE80211_WMM_IE_STA_QOSINFO_SP_SHIFT);
-		} else {
-			qos_info = 0;
-		}
-
-		pos = ieee80211_add_wmm_info_ie(skb_put(skb, 9), qos_info);
-	}
-
-	/* add any remaining custom (i.e. vendor specific here) IEs */
-	if (assoc_data->ie_len) {
-		noffset = assoc_data->ie_len;
-		skb_put_data(skb, assoc_data->ie + offset, noffset - offset);
-	}
-
-	if (assoc_data->fils_kek_len) {
-		ret = fils_encrypt_assoc_req(skb, assoc_data);
-		if (ret < 0) {
-			dev_kfree_skb(skb);
-			return ret;
-		}
-	}
-
-	pos = skb_tail_pointer(skb);
-	kfree(ifmgd->assoc_req_ies);
-	ifmgd->assoc_req_ies = kmemdup(ie_start, pos - ie_start, GFP_ATOMIC);
-	if (!ifmgd->assoc_req_ies) {
-		dev_kfree_skb(skb);
-		return -ENOMEM;
-	}
-
-	ifmgd->assoc_req_ies_len = pos - ie_start;
-
-	drv_mgd_prepare_tx(local, sdata, &info);
-
-	IEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;
-	if (ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS))
-		IEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_CTL_REQ_TX_STATUS |
-						IEEE80211_TX_INTFL_MLME_CONN_TX;
-	ieee80211_tx_skb(sdata, skb);
-
-	return 0;
-}
-
-void ieee80211_send_pspoll(struct ieee80211_local *local,
-			   struct ieee80211_sub_if_data *sdata)
-{
-	struct ieee80211_pspoll *pspoll;
-	struct sk_buff *skb;
-
-	skb = ieee80211_pspoll_get(&local->hw, &sdata->vif);
-	if (!skb)
-		return;
-
-	pspoll = (struct ieee80211_pspoll *) skb->data;
-	pspoll->frame_control |= cpu_to_le16(IEEE80211_FCTL_PM);
-
-	IEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;
-	ieee80211_tx_skb(sdata, skb);
-}
-
-void ieee80211_send_nullfunc(struct ieee80211_local *local,
-			     struct ieee80211_sub_if_data *sdata,
-			     bool powersave)
-{
-	struct sk_buff *skb;
-	struct ieee80211_hdr_3addr *nullfunc;
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-
-	skb = ieee80211_nullfunc_get(&local->hw, &sdata->vif, -1,
-				     !ieee80211_hw_check(&local->hw,
-							 DOESNT_SUPPORT_QOS_NDP));
-	if (!skb)
-		return;
-
-	nullfunc = (struct ieee80211_hdr_3addr *) skb->data;
-	if (powersave)
-		nullfunc->frame_control |= cpu_to_le16(IEEE80211_FCTL_PM);
-
-	IEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT |
-					IEEE80211_TX_INTFL_OFFCHAN_TX_OK;
-
-	if (ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS))
-		IEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_CTL_REQ_TX_STATUS;
-
-	if (ifmgd->flags & IEEE80211_STA_CONNECTION_POLL)
-		IEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_CTL_USE_MINRATE;
-
-	ieee80211_tx_skb(sdata, skb);
-}
-
-void ieee80211_send_4addr_nullfunc(struct ieee80211_local *local,
-				   struct ieee80211_sub_if_data *sdata)
-{
-	struct sk_buff *skb;
-	struct ieee80211_hdr *nullfunc;
-	__le16 fc;
-
-	if (WARN_ON(sdata->vif.type != NL80211_IFTYPE_STATION))
-		return;
-
-	skb = dev_alloc_skb(local->hw.extra_tx_headroom + 30);
-	if (!skb)
-		return;
-
-	skb_reserve(skb, local->hw.extra_tx_headroom);
-
-	nullfunc = skb_put_zero(skb, 30);
-	fc = cpu_to_le16(IEEE80211_FTYPE_DATA | IEEE80211_STYPE_NULLFUNC |
-			 IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS);
-	nullfunc->frame_control = fc;
-	memcpy(nullfunc->addr1, sdata->deflink.u.mgd.bssid, ETH_ALEN);
-	memcpy(nullfunc->addr2, sdata->vif.addr, ETH_ALEN);
-	memcpy(nullfunc->addr3, sdata->deflink.u.mgd.bssid, ETH_ALEN);
-	memcpy(nullfunc->addr4, sdata->vif.addr, ETH_ALEN);
-
-	IEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;
-	IEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_CTL_USE_MINRATE;
-	ieee80211_tx_skb(sdata, skb);
-}
-
-/* spectrum management related things */
-static void ieee80211_chswitch_work(struct wiphy *wiphy,
-				    struct wiphy_work *work)
-{
-	struct ieee80211_link_data *link =
-		container_of(work, struct ieee80211_link_data,
-			     u.mgd.chswitch_work.work);
-	struct ieee80211_sub_if_data *sdata = link->sdata;
-	struct ieee80211_local *local = sdata->local;
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-	int ret;
-
-	if (!ieee80211_sdata_running(sdata))
-		return;
-
-	sdata_lock(sdata);
-	mutex_lock(&local->mtx);
-	mutex_lock(&local->chanctx_mtx);
-
-	if (!ifmgd->associated)
-		goto out;
-
-	if (!link->conf->csa_active)
-		goto out;
-
-	/*
-	 * using reservation isn't immediate as it may be deferred until later
-	 * with multi-vif. once reservation is complete it will re-schedule the
-	 * work with no reserved_chanctx so verify chandef to check if it
-	 * completed successfully
-	 */
-
-	if (link->reserved_chanctx) {
-		/*
-		 * with multi-vif csa driver may call ieee80211_csa_finish()
-		 * many times while waiting for other interfaces to use their
-		 * reservations
-		 */
-		if (link->reserved_ready)
-			goto out;
-
-		ret = ieee80211_link_use_reserved_context(link);
-		if (ret) {
-			sdata_info(sdata,
-				   "failed to use reserved channel context, disconnecting (err=%d)\n",
-				   ret);
-			wiphy_work_queue(sdata->local->hw.wiphy,
-					 &ifmgd->csa_connection_drop_work);
-			goto out;
-		}
-
-		goto out;
-	}
-
-	if (!cfg80211_chandef_identical(&link->conf->chandef,
-					&link->csa_chandef)) {
-		sdata_info(sdata,
-			   "failed to finalize channel switch, disconnecting\n");
-		wiphy_work_queue(sdata->local->hw.wiphy,
-				 &ifmgd->csa_connection_drop_work);
-		goto out;
-	}
-
-	link->u.mgd.csa_waiting_bcn = true;
-
-	ieee80211_sta_reset_beacon_monitor(sdata);
-	ieee80211_sta_reset_conn_monitor(sdata);
-
-out:
-	mutex_unlock(&local->chanctx_mtx);
-	mutex_unlock(&local->mtx);
-	sdata_unlock(sdata);
-}
-
-static void ieee80211_chswitch_post_beacon(struct ieee80211_link_data *link)
-{
-	struct ieee80211_sub_if_data *sdata = link->sdata;
-	struct ieee80211_local *local = sdata->local;
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-	int ret;
-
-	sdata_assert_lock(sdata);
-
-	WARN_ON(!link->conf->csa_active);
-
-	if (link->csa_block_tx) {
-		ieee80211_wake_vif_queues(local, sdata,
-					  IEEE80211_QUEUE_STOP_REASON_CSA);
-		link->csa_block_tx = false;
-	}
-
-	link->conf->csa_active = false;
-	link->u.mgd.csa_waiting_bcn = false;
-	/*
-	 * If the CSA IE is still present on the beacon after the switch,
-	 * we need to consider it as a new CSA (possibly to self).
-	 */
-	link->u.mgd.beacon_crc_valid = false;
-
-	ret = drv_post_channel_switch(sdata);
-	if (ret) {
-		sdata_info(sdata,
-			   "driver post channel switch failed, disconnecting\n");
-		wiphy_work_queue(sdata->local->hw.wiphy,
-				 &ifmgd->csa_connection_drop_work);
-		return;
-	}
-
-	cfg80211_ch_switch_notify(sdata->dev, &link->reserved_chandef, 0, 0);
-}
-
-void ieee80211_chswitch_done(struct ieee80211_vif *vif, bool success)
-{
-	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-
-	if (WARN_ON(ieee80211_vif_is_mld(&sdata->vif)))
-		success = false;
-
-	trace_api_chswitch_done(sdata, success);
-	if (!success) {
-		sdata_info(sdata,
-			   "driver channel switch failed, disconnecting\n");
-		wiphy_work_queue(sdata->local->hw.wiphy,
-				 &ifmgd->csa_connection_drop_work);
-	} else {
-		wiphy_delayed_work_queue(sdata->local->hw.wiphy,
-					 &sdata->deflink.u.mgd.chswitch_work,
-					 0);
-	}
-}
-EXPORT_SYMBOL(ieee80211_chswitch_done);
-
-static void
-ieee80211_sta_abort_chanswitch(struct ieee80211_link_data *link)
-{
-	struct ieee80211_sub_if_data *sdata = link->sdata;
-	struct ieee80211_local *local = sdata->local;
-
-	if (!local->ops->abort_channel_switch)
-		return;
-
-	mutex_lock(&local->mtx);
-
-	mutex_lock(&local->chanctx_mtx);
-	ieee80211_link_unreserve_chanctx(link);
-	mutex_unlock(&local->chanctx_mtx);
-
-	if (link->csa_block_tx)
-		ieee80211_wake_vif_queues(local, sdata,
-					  IEEE80211_QUEUE_STOP_REASON_CSA);
-
-	link->csa_block_tx = false;
-	link->conf->csa_active = false;
-
-	mutex_unlock(&local->mtx);
-
-	drv_abort_channel_switch(sdata);
-}
-
-static void
-ieee80211_sta_process_chanswitch(struct ieee80211_link_data *link,
-				 u64 timestamp, u32 device_timestamp,
-				 struct ieee802_11_elems *elems,
-				 bool beacon)
-{
-	struct ieee80211_sub_if_data *sdata = link->sdata;
-	struct ieee80211_local *local = sdata->local;
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-	struct cfg80211_bss *cbss = link->u.mgd.bss;
-	struct ieee80211_chanctx_conf *conf;
-	struct ieee80211_chanctx *chanctx;
-	enum nl80211_band current_band;
-	struct ieee80211_csa_ie csa_ie;
-	struct ieee80211_channel_switch ch_switch;
-	struct ieee80211_bss *bss;
-	unsigned long timeout;
-	int res;
-
-	sdata_assert_lock(sdata);
-
-	if (!cbss)
-		return;
-
-	current_band = cbss->channel->band;
-	bss = (void *)cbss->priv;
-	res = ieee80211_parse_ch_switch_ie(sdata, elems, current_band,
-					   bss->vht_cap_info,
-					   link->u.mgd.conn_flags,
-					   link->u.mgd.bssid, &csa_ie);
-
-	if (!res) {
-		ch_switch.timestamp = timestamp;
-		ch_switch.device_timestamp = device_timestamp;
-		ch_switch.block_tx = csa_ie.mode;
-		ch_switch.chandef = csa_ie.chandef;
-		ch_switch.count = csa_ie.count;
-		ch_switch.delay = csa_ie.max_switch_time;
-	}
-
-	if (res < 0)
-		goto lock_and_drop_connection;
-
-	if (beacon && link->conf->csa_active &&
-	    !link->u.mgd.csa_waiting_bcn) {
-		if (res)
-			ieee80211_sta_abort_chanswitch(link);
-		else
-			drv_channel_switch_rx_beacon(sdata, &ch_switch);
-		return;
-	} else if (link->conf->csa_active || res) {
-		/* disregard subsequent announcements if already processing */
-		return;
-	}
-
-	if (link->conf->chandef.chan->band !=
-	    csa_ie.chandef.chan->band) {
-		sdata_info(sdata,
-			   "AP %pM switches to different band (%d MHz, width:%d, CF1/2: %d/%d MHz), disconnecting\n",
-			   link->u.mgd.bssid,
-			   csa_ie.chandef.chan->center_freq,
-			   csa_ie.chandef.width, csa_ie.chandef.center_freq1,
-			   csa_ie.chandef.center_freq2);
-		goto lock_and_drop_connection;
-	}
-
-	if (!cfg80211_chandef_usable(local->hw.wiphy, &csa_ie.chandef,
-				     IEEE80211_CHAN_DISABLED)) {
-		sdata_info(sdata,
-			   "AP %pM switches to unsupported channel "
-			   "(%d.%03d MHz, width:%d, CF1/2: %d.%03d/%d MHz), "
-			   "disconnecting\n",
-			   link->u.mgd.bssid,
-			   csa_ie.chandef.chan->center_freq,
-			   csa_ie.chandef.chan->freq_offset,
-			   csa_ie.chandef.width, csa_ie.chandef.center_freq1,
-			   csa_ie.chandef.freq1_offset,
-			   csa_ie.chandef.center_freq2);
-		goto lock_and_drop_connection;
-	}
-
-	if (cfg80211_chandef_identical(&csa_ie.chandef,
-				       &link->conf->chandef) &&
-	    (!csa_ie.mode || !beacon)) {
-		if (link->u.mgd.csa_ignored_same_chan)
-			return;
-		sdata_info(sdata,
-			   "AP %pM tries to chanswitch to same channel, ignore\n",
-			   link->u.mgd.bssid);
-		link->u.mgd.csa_ignored_same_chan = true;
-		return;
-	}
-
-	/*
-	 * Drop all TDLS peers - either we disconnect or move to a different
-	 * channel from this point on. There's no telling what our peer will do.
-	 * The TDLS WIDER_BW scenario is also problematic, as peers might now
-	 * have an incompatible wider chandef.
-	 */
-	ieee80211_teardown_tdls_peers(sdata);
-
-	mutex_lock(&local->mtx);
-	mutex_lock(&local->chanctx_mtx);
-	conf = rcu_dereference_protected(link->conf->chanctx_conf,
-					 lockdep_is_held(&local->chanctx_mtx));
-	if (!conf) {
-		sdata_info(sdata,
-			   "no channel context assigned to vif?, disconnecting\n");
-		goto drop_connection;
-	}
-
-	chanctx = container_of(conf, struct ieee80211_chanctx, conf);
-
-	if (local->use_chanctx &&
-	    !ieee80211_hw_check(&local->hw, CHANCTX_STA_CSA)) {
-		sdata_info(sdata,
-			   "driver doesn't support chan-switch with channel contexts\n");
-		goto drop_connection;
-	}
-
-	if (drv_pre_channel_switch(sdata, &ch_switch)) {
-		sdata_info(sdata,
-			   "preparing for channel switch failed, disconnecting\n");
-		goto drop_connection;
-	}
-
-	res = ieee80211_link_reserve_chanctx(link, &csa_ie.chandef,
-					     chanctx->mode, false);
-	if (res) {
-		sdata_info(sdata,
-			   "failed to reserve channel context for channel switch, disconnecting (err=%d)\n",
-			   res);
-		goto drop_connection;
-	}
-	mutex_unlock(&local->chanctx_mtx);
-
-	link->conf->csa_active = true;
-	link->csa_chandef = csa_ie.chandef;
-	link->csa_block_tx = csa_ie.mode;
-	link->u.mgd.csa_ignored_same_chan = false;
-	link->u.mgd.beacon_crc_valid = false;
-
-	if (link->csa_block_tx)
-		ieee80211_stop_vif_queues(local, sdata,
-					  IEEE80211_QUEUE_STOP_REASON_CSA);
-	mutex_unlock(&local->mtx);
-
-	cfg80211_ch_switch_started_notify(sdata->dev, &csa_ie.chandef,
-					  link->link_id, csa_ie.count,
-					  csa_ie.mode, 0);
-
-	if (local->ops->channel_switch) {
-		/* use driver's channel switch callback */
-		drv_channel_switch(local, sdata, &ch_switch);
-		return;
-	}
-
-	/* channel switch handled in software */
-	timeout = TU_TO_JIFFIES((max_t(int, csa_ie.count, 1) - 1) *
-				cbss->beacon_interval);
-	wiphy_delayed_work_queue(local->hw.wiphy,
-				 &link->u.mgd.chswitch_work,
-				 timeout);
-	return;
- lock_and_drop_connection:
-	mutex_lock(&local->mtx);
-	mutex_lock(&local->chanctx_mtx);
- drop_connection:
-	/*
-	 * This is just so that the disconnect flow will know that
-	 * we were trying to switch channel and failed. In case the
-	 * mode is 1 (we are not allowed to Tx), we will know not to
-	 * send a deauthentication frame. Those two fields will be
-	 * reset when the disconnection worker runs.
-	 */
-	link->conf->csa_active = true;
-	link->csa_block_tx = csa_ie.mode;
-
-	wiphy_work_queue(sdata->local->hw.wiphy,
-			 &ifmgd->csa_connection_drop_work);
-	mutex_unlock(&local->chanctx_mtx);
-	mutex_unlock(&local->mtx);
-}
-
-static bool
-ieee80211_find_80211h_pwr_constr(struct ieee80211_sub_if_data *sdata,
-				 struct ieee80211_channel *channel,
-				 const u8 *country_ie, u8 country_ie_len,
-				 const u8 *pwr_constr_elem,
-				 int *chan_pwr, int *pwr_reduction)
-{
-	struct ieee80211_country_ie_triplet *triplet;
-	int chan = ieee80211_frequency_to_channel(channel->center_freq);
-	int i, chan_increment;
-	bool have_chan_pwr = false;
-
-	/* Invalid IE */
-	if (country_ie_len % 2 || country_ie_len < IEEE80211_COUNTRY_IE_MIN_LEN)
-		return false;
-
-	triplet = (void *)(country_ie + 3);
-	country_ie_len -= 3;
-
-	switch (channel->band) {
-	default:
-		WARN_ON_ONCE(1);
-		fallthrough;
-	case NL80211_BAND_2GHZ:
-	case NL80211_BAND_60GHZ:
-	case NL80211_BAND_LC:
-		chan_increment = 1;
-		break;
-	case NL80211_BAND_5GHZ:
-		chan_increment = 4;
-		break;
-	case NL80211_BAND_6GHZ:
-		/*
-		 * In the 6 GHz band, the "maximum transmit power level"
-		 * field in the triplets is reserved, and thus will be
-		 * zero and we shouldn't use it to control TX power.
-		 * The actual TX power will be given in the transmit
-		 * power envelope element instead.
-		 */
-		return false;
-	}
-
-	/* find channel */
-	while (country_ie_len >= 3) {
-		u8 first_channel = triplet->chans.first_channel;
-
-		if (first_channel >= IEEE80211_COUNTRY_EXTENSION_ID)
-			goto next;
-
-		for (i = 0; i < triplet->chans.num_channels; i++) {
-			if (first_channel + i * chan_increment == chan) {
-				have_chan_pwr = true;
-				*chan_pwr = triplet->chans.max_power;
-				break;
-			}
-		}
-		if (have_chan_pwr)
-			break;
-
- next:
-		triplet++;
-		country_ie_len -= 3;
-	}
-
-	if (have_chan_pwr && pwr_constr_elem)
-		*pwr_reduction = *pwr_constr_elem;
-	else
-		*pwr_reduction = 0;
-
-	return have_chan_pwr;
-}
-
-static void ieee80211_find_cisco_dtpc(struct ieee80211_sub_if_data *sdata,
-				      struct ieee80211_channel *channel,
-				      const u8 *cisco_dtpc_ie,
-				      int *pwr_level)
-{
-	/* From practical testing, the first data byte of the DTPC element
-	 * seems to contain the requested dBm level, and the CLI on Cisco
-	 * APs clearly state the range is -127 to 127 dBm, which indicates
-	 * a signed byte, although it seemingly never actually goes negative.
-	 * The other byte seems to always be zero.
-	 */
-	*pwr_level = (__s8)cisco_dtpc_ie[4];
-}
-
-static u64 ieee80211_handle_pwr_constr(struct ieee80211_link_data *link,
-				       struct ieee80211_channel *channel,
-				       struct ieee80211_mgmt *mgmt,
-				       const u8 *country_ie, u8 country_ie_len,
-				       const u8 *pwr_constr_ie,
-				       const u8 *cisco_dtpc_ie)
-{
-	struct ieee80211_sub_if_data *sdata = link->sdata;
-	bool has_80211h_pwr = false, has_cisco_pwr = false;
-	int chan_pwr = 0, pwr_reduction_80211h = 0;
-	int pwr_level_cisco, pwr_level_80211h;
-	int new_ap_level;
-	__le16 capab = mgmt->u.probe_resp.capab_info;
-
-	if (ieee80211_is_s1g_beacon(mgmt->frame_control))
-		return 0;	/* TODO */
-
-	if (country_ie &&
-	    (capab & cpu_to_le16(WLAN_CAPABILITY_SPECTRUM_MGMT) ||
-	     capab & cpu_to_le16(WLAN_CAPABILITY_RADIO_MEASURE))) {
-		has_80211h_pwr = ieee80211_find_80211h_pwr_constr(
-			sdata, channel, country_ie, country_ie_len,
-			pwr_constr_ie, &chan_pwr, &pwr_reduction_80211h);
-		pwr_level_80211h =
-			max_t(int, 0, chan_pwr - pwr_reduction_80211h);
-	}
-
-	if (cisco_dtpc_ie) {
-		ieee80211_find_cisco_dtpc(
-			sdata, channel, cisco_dtpc_ie, &pwr_level_cisco);
-		has_cisco_pwr = true;
-	}
-
-	if (!has_80211h_pwr && !has_cisco_pwr)
-		return 0;
-
-	/* If we have both 802.11h and Cisco DTPC, apply both limits
-	 * by picking the smallest of the two power levels advertised.
-	 */
-	if (has_80211h_pwr &&
-	    (!has_cisco_pwr || pwr_level_80211h <= pwr_level_cisco)) {
-		new_ap_level = pwr_level_80211h;
-
-		if (link->ap_power_level == new_ap_level)
-			return 0;
-
-		sdata_dbg(sdata,
-			  "Limiting TX power to %d (%d - %d) dBm as advertised by %pM\n",
-			  pwr_level_80211h, chan_pwr, pwr_reduction_80211h,
-			  link->u.mgd.bssid);
-	} else {  /* has_cisco_pwr is always true here. */
-		new_ap_level = pwr_level_cisco;
-
-		if (link->ap_power_level == new_ap_level)
-			return 0;
-
-		sdata_dbg(sdata,
-			  "Limiting TX power to %d dBm as advertised by %pM\n",
-			  pwr_level_cisco, link->u.mgd.bssid);
-	}
-
-	link->ap_power_level = new_ap_level;
-	if (__ieee80211_recalc_txpower(sdata))
-		return BSS_CHANGED_TXPOWER;
-	return 0;
-}
-
-/* powersave */
-static void ieee80211_enable_ps(struct ieee80211_local *local,
-				struct ieee80211_sub_if_data *sdata)
-{
-	struct ieee80211_conf *conf = &local->hw.conf;
-
-	/*
-	 * If we are scanning right now then the parameters will
-	 * take effect when scan finishes.
-	 */
-	if (local->scanning)
-		return;
-
-	if (conf->dynamic_ps_timeout > 0 &&
-	    !ieee80211_hw_check(&local->hw, SUPPORTS_DYNAMIC_PS)) {
-		mod_timer(&local->dynamic_ps_timer, jiffies +
-			  msecs_to_jiffies(conf->dynamic_ps_timeout));
-	} else {
-		if (ieee80211_hw_check(&local->hw, PS_NULLFUNC_STACK))
-			ieee80211_send_nullfunc(local, sdata, true);
-
-		if (ieee80211_hw_check(&local->hw, PS_NULLFUNC_STACK) &&
-		    ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS))
-			return;
-
-		conf->flags |= IEEE80211_CONF_PS;
-		ieee80211_hw_config(local, IEEE80211_CONF_CHANGE_PS);
-	}
-}
-
-static void ieee80211_change_ps(struct ieee80211_local *local)
-{
-	struct ieee80211_conf *conf = &local->hw.conf;
-
-	if (local->ps_sdata) {
-		ieee80211_enable_ps(local, local->ps_sdata);
-	} else if (conf->flags & IEEE80211_CONF_PS) {
-		conf->flags &= ~IEEE80211_CONF_PS;
-		ieee80211_hw_config(local, IEEE80211_CONF_CHANGE_PS);
-		del_timer_sync(&local->dynamic_ps_timer);
-		cancel_work_sync(&local->dynamic_ps_enable_work);
-	}
-}
-
-static bool ieee80211_powersave_allowed(struct ieee80211_sub_if_data *sdata)
-{
-	struct ieee80211_local *local = sdata->local;
-	struct ieee80211_if_managed *mgd = &sdata->u.mgd;
-	struct sta_info *sta = NULL;
-	bool authorized = false;
-
-	if (!mgd->powersave)
-		return false;
-
-	if (mgd->broken_ap)
-		return false;
-
-	if (!mgd->associated)
-		return false;
-
-	if (mgd->flags & IEEE80211_STA_CONNECTION_POLL)
-		return false;
-
-	if (!(local->hw.wiphy->flags & WIPHY_FLAG_SUPPORTS_MLO) &&
-	    !sdata->deflink.u.mgd.have_beacon)
-		return false;
-
-	rcu_read_lock();
-	sta = sta_info_get(sdata, sdata->vif.cfg.ap_addr);
-	if (sta)
-		authorized = test_sta_flag(sta, WLAN_STA_AUTHORIZED);
-	rcu_read_unlock();
-
-	return authorized;
-}
-
-/* need to hold RTNL or interface lock */
-void ieee80211_recalc_ps(struct ieee80211_local *local)
-{
-	struct ieee80211_sub_if_data *sdata, *found = NULL;
-	int count = 0;
-	int timeout;
-
-	if (!ieee80211_hw_check(&local->hw, SUPPORTS_PS) ||
-	    ieee80211_hw_check(&local->hw, SUPPORTS_DYNAMIC_PS)) {
-		local->ps_sdata = NULL;
-		return;
-	}
-
-	list_for_each_entry(sdata, &local->interfaces, list) {
-		if (!ieee80211_sdata_running(sdata))
-			continue;
-		if (sdata->vif.type == NL80211_IFTYPE_AP) {
-			/* If an AP vif is found, then disable PS
-			 * by setting the count to zero thereby setting
-			 * ps_sdata to NULL.
-			 */
-			count = 0;
-			break;
-		}
-		if (sdata->vif.type != NL80211_IFTYPE_STATION)
-			continue;
-		found = sdata;
-		count++;
-	}
-
-	if (count == 1 && ieee80211_powersave_allowed(found)) {
-		u8 dtimper = found->deflink.u.mgd.dtim_period;
-
-		timeout = local->dynamic_ps_forced_timeout;
-		if (timeout < 0)
-			timeout = 100;
-		local->hw.conf.dynamic_ps_timeout = timeout;
-
-		/* If the TIM IE is invalid, pretend the value is 1 */
-		if (!dtimper)
-			dtimper = 1;
-
-		local->hw.conf.ps_dtim_period = dtimper;
-		local->ps_sdata = found;
-	} else {
-		local->ps_sdata = NULL;
-	}
-
-	ieee80211_change_ps(local);
-}
-
-void ieee80211_recalc_ps_vif(struct ieee80211_sub_if_data *sdata)
-{
-	bool ps_allowed = ieee80211_powersave_allowed(sdata);
-
-	if (sdata->vif.cfg.ps != ps_allowed) {
-		sdata->vif.cfg.ps = ps_allowed;
-		ieee80211_vif_cfg_change_notify(sdata, BSS_CHANGED_PS);
-	}
-}
-
-void ieee80211_dynamic_ps_disable_work(struct work_struct *work)
-{
-	struct ieee80211_local *local =
-		container_of(work, struct ieee80211_local,
-			     dynamic_ps_disable_work);
-
-	if (local->hw.conf.flags & IEEE80211_CONF_PS) {
-		local->hw.conf.flags &= ~IEEE80211_CONF_PS;
-		ieee80211_hw_config(local, IEEE80211_CONF_CHANGE_PS);
-	}
-
-	ieee80211_wake_queues_by_reason(&local->hw,
-					IEEE80211_MAX_QUEUE_MAP,
-					IEEE80211_QUEUE_STOP_REASON_PS,
-					false);
-}
-
-void ieee80211_dynamic_ps_enable_work(struct work_struct *work)
-{
-	struct ieee80211_local *local =
-		container_of(work, struct ieee80211_local,
-			     dynamic_ps_enable_work);
-	struct ieee80211_sub_if_data *sdata = local->ps_sdata;
-	struct ieee80211_if_managed *ifmgd;
-	unsigned long flags;
-	int q;
-
-	/* can only happen when PS was just disabled anyway */
-	if (!sdata)
-		return;
-
-	ifmgd = &sdata->u.mgd;
-
-	if (local->hw.conf.flags & IEEE80211_CONF_PS)
-		return;
-
-	if (local->hw.conf.dynamic_ps_timeout > 0) {
-		/* don't enter PS if TX frames are pending */
-		if (drv_tx_frames_pending(local)) {
-			mod_timer(&local->dynamic_ps_timer, jiffies +
-				  msecs_to_jiffies(
-				  local->hw.conf.dynamic_ps_timeout));
-			return;
-		}
-
-		/*
-		 * transmission can be stopped by others which leads to
-		 * dynamic_ps_timer expiry. Postpone the ps timer if it
-		 * is not the actual idle state.
-		 */
-		spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
-		for (q = 0; q < local->hw.queues; q++) {
-			if (local->queue_stop_reasons[q]) {
-				spin_unlock_irqrestore(&local->queue_stop_reason_lock,
-						       flags);
-				mod_timer(&local->dynamic_ps_timer, jiffies +
-					  msecs_to_jiffies(
-					  local->hw.conf.dynamic_ps_timeout));
-				return;
-			}
-		}
-		spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
-	}
-
-	if (ieee80211_hw_check(&local->hw, PS_NULLFUNC_STACK) &&
-	    !(ifmgd->flags & IEEE80211_STA_NULLFUNC_ACKED)) {
-		if (drv_tx_frames_pending(local)) {
-			mod_timer(&local->dynamic_ps_timer, jiffies +
-				  msecs_to_jiffies(
-				  local->hw.conf.dynamic_ps_timeout));
-		} else {
-			ieee80211_send_nullfunc(local, sdata, true);
-			/* Flush to get the tx status of nullfunc frame */
-			ieee80211_flush_queues(local, sdata, false);
-		}
-	}
-
-	if (!(ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS) &&
-	      ieee80211_hw_check(&local->hw, PS_NULLFUNC_STACK)) ||
-	    (ifmgd->flags & IEEE80211_STA_NULLFUNC_ACKED)) {
-		ifmgd->flags &= ~IEEE80211_STA_NULLFUNC_ACKED;
-		local->hw.conf.flags |= IEEE80211_CONF_PS;
-		ieee80211_hw_config(local, IEEE80211_CONF_CHANGE_PS);
-	}
-}
-
-void ieee80211_dynamic_ps_timer(struct timer_list *t)
-{
-	struct ieee80211_local *local = from_timer(local, t, dynamic_ps_timer);
-
-	ieee80211_queue_work(&local->hw, &local->dynamic_ps_enable_work);
-}
-
-void ieee80211_dfs_cac_timer_work(struct work_struct *work)
-{
-	struct delayed_work *delayed_work = to_delayed_work(work);
-	struct ieee80211_link_data *link =
-		container_of(delayed_work, struct ieee80211_link_data,
-			     dfs_cac_timer_work);
-	struct cfg80211_chan_def chandef = link->conf->chandef;
-	struct ieee80211_sub_if_data *sdata = link->sdata;
-
-	mutex_lock(&sdata->local->mtx);
-	if (sdata->wdev.cac_started) {
-		ieee80211_link_release_channel(link);
-		cfg80211_cac_event(sdata->dev, &chandef,
-				   NL80211_RADAR_CAC_FINISHED,
-				   GFP_KERNEL);
-	}
-	mutex_unlock(&sdata->local->mtx);
-}
-
-static bool
-__ieee80211_sta_handle_tspec_ac_params(struct ieee80211_sub_if_data *sdata)
-{
-	struct ieee80211_local *local = sdata->local;
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-	bool ret = false;
-	int ac;
-
-	if (local->hw.queues < IEEE80211_NUM_ACS)
-		return false;
-
-	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
-		struct ieee80211_sta_tx_tspec *tx_tspec = &ifmgd->tx_tspec[ac];
-		int non_acm_ac;
-		unsigned long now = jiffies;
-
-		if (tx_tspec->action == TX_TSPEC_ACTION_NONE &&
-		    tx_tspec->admitted_time &&
-		    time_after(now, tx_tspec->time_slice_start + HZ)) {
-			tx_tspec->consumed_tx_time = 0;
-			tx_tspec->time_slice_start = now;
-
-			if (tx_tspec->downgraded)
-				tx_tspec->action =
-					TX_TSPEC_ACTION_STOP_DOWNGRADE;
-		}
-
-		switch (tx_tspec->action) {
-		case TX_TSPEC_ACTION_STOP_DOWNGRADE:
-			/* take the original parameters */
-			if (drv_conf_tx(local, &sdata->deflink, ac,
-					&sdata->deflink.tx_conf[ac]))
-				link_err(&sdata->deflink,
-					 "failed to set TX queue parameters for queue %d\n",
-					 ac);
-			tx_tspec->action = TX_TSPEC_ACTION_NONE;
-			tx_tspec->downgraded = false;
-			ret = true;
-			break;
-		case TX_TSPEC_ACTION_DOWNGRADE:
-			if (time_after(now, tx_tspec->time_slice_start + HZ)) {
-				tx_tspec->action = TX_TSPEC_ACTION_NONE;
-				ret = true;
-				break;
-			}
-			/* downgrade next lower non-ACM AC */
-			for (non_acm_ac = ac + 1;
-			     non_acm_ac < IEEE80211_NUM_ACS;
-			     non_acm_ac++)
-				if (!(sdata->wmm_acm & BIT(7 - 2 * non_acm_ac)))
-					break;
-			/* Usually the loop will result in using BK even if it
-			 * requires admission control, but such a configuration
-			 * makes no sense and we have to transmit somehow - the
-			 * AC selection does the same thing.
-			 * If we started out trying to downgrade from BK, then
-			 * the extra condition here might be needed.
-			 */
-			if (non_acm_ac >= IEEE80211_NUM_ACS)
-				non_acm_ac = IEEE80211_AC_BK;
-			if (drv_conf_tx(local, &sdata->deflink, ac,
-					&sdata->deflink.tx_conf[non_acm_ac]))
-				link_err(&sdata->deflink,
-					 "failed to set TX queue parameters for queue %d\n",
-					 ac);
-			tx_tspec->action = TX_TSPEC_ACTION_NONE;
-			ret = true;
-			schedule_delayed_work(&ifmgd->tx_tspec_wk,
-				tx_tspec->time_slice_start + HZ - now + 1);
-			break;
-		case TX_TSPEC_ACTION_NONE:
-			/* nothing now */
-			break;
-		}
-	}
-
-	return ret;
-}
-
-void ieee80211_sta_handle_tspec_ac_params(struct ieee80211_sub_if_data *sdata)
-{
-	if (__ieee80211_sta_handle_tspec_ac_params(sdata))
-		ieee80211_link_info_change_notify(sdata, &sdata->deflink,
-						  BSS_CHANGED_QOS);
-}
-
-static void ieee80211_sta_handle_tspec_ac_params_wk(struct work_struct *work)
-{
-	struct ieee80211_sub_if_data *sdata;
-
-	sdata = container_of(work, struct ieee80211_sub_if_data,
-			     u.mgd.tx_tspec_wk.work);
-	ieee80211_sta_handle_tspec_ac_params(sdata);
-}
-
-void ieee80211_mgd_set_link_qos_params(struct ieee80211_link_data *link)
-{
-	struct ieee80211_sub_if_data *sdata = link->sdata;
-	struct ieee80211_local *local = sdata->local;
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-	struct ieee80211_tx_queue_params *params = link->tx_conf;
-	u8 ac;
-
-	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
-		mlme_dbg(sdata,
-			 "WMM AC=%d acm=%d aifs=%d cWmin=%d cWmax=%d txop=%d uapsd=%d, downgraded=%d\n",
-			 ac, params[ac].acm,
-			 params[ac].aifs, params[ac].cw_min, params[ac].cw_max,
-			 params[ac].txop, params[ac].uapsd,
-			 ifmgd->tx_tspec[ac].downgraded);
-		if (!ifmgd->tx_tspec[ac].downgraded &&
-		    drv_conf_tx(local, link, ac, &params[ac]))
-			link_err(link,
-				 "failed to set TX queue parameters for AC %d\n",
-				 ac);
-	}
-}
-
-/* MLME */
-static bool
-ieee80211_sta_wmm_params(struct ieee80211_local *local,
-			 struct ieee80211_link_data *link,
-			 const u8 *wmm_param, size_t wmm_param_len,
-			 const struct ieee80211_mu_edca_param_set *mu_edca)
-{
-	struct ieee80211_sub_if_data *sdata = link->sdata;
-	struct ieee80211_tx_queue_params params[IEEE80211_NUM_ACS];
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-	size_t left;
-	int count, mu_edca_count, ac;
-	const u8 *pos;
-	u8 uapsd_queues = 0;
-
-	if (!local->ops->conf_tx)
-		return false;
-
-	if (local->hw.queues < IEEE80211_NUM_ACS)
-		return false;
-
-	if (!wmm_param)
-		return false;
-
-	if (wmm_param_len < 8 || wmm_param[5] /* version */ != 1)
-		return false;
-
-	if (ifmgd->flags & IEEE80211_STA_UAPSD_ENABLED)
-		uapsd_queues = ifmgd->uapsd_queues;
-
-	count = wmm_param[6] & 0x0f;
-	/* -1 is the initial value of ifmgd->mu_edca_last_param_set.
-	 * if mu_edca was preset before and now it disappeared tell
-	 * the driver about it.
-	 */
-	mu_edca_count = mu_edca ? mu_edca->mu_qos_info & 0x0f : -1;
-	if (count == link->u.mgd.wmm_last_param_set &&
-	    mu_edca_count == link->u.mgd.mu_edca_last_param_set)
-		return false;
-	link->u.mgd.wmm_last_param_set = count;
-	link->u.mgd.mu_edca_last_param_set = mu_edca_count;
-
-	pos = wmm_param + 8;
-	left = wmm_param_len - 8;
-
-	memset(&params, 0, sizeof(params));
-
-	sdata->wmm_acm = 0;
-	for (; left >= 4; left -= 4, pos += 4) {
-		int aci = (pos[0] >> 5) & 0x03;
-		int acm = (pos[0] >> 4) & 0x01;
-		bool uapsd = false;
-
-		switch (aci) {
-		case 1: /* AC_BK */
-			ac = IEEE80211_AC_BK;
-			if (acm)
-				sdata->wmm_acm |= BIT(1) | BIT(2); /* BK/- */
-			if (uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_BK)
-				uapsd = true;
-			params[ac].mu_edca = !!mu_edca;
-			if (mu_edca)
-				params[ac].mu_edca_param_rec = mu_edca->ac_bk;
-			break;
-		case 2: /* AC_VI */
-			ac = IEEE80211_AC_VI;
-			if (acm)
-				sdata->wmm_acm |= BIT(4) | BIT(5); /* CL/VI */
-			if (uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_VI)
-				uapsd = true;
-			params[ac].mu_edca = !!mu_edca;
-			if (mu_edca)
-				params[ac].mu_edca_param_rec = mu_edca->ac_vi;
-			break;
-		case 3: /* AC_VO */
-			ac = IEEE80211_AC_VO;
-			if (acm)
-				sdata->wmm_acm |= BIT(6) | BIT(7); /* VO/NC */
-			if (uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_VO)
-				uapsd = true;
-			params[ac].mu_edca = !!mu_edca;
-			if (mu_edca)
-				params[ac].mu_edca_param_rec = mu_edca->ac_vo;
-			break;
-		case 0: /* AC_BE */
-		default:
-			ac = IEEE80211_AC_BE;
-			if (acm)
-				sdata->wmm_acm |= BIT(0) | BIT(3); /* BE/EE */
-			if (uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_BE)
-				uapsd = true;
-			params[ac].mu_edca = !!mu_edca;
-			if (mu_edca)
-				params[ac].mu_edca_param_rec = mu_edca->ac_be;
-			break;
-		}
-
-		params[ac].aifs = pos[0] & 0x0f;
-
-		if (params[ac].aifs < 2) {
-			link_info(link,
-				  "AP has invalid WMM params (AIFSN=%d for ACI %d), will use 2\n",
-				  params[ac].aifs, aci);
-			params[ac].aifs = 2;
-		}
-		params[ac].cw_max = ecw2cw((pos[1] & 0xf0) >> 4);
-		params[ac].cw_min = ecw2cw(pos[1] & 0x0f);
-		params[ac].txop = get_unaligned_le16(pos + 2);
-		params[ac].acm = acm;
-		params[ac].uapsd = uapsd;
-
-		if (params[ac].cw_min == 0 ||
-		    params[ac].cw_min > params[ac].cw_max) {
-			link_info(link,
-				  "AP has invalid WMM params (CWmin/max=%d/%d for ACI %d), using defaults\n",
-				  params[ac].cw_min, params[ac].cw_max, aci);
-			return false;
-		}
-		ieee80211_regulatory_limit_wmm_params(sdata, &params[ac], ac);
-	}
-
-	/* WMM specification requires all 4 ACIs. */
-	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
-		if (params[ac].cw_min == 0) {
-			link_info(link,
-				  "AP has invalid WMM params (missing AC %d), using defaults\n",
-				  ac);
-			return false;
-		}
-	}
-
-	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++)
-		link->tx_conf[ac] = params[ac];
-
-	ieee80211_mgd_set_link_qos_params(link);
-
-	/* enable WMM or activate new settings */
-	link->conf->qos = true;
-	return true;
-}
-
-static void __ieee80211_stop_poll(struct ieee80211_sub_if_data *sdata)
-{
-	lockdep_assert_held(&sdata->local->mtx);
-
-	sdata->u.mgd.flags &= ~IEEE80211_STA_CONNECTION_POLL;
-	ieee80211_run_deferred_scan(sdata->local);
-}
-
-static void ieee80211_stop_poll(struct ieee80211_sub_if_data *sdata)
-{
-	mutex_lock(&sdata->local->mtx);
-	__ieee80211_stop_poll(sdata);
-	mutex_unlock(&sdata->local->mtx);
-}
-
-static u64 ieee80211_handle_bss_capability(struct ieee80211_link_data *link,
-					   u16 capab, bool erp_valid, u8 erp)
-{
-	struct ieee80211_bss_conf *bss_conf = link->conf;
-	struct ieee80211_supported_band *sband;
-	u64 changed = 0;
-	bool use_protection;
-	bool use_short_preamble;
-	bool use_short_slot;
-
-	sband = ieee80211_get_link_sband(link);
-	if (!sband)
-		return changed;
-
-	if (erp_valid) {
-		use_protection = (erp & WLAN_ERP_USE_PROTECTION) != 0;
-		use_short_preamble = (erp & WLAN_ERP_BARKER_PREAMBLE) == 0;
-	} else {
-		use_protection = false;
-		use_short_preamble = !!(capab & WLAN_CAPABILITY_SHORT_PREAMBLE);
-	}
-
-	use_short_slot = !!(capab & WLAN_CAPABILITY_SHORT_SLOT_TIME);
-	if (sband->band == NL80211_BAND_5GHZ ||
-	    sband->band == NL80211_BAND_6GHZ)
-		use_short_slot = true;
-
-	if (use_protection != bss_conf->use_cts_prot) {
-		bss_conf->use_cts_prot = use_protection;
-		changed |= BSS_CHANGED_ERP_CTS_PROT;
-	}
-
-	if (use_short_preamble != bss_conf->use_short_preamble) {
-		bss_conf->use_short_preamble = use_short_preamble;
-		changed |= BSS_CHANGED_ERP_PREAMBLE;
-	}
-
-	if (use_short_slot != bss_conf->use_short_slot) {
-		bss_conf->use_short_slot = use_short_slot;
-		changed |= BSS_CHANGED_ERP_SLOT;
-	}
-
-	return changed;
-}
-
-static u64 ieee80211_link_set_associated(struct ieee80211_link_data *link,
-					 struct cfg80211_bss *cbss)
-{
-	struct ieee80211_sub_if_data *sdata = link->sdata;
-	struct ieee80211_bss_conf *bss_conf = link->conf;
-	struct ieee80211_bss *bss = (void *)cbss->priv;
-	u64 changed = BSS_CHANGED_QOS;
-
-	/* not really used in MLO */
-	sdata->u.mgd.beacon_timeout =
-		usecs_to_jiffies(ieee80211_tu_to_usec(beacon_loss_count *
-						      bss_conf->beacon_int));
-
-	changed |= ieee80211_handle_bss_capability(link,
-						   bss_conf->assoc_capability,
-						   bss->has_erp_value,
-						   bss->erp_value);
-
-	ieee80211_check_rate_mask(link);
-
-	link->u.mgd.bss = cbss;
-	memcpy(link->u.mgd.bssid, cbss->bssid, ETH_ALEN);
-
-	if (sdata->vif.p2p ||
-	    sdata->vif.driver_flags & IEEE80211_VIF_GET_NOA_UPDATE) {
-		const struct cfg80211_bss_ies *ies;
-
-		rcu_read_lock();
-		ies = rcu_dereference(cbss->ies);
-		if (ies) {
-			int ret;
-
-			ret = cfg80211_get_p2p_attr(
-					ies->data, ies->len,
-					IEEE80211_P2P_ATTR_ABSENCE_NOTICE,
-					(u8 *) &bss_conf->p2p_noa_attr,
-					sizeof(bss_conf->p2p_noa_attr));
-			if (ret >= 2) {
-				link->u.mgd.p2p_noa_index =
-					bss_conf->p2p_noa_attr.index;
-				changed |= BSS_CHANGED_P2P_PS;
-			}
-		}
-		rcu_read_unlock();
-	}
-
-	if (link->u.mgd.have_beacon) {
-		bss_conf->beacon_rate = bss->beacon_rate;
-		changed |= BSS_CHANGED_BEACON_INFO;
-	} else {
-		bss_conf->beacon_rate = NULL;
-	}
-
-	/* Tell the driver to monitor connection quality (if supported) */
-	if (sdata->vif.driver_flags & IEEE80211_VIF_SUPPORTS_CQM_RSSI &&
-	    bss_conf->cqm_rssi_thold)
-		changed |= BSS_CHANGED_CQM;
-
-	return changed;
-}
-
-static void ieee80211_set_associated(struct ieee80211_sub_if_data *sdata,
-				     struct ieee80211_mgd_assoc_data *assoc_data,
-				     u64 changed[IEEE80211_MLD_MAX_NUM_LINKS])
-{
-	struct ieee80211_local *local = sdata->local;
-	struct ieee80211_vif_cfg *vif_cfg = &sdata->vif.cfg;
-	u64 vif_changed = BSS_CHANGED_ASSOC;
-	unsigned int link_id;
-
-	sdata->u.mgd.associated = true;
-
-	for (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {
-		struct cfg80211_bss *cbss = assoc_data->link[link_id].bss;
-		struct ieee80211_link_data *link;
-
-		if (!cbss ||
-		    assoc_data->link[link_id].status != WLAN_STATUS_SUCCESS)
-			continue;
-
-		if (ieee80211_vif_is_mld(&sdata->vif) &&
-		    !(ieee80211_vif_usable_links(&sdata->vif) & BIT(link_id)))
-			continue;
-
-		link = sdata_dereference(sdata->link[link_id], sdata);
-		if (WARN_ON(!link))
-			return;
-
-		changed[link_id] |= ieee80211_link_set_associated(link, cbss);
-	}
-
-	/* just to be sure */
-	ieee80211_stop_poll(sdata);
-
-	ieee80211_led_assoc(local, 1);
-
-	vif_cfg->assoc = 1;
-
-	/* Enable ARP filtering */
-	if (vif_cfg->arp_addr_cnt)
-		vif_changed |= BSS_CHANGED_ARP_FILTER;
-
-	if (ieee80211_vif_is_mld(&sdata->vif)) {
-		for (link_id = 0;
-		     link_id < IEEE80211_MLD_MAX_NUM_LINKS;
-		     link_id++) {
-			struct ieee80211_link_data *link;
-			struct cfg80211_bss *cbss = assoc_data->link[link_id].bss;
-
-			if (!cbss ||
-			    !(BIT(link_id) &
-			      ieee80211_vif_usable_links(&sdata->vif)) ||
-			    assoc_data->link[link_id].status != WLAN_STATUS_SUCCESS)
-				continue;
-
-			link = sdata_dereference(sdata->link[link_id], sdata);
-			if (WARN_ON(!link))
-				return;
-
-			ieee80211_link_info_change_notify(sdata, link,
-							  changed[link_id]);
-
-			ieee80211_recalc_smps(sdata, link);
-		}
-
-		ieee80211_vif_cfg_change_notify(sdata, vif_changed);
-	} else {
-		ieee80211_bss_info_change_notify(sdata,
-						 vif_changed | changed[0]);
-	}
-
-	mutex_lock(&local->iflist_mtx);
-	ieee80211_recalc_ps(local);
-	mutex_unlock(&local->iflist_mtx);
-
-	/* leave this here to not change ordering in non-MLO cases */
-	if (!ieee80211_vif_is_mld(&sdata->vif))
-		ieee80211_recalc_smps(sdata, &sdata->deflink);
-	ieee80211_recalc_ps_vif(sdata);
-
-	netif_carrier_on(sdata->dev);
-}
-
-static void ieee80211_set_disassoc(struct ieee80211_sub_if_data *sdata,
-				   u16 stype, u16 reason, bool tx,
-				   u8 *frame_buf)
-{
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-	struct ieee80211_local *local = sdata->local;
-	unsigned int link_id;
-	u64 changed = 0;
-	struct ieee80211_prep_tx_info info = {
-		.subtype = stype,
-	};
-
-	sdata_assert_lock(sdata);
-
-	if (WARN_ON_ONCE(tx && !frame_buf))
-		return;
-
-	if (WARN_ON(!ifmgd->associated))
-		return;
-
-	ieee80211_stop_poll(sdata);
-
-	ifmgd->associated = false;
-
-	/* other links will be destroyed */
-	sdata->deflink.u.mgd.bss = NULL;
-
-	netif_carrier_off(sdata->dev);
-
-	/*
-	 * if we want to get out of ps before disassoc (why?) we have
-	 * to do it before sending disassoc, as otherwise the null-packet
-	 * won't be valid.
-	 */
-	if (local->hw.conf.flags & IEEE80211_CONF_PS) {
-		local->hw.conf.flags &= ~IEEE80211_CONF_PS;
-		ieee80211_hw_config(local, IEEE80211_CONF_CHANGE_PS);
-	}
-	local->ps_sdata = NULL;
-
-	/* disable per-vif ps */
-	ieee80211_recalc_ps_vif(sdata);
-
-	/* make sure ongoing transmission finishes */
-	synchronize_net();
-
-	/*
-	 * drop any frame before deauth/disassoc, this can be data or
-	 * management frame. Since we are disconnecting, we should not
-	 * insist sending these frames which can take time and delay
-	 * the disconnection and possible the roaming.
-	 */
-	if (tx)
-		ieee80211_flush_queues(local, sdata, true);
-
-	/* deauthenticate/disassociate now */
-	if (tx || frame_buf) {
-		/*
-		 * In multi channel scenarios guarantee that the virtual
-		 * interface is granted immediate airtime to transmit the
-		 * deauthentication frame by calling mgd_prepare_tx, if the
-		 * driver requested so.
-		 */
-		if (ieee80211_hw_check(&local->hw, DEAUTH_NEED_MGD_TX_PREP) &&
-		    !sdata->deflink.u.mgd.have_beacon) {
-			drv_mgd_prepare_tx(sdata->local, sdata, &info);
-		}
-
-		ieee80211_send_deauth_disassoc(sdata, sdata->vif.cfg.ap_addr,
-					       sdata->vif.cfg.ap_addr, stype,
-					       reason, tx, frame_buf);
-	}
-
-	/* flush out frame - make sure the deauth was actually sent */
-	if (tx)
-		ieee80211_flush_queues(local, sdata, false);
-
-	drv_mgd_complete_tx(sdata->local, sdata, &info);
-
-	/* clear AP addr only after building the needed mgmt frames */
-	eth_zero_addr(sdata->deflink.u.mgd.bssid);
-	eth_zero_addr(sdata->vif.cfg.ap_addr);
-
-	sdata->vif.cfg.ssid_len = 0;
-
-	/* remove AP and TDLS peers */
-	sta_info_flush(sdata);
-
-	/* finally reset all BSS / config parameters */
-	if (!ieee80211_vif_is_mld(&sdata->vif))
-		changed |= ieee80211_reset_erp_info(sdata);
-
-	ieee80211_led_assoc(local, 0);
-	changed |= BSS_CHANGED_ASSOC;
-	sdata->vif.cfg.assoc = false;
-
-	sdata->deflink.u.mgd.p2p_noa_index = -1;
-	memset(&sdata->vif.bss_conf.p2p_noa_attr, 0,
-	       sizeof(sdata->vif.bss_conf.p2p_noa_attr));
-
-	/* on the next assoc, re-program HT/VHT parameters */
-	memset(&ifmgd->ht_capa, 0, sizeof(ifmgd->ht_capa));
-	memset(&ifmgd->ht_capa_mask, 0, sizeof(ifmgd->ht_capa_mask));
-	memset(&ifmgd->vht_capa, 0, sizeof(ifmgd->vht_capa));
-	memset(&ifmgd->vht_capa_mask, 0, sizeof(ifmgd->vht_capa_mask));
-
-	/*
-	 * reset MU-MIMO ownership and group data in default link,
-	 * if used, other links are destroyed
-	 */
-	memset(sdata->vif.bss_conf.mu_group.membership, 0,
-	       sizeof(sdata->vif.bss_conf.mu_group.membership));
-	memset(sdata->vif.bss_conf.mu_group.position, 0,
-	       sizeof(sdata->vif.bss_conf.mu_group.position));
-	if (!ieee80211_vif_is_mld(&sdata->vif))
-		changed |= BSS_CHANGED_MU_GROUPS;
-	sdata->vif.bss_conf.mu_mimo_owner = false;
-
-	sdata->deflink.ap_power_level = IEEE80211_UNSET_POWER_LEVEL;
-
-	del_timer_sync(&local->dynamic_ps_timer);
-	cancel_work_sync(&local->dynamic_ps_enable_work);
-
-	/* Disable ARP filtering */
-	if (sdata->vif.cfg.arp_addr_cnt)
-		changed |= BSS_CHANGED_ARP_FILTER;
-
-	sdata->vif.bss_conf.qos = false;
-	if (!ieee80211_vif_is_mld(&sdata->vif)) {
-		changed |= BSS_CHANGED_QOS;
-		/* The BSSID (not really interesting) and HT changed */
-		changed |= BSS_CHANGED_BSSID | BSS_CHANGED_HT;
-		ieee80211_bss_info_change_notify(sdata, changed);
-	} else {
-		ieee80211_vif_cfg_change_notify(sdata, changed);
-	}
-
-	/* disassociated - set to defaults now */
-	ieee80211_set_wmm_default(&sdata->deflink, false, false);
-
-	del_timer_sync(&sdata->u.mgd.conn_mon_timer);
-	del_timer_sync(&sdata->u.mgd.bcn_mon_timer);
-	del_timer_sync(&sdata->u.mgd.timer);
-
-	sdata->vif.bss_conf.dtim_period = 0;
-	sdata->vif.bss_conf.beacon_rate = NULL;
-
-	sdata->deflink.u.mgd.have_beacon = false;
-	sdata->deflink.u.mgd.tracking_signal_avg = false;
-	sdata->deflink.u.mgd.disable_wmm_tracking = false;
-
-	ifmgd->flags = 0;
-	sdata->deflink.u.mgd.conn_flags = 0;
-	mutex_lock(&local->mtx);
-
-	for (link_id = 0; link_id < ARRAY_SIZE(sdata->link); link_id++) {
-		struct ieee80211_link_data *link;
-
-		link = sdata_dereference(sdata->link[link_id], sdata);
-		if (!link)
-			continue;
-		ieee80211_link_release_channel(link);
-	}
-
-	sdata->vif.bss_conf.csa_active = false;
-	sdata->deflink.u.mgd.csa_waiting_bcn = false;
-	sdata->deflink.u.mgd.csa_ignored_same_chan = false;
-	if (sdata->deflink.csa_block_tx) {
-		ieee80211_wake_vif_queues(local, sdata,
-					  IEEE80211_QUEUE_STOP_REASON_CSA);
-		sdata->deflink.csa_block_tx = false;
-	}
-	mutex_unlock(&local->mtx);
-
-	/* existing TX TSPEC sessions no longer exist */
-	memset(ifmgd->tx_tspec, 0, sizeof(ifmgd->tx_tspec));
-	cancel_delayed_work_sync(&ifmgd->tx_tspec_wk);
-
-	sdata->vif.bss_conf.pwr_reduction = 0;
-	sdata->vif.bss_conf.tx_pwr_env_num = 0;
-	memset(sdata->vif.bss_conf.tx_pwr_env, 0,
-	       sizeof(sdata->vif.bss_conf.tx_pwr_env));
-
-	ieee80211_vif_set_links(sdata, 0, 0);
-}
-
-static void ieee80211_reset_ap_probe(struct ieee80211_sub_if_data *sdata)
-{
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-	struct ieee80211_local *local = sdata->local;
-
-	mutex_lock(&local->mtx);
-	if (!(ifmgd->flags & IEEE80211_STA_CONNECTION_POLL))
-		goto out;
-
-	__ieee80211_stop_poll(sdata);
-
-	mutex_lock(&local->iflist_mtx);
-	ieee80211_recalc_ps(local);
-	mutex_unlock(&local->iflist_mtx);
-
-	if (ieee80211_hw_check(&sdata->local->hw, CONNECTION_MONITOR))
-		goto out;
-
-	/*
-	 * We've received a probe response, but are not sure whether
-	 * we have or will be receiving any beacons or data, so let's
-	 * schedule the timers again, just in case.
-	 */
-	ieee80211_sta_reset_beacon_monitor(sdata);
-
-	mod_timer(&ifmgd->conn_mon_timer,
-		  round_jiffies_up(jiffies +
-				   IEEE80211_CONNECTION_IDLE_TIME));
-out:
-	mutex_unlock(&local->mtx);
-}
-
-static void ieee80211_sta_tx_wmm_ac_notify(struct ieee80211_sub_if_data *sdata,
-					   struct ieee80211_hdr *hdr,
-					   u16 tx_time)
-{
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-	u16 tid;
-	int ac;
-	struct ieee80211_sta_tx_tspec *tx_tspec;
-	unsigned long now = jiffies;
-
-	if (!ieee80211_is_data_qos(hdr->frame_control))
-		return;
-
-	tid = ieee80211_get_tid(hdr);
-	ac = ieee80211_ac_from_tid(tid);
-	tx_tspec = &ifmgd->tx_tspec[ac];
-
-	if (likely(!tx_tspec->admitted_time))
-		return;
-
-	if (time_after(now, tx_tspec->time_slice_start + HZ)) {
-		tx_tspec->consumed_tx_time = 0;
-		tx_tspec->time_slice_start = now;
-
-		if (tx_tspec->downgraded) {
-			tx_tspec->action = TX_TSPEC_ACTION_STOP_DOWNGRADE;
-			schedule_delayed_work(&ifmgd->tx_tspec_wk, 0);
-		}
-	}
-
-	if (tx_tspec->downgraded)
-		return;
-
-	tx_tspec->consumed_tx_time += tx_time;
-
-	if (tx_tspec->consumed_tx_time >= tx_tspec->admitted_time) {
-		tx_tspec->downgraded = true;
-		tx_tspec->action = TX_TSPEC_ACTION_DOWNGRADE;
-		schedule_delayed_work(&ifmgd->tx_tspec_wk, 0);
-	}
-}
-
-void ieee80211_sta_tx_notify(struct ieee80211_sub_if_data *sdata,
-			     struct ieee80211_hdr *hdr, bool ack, u16 tx_time)
-{
-	ieee80211_sta_tx_wmm_ac_notify(sdata, hdr, tx_time);
-
-	if (!ieee80211_is_any_nullfunc(hdr->frame_control) ||
-	    !sdata->u.mgd.probe_send_count)
-		return;
-
-	if (ack)
-		sdata->u.mgd.probe_send_count = 0;
-	else
-		sdata->u.mgd.nullfunc_failed = true;
-	wiphy_work_queue(sdata->local->hw.wiphy, &sdata->work);
-}
-
-static void ieee80211_mlme_send_probe_req(struct ieee80211_sub_if_data *sdata,
-					  const u8 *src, const u8 *dst,
-					  const u8 *ssid, size_t ssid_len,
-					  struct ieee80211_channel *channel)
-{
-	struct sk_buff *skb;
-
-	skb = ieee80211_build_probe_req(sdata, src, dst, (u32)-1, channel,
-					ssid, ssid_len, NULL, 0,
-					IEEE80211_PROBE_FLAG_DIRECTED);
-	if (skb)
-		ieee80211_tx_skb(sdata, skb);
-}
-
-static void ieee80211_mgd_probe_ap_send(struct ieee80211_sub_if_data *sdata)
-{
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-	u8 *dst = sdata->vif.cfg.ap_addr;
-	u8 unicast_limit = max(1, max_probe_tries - 3);
-	struct sta_info *sta;
-
-	if (WARN_ON(ieee80211_vif_is_mld(&sdata->vif)))
-		return;
-
-	/*
-	 * Try sending broadcast probe requests for the last three
-	 * probe requests after the first ones failed since some
-	 * buggy APs only support broadcast probe requests.
-	 */
-	if (ifmgd->probe_send_count >= unicast_limit)
-		dst = NULL;
-
-	/*
-	 * When the hardware reports an accurate Tx ACK status, it's
-	 * better to send a nullfunc frame instead of a probe request,
-	 * as it will kick us off the AP quickly if we aren't associated
-	 * anymore. The timeout will be reset if the frame is ACKed by
-	 * the AP.
-	 */
-	ifmgd->probe_send_count++;
-
-	if (dst) {
-		mutex_lock(&sdata->local->sta_mtx);
-		sta = sta_info_get(sdata, dst);
-		if (!WARN_ON(!sta))
-			ieee80211_check_fast_rx(sta);
-		mutex_unlock(&sdata->local->sta_mtx);
-	}
-
-	if (ieee80211_hw_check(&sdata->local->hw, REPORTS_TX_ACK_STATUS)) {
-		ifmgd->nullfunc_failed = false;
-		ieee80211_send_nullfunc(sdata->local, sdata, false);
-	} else {
-		ieee80211_mlme_send_probe_req(sdata, sdata->vif.addr, dst,
-					      sdata->vif.cfg.ssid,
-					      sdata->vif.cfg.ssid_len,
-					      sdata->deflink.u.mgd.bss->channel);
-	}
-
-	ifmgd->probe_timeout = jiffies + msecs_to_jiffies(probe_wait_ms);
-	run_again(sdata, ifmgd->probe_timeout);
-}
-
-static void ieee80211_mgd_probe_ap(struct ieee80211_sub_if_data *sdata,
-				   bool beacon)
-{
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-	bool already = false;
-
-	if (WARN_ON_ONCE(ieee80211_vif_is_mld(&sdata->vif)))
-		return;
-
-	if (!ieee80211_sdata_running(sdata))
-		return;
-
-	sdata_lock(sdata);
-
-	if (!ifmgd->associated)
-		goto out;
-
-	mutex_lock(&sdata->local->mtx);
-
-	if (sdata->local->tmp_channel || sdata->local->scanning) {
-		mutex_unlock(&sdata->local->mtx);
-		goto out;
-	}
-
-	if (sdata->local->suspending) {
-		/* reschedule after resume */
-		mutex_unlock(&sdata->local->mtx);
-		ieee80211_reset_ap_probe(sdata);
-		goto out;
-	}
-
-	if (beacon) {
-		mlme_dbg_ratelimited(sdata,
-				     "detected beacon loss from AP (missed %d beacons) - probing\n",
-				     beacon_loss_count);
-
-		ieee80211_cqm_beacon_loss_notify(&sdata->vif, GFP_KERNEL);
-	}
-
-	/*
-	 * The driver/our work has already reported this event or the
-	 * connection monitoring has kicked in and we have already sent
-	 * a probe request. Or maybe the AP died and the driver keeps
-	 * reporting until we disassociate...
-	 *
-	 * In either case we have to ignore the current call to this
-	 * function (except for setting the correct probe reason bit)
-	 * because otherwise we would reset the timer every time and
-	 * never check whether we received a probe response!
-	 */
-	if (ifmgd->flags & IEEE80211_STA_CONNECTION_POLL)
-		already = true;
-
-	ifmgd->flags |= IEEE80211_STA_CONNECTION_POLL;
-
-	mutex_unlock(&sdata->local->mtx);
-
-	if (already)
-		goto out;
-
-	mutex_lock(&sdata->local->iflist_mtx);
-	ieee80211_recalc_ps(sdata->local);
-	mutex_unlock(&sdata->local->iflist_mtx);
-
-	ifmgd->probe_send_count = 0;
-	ieee80211_mgd_probe_ap_send(sdata);
- out:
-	sdata_unlock(sdata);
-}
-
-struct sk_buff *ieee80211_ap_probereq_get(struct ieee80211_hw *hw,
-					  struct ieee80211_vif *vif)
-{
-	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-	struct cfg80211_bss *cbss;
-	struct sk_buff *skb;
-	const struct element *ssid;
-	int ssid_len;
-
-	if (WARN_ON(sdata->vif.type != NL80211_IFTYPE_STATION ||
-		    ieee80211_vif_is_mld(&sdata->vif)))
-		return NULL;
-
-	sdata_assert_lock(sdata);
-
-	if (ifmgd->associated)
-		cbss = sdata->deflink.u.mgd.bss;
-	else if (ifmgd->auth_data)
-		cbss = ifmgd->auth_data->bss;
-	else if (ifmgd->assoc_data && ifmgd->assoc_data->link[0].bss)
-		cbss = ifmgd->assoc_data->link[0].bss;
-	else
-		return NULL;
-
-	rcu_read_lock();
-	ssid = ieee80211_bss_get_elem(cbss, WLAN_EID_SSID);
-	if (WARN_ONCE(!ssid || ssid->datalen > IEEE80211_MAX_SSID_LEN,
-		      "invalid SSID element (len=%d)",
-		      ssid ? ssid->datalen : -1))
-		ssid_len = 0;
-	else
-		ssid_len = ssid->datalen;
-
-	skb = ieee80211_build_probe_req(sdata, sdata->vif.addr, cbss->bssid,
-					(u32) -1, cbss->channel,
-					ssid->data, ssid_len,
-					NULL, 0, IEEE80211_PROBE_FLAG_DIRECTED);
-	rcu_read_unlock();
-
-	return skb;
-}
-EXPORT_SYMBOL(ieee80211_ap_probereq_get);
-
-static void ieee80211_report_disconnect(struct ieee80211_sub_if_data *sdata,
-					const u8 *buf, size_t len, bool tx,
-					u16 reason, bool reconnect)
-{
-	struct ieee80211_event event = {
-		.type = MLME_EVENT,
-		.u.mlme.data = tx ? DEAUTH_TX_EVENT : DEAUTH_RX_EVENT,
-		.u.mlme.reason = reason,
-	};
-
-	if (tx)
-		cfg80211_tx_mlme_mgmt(sdata->dev, buf, len, reconnect);
-	else
-		cfg80211_rx_mlme_mgmt(sdata->dev, buf, len);
-
-	drv_event_callback(sdata->local, sdata, &event);
-}
-
-static void ___ieee80211_disconnect(struct ieee80211_sub_if_data *sdata)
-{
-	struct ieee80211_local *local = sdata->local;
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-	u8 frame_buf[IEEE80211_DEAUTH_FRAME_LEN];
-	bool tx;
-
-	if (!ifmgd->associated)
-		return;
-
-	/* in MLO assume we have a link where we can TX the frame */
-	tx = ieee80211_vif_is_mld(&sdata->vif) ||
-		!sdata->deflink.csa_block_tx;
-
-	if (!ifmgd->driver_disconnect) {
-		unsigned int link_id;
-
-		/*
-		 * AP is probably out of range (or not reachable for another
-		 * reason) so remove the bss structs for that AP. In the case
-		 * of multi-link, it's not clear that all of them really are
-		 * out of range, but if they weren't the driver likely would
-		 * have switched to just have a single link active?
-		 */
-		for (link_id = 0;
-		     link_id < ARRAY_SIZE(sdata->link);
-		     link_id++) {
-			struct ieee80211_link_data *link;
-
-			link = sdata_dereference(sdata->link[link_id], sdata);
-			if (!link)
-				continue;
-			cfg80211_unlink_bss(local->hw.wiphy, link->u.mgd.bss);
-			link->u.mgd.bss = NULL;
-		}
-	}
-
-	ieee80211_set_disassoc(sdata, IEEE80211_STYPE_DEAUTH,
-			       ifmgd->driver_disconnect ?
-					WLAN_REASON_DEAUTH_LEAVING :
-					WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY,
-			       tx, frame_buf);
-	mutex_lock(&local->mtx);
-	/* the other links will be destroyed */
-	sdata->vif.bss_conf.csa_active = false;
-	sdata->deflink.u.mgd.csa_waiting_bcn = false;
-	if (sdata->deflink.csa_block_tx) {
-		ieee80211_wake_vif_queues(local, sdata,
-					  IEEE80211_QUEUE_STOP_REASON_CSA);
-		sdata->deflink.csa_block_tx = false;
-	}
-	mutex_unlock(&local->mtx);
-
-	ieee80211_report_disconnect(sdata, frame_buf, sizeof(frame_buf), tx,
-				    WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY,
-				    ifmgd->reconnect);
-	ifmgd->reconnect = false;
-}
-
-static void __ieee80211_disconnect(struct ieee80211_sub_if_data *sdata)
-{
-	sdata_lock(sdata);
-	___ieee80211_disconnect(sdata);
-	sdata_unlock(sdata);
-}
-
-static void ieee80211_beacon_connection_loss_work(struct wiphy *wiphy,
-						  struct wiphy_work *work)
-{
-	struct ieee80211_sub_if_data *sdata =
-		container_of(work, struct ieee80211_sub_if_data,
-			     u.mgd.beacon_connection_loss_work);
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-
-	if (ifmgd->connection_loss) {
-		sdata_info(sdata, "Connection to AP %pM lost\n",
-			   sdata->vif.cfg.ap_addr);
-		__ieee80211_disconnect(sdata);
-		ifmgd->connection_loss = false;
-	} else if (ifmgd->driver_disconnect) {
-		sdata_info(sdata,
-			   "Driver requested disconnection from AP %pM\n",
-			   sdata->vif.cfg.ap_addr);
-		__ieee80211_disconnect(sdata);
-		ifmgd->driver_disconnect = false;
-	} else {
-		if (ifmgd->associated)
-			sdata->deflink.u.mgd.beacon_loss_count++;
-		ieee80211_mgd_probe_ap(sdata, true);
-	}
-}
-
-static void ieee80211_csa_connection_drop_work(struct wiphy *wiphy,
-					       struct wiphy_work *work)
-{
-	struct ieee80211_sub_if_data *sdata =
-		container_of(work, struct ieee80211_sub_if_data,
-			     u.mgd.csa_connection_drop_work);
-
-	__ieee80211_disconnect(sdata);
-}
-
-void ieee80211_beacon_loss(struct ieee80211_vif *vif)
-{
-	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
-	struct ieee80211_hw *hw = &sdata->local->hw;
-
-	trace_api_beacon_loss(sdata);
-
-	sdata->u.mgd.connection_loss = false;
-	wiphy_work_queue(hw->wiphy, &sdata->u.mgd.beacon_connection_loss_work);
-}
-EXPORT_SYMBOL(ieee80211_beacon_loss);
-
-void ieee80211_connection_loss(struct ieee80211_vif *vif)
-{
-	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
-	struct ieee80211_hw *hw = &sdata->local->hw;
-
-	trace_api_connection_loss(sdata);
-
-	sdata->u.mgd.connection_loss = true;
-	wiphy_work_queue(hw->wiphy, &sdata->u.mgd.beacon_connection_loss_work);
-}
-EXPORT_SYMBOL(ieee80211_connection_loss);
-
-void ieee80211_disconnect(struct ieee80211_vif *vif, bool reconnect)
-{
-	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
-	struct ieee80211_hw *hw = &sdata->local->hw;
-
-	trace_api_disconnect(sdata, reconnect);
-
-	if (WARN_ON(sdata->vif.type != NL80211_IFTYPE_STATION))
-		return;
-
-	sdata->u.mgd.driver_disconnect = true;
-	sdata->u.mgd.reconnect = reconnect;
-	wiphy_work_queue(hw->wiphy, &sdata->u.mgd.beacon_connection_loss_work);
-}
-EXPORT_SYMBOL(ieee80211_disconnect);
-
-static void ieee80211_destroy_auth_data(struct ieee80211_sub_if_data *sdata,
-					bool assoc)
-{
-	struct ieee80211_mgd_auth_data *auth_data = sdata->u.mgd.auth_data;
-
-	sdata_assert_lock(sdata);
-
-	if (!assoc) {
-		/*
-		 * we are not authenticated yet, the only timer that could be
-		 * running is the timeout for the authentication response which
-		 * which is not relevant anymore.
-		 */
-		del_timer_sync(&sdata->u.mgd.timer);
-		sta_info_destroy_addr(sdata, auth_data->ap_addr);
-
-		/* other links are destroyed */
-		sdata->deflink.u.mgd.conn_flags = 0;
-		eth_zero_addr(sdata->deflink.u.mgd.bssid);
-		ieee80211_link_info_change_notify(sdata, &sdata->deflink,
-						  BSS_CHANGED_BSSID);
-		sdata->u.mgd.flags = 0;
-
-		mutex_lock(&sdata->local->mtx);
-		ieee80211_link_release_channel(&sdata->deflink);
-		ieee80211_vif_set_links(sdata, 0, 0);
-		mutex_unlock(&sdata->local->mtx);
-	}
-
-	cfg80211_put_bss(sdata->local->hw.wiphy, auth_data->bss);
-	kfree(auth_data);
-	sdata->u.mgd.auth_data = NULL;
-}
-
-enum assoc_status {
-	ASSOC_SUCCESS,
-	ASSOC_REJECTED,
-	ASSOC_TIMEOUT,
-	ASSOC_ABANDON,
-};
-
-static void ieee80211_destroy_assoc_data(struct ieee80211_sub_if_data *sdata,
-					 enum assoc_status status)
-{
-	struct ieee80211_mgd_assoc_data *assoc_data = sdata->u.mgd.assoc_data;
-
-	sdata_assert_lock(sdata);
-
-	if (status != ASSOC_SUCCESS) {
-		/*
-		 * we are not associated yet, the only timer that could be
-		 * running is the timeout for the association response which
-		 * which is not relevant anymore.
-		 */
-		del_timer_sync(&sdata->u.mgd.timer);
-		sta_info_destroy_addr(sdata, assoc_data->ap_addr);
-
-		sdata->deflink.u.mgd.conn_flags = 0;
-		eth_zero_addr(sdata->deflink.u.mgd.bssid);
-		ieee80211_link_info_change_notify(sdata, &sdata->deflink,
-						  BSS_CHANGED_BSSID);
-		sdata->u.mgd.flags = 0;
-		sdata->vif.bss_conf.mu_mimo_owner = false;
-
-		if (status != ASSOC_REJECTED) {
-			struct cfg80211_assoc_failure data = {
-				.timeout = status == ASSOC_TIMEOUT,
-			};
-			int i;
-
-			BUILD_BUG_ON(ARRAY_SIZE(data.bss) !=
-				     ARRAY_SIZE(assoc_data->link));
-
-			for (i = 0; i < ARRAY_SIZE(data.bss); i++)
-				data.bss[i] = assoc_data->link[i].bss;
-
-			if (ieee80211_vif_is_mld(&sdata->vif))
-				data.ap_mld_addr = assoc_data->ap_addr;
-
-			cfg80211_assoc_failure(sdata->dev, &data);
-		}
-
-		mutex_lock(&sdata->local->mtx);
-		ieee80211_link_release_channel(&sdata->deflink);
-		ieee80211_vif_set_links(sdata, 0, 0);
-		mutex_unlock(&sdata->local->mtx);
-	}
-
-	kfree(assoc_data);
-	sdata->u.mgd.assoc_data = NULL;
-}
-
-static void ieee80211_auth_challenge(struct ieee80211_sub_if_data *sdata,
-				     struct ieee80211_mgmt *mgmt, size_t len)
-{
-	struct ieee80211_local *local = sdata->local;
-	struct ieee80211_mgd_auth_data *auth_data = sdata->u.mgd.auth_data;
-	const struct element *challenge;
-	u8 *pos;
-	u32 tx_flags = 0;
-	struct ieee80211_prep_tx_info info = {
-		.subtype = IEEE80211_STYPE_AUTH,
-	};
-
-	pos = mgmt->u.auth.variable;
-	challenge = cfg80211_find_elem(WLAN_EID_CHALLENGE, pos,
-				       len - (pos - (u8 *)mgmt));
-	if (!challenge)
-		return;
-	auth_data->expected_transaction = 4;
-	drv_mgd_prepare_tx(sdata->local, sdata, &info);
-	if (ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS))
-		tx_flags = IEEE80211_TX_CTL_REQ_TX_STATUS |
-			   IEEE80211_TX_INTFL_MLME_CONN_TX;
-	ieee80211_send_auth(sdata, 3, auth_data->algorithm, 0,
-			    (void *)challenge,
-			    challenge->datalen + sizeof(*challenge),
-			    auth_data->ap_addr, auth_data->ap_addr,
-			    auth_data->key, auth_data->key_len,
-			    auth_data->key_idx, tx_flags);
-}
-
-static bool ieee80211_mark_sta_auth(struct ieee80211_sub_if_data *sdata)
-{
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-	const u8 *ap_addr = ifmgd->auth_data->ap_addr;
-	struct sta_info *sta;
-	bool result = true;
-
-	sdata_info(sdata, "authenticated\n");
-	ifmgd->auth_data->done = true;
-	ifmgd->auth_data->timeout = jiffies + IEEE80211_AUTH_WAIT_ASSOC;
-	ifmgd->auth_data->timeout_started = true;
-	run_again(sdata, ifmgd->auth_data->timeout);
-
-	/* move station state to auth */
-	mutex_lock(&sdata->local->sta_mtx);
-	sta = sta_info_get(sdata, ap_addr);
-	if (!sta) {
-		WARN_ONCE(1, "%s: STA %pM not found", sdata->name, ap_addr);
-		result = false;
-		goto out;
-	}
-	if (sta_info_move_state(sta, IEEE80211_STA_AUTH)) {
-		sdata_info(sdata, "failed moving %pM to auth\n", ap_addr);
-		result = false;
-		goto out;
-	}
-
-out:
-	mutex_unlock(&sdata->local->sta_mtx);
-	return result;
-}
-
-static void ieee80211_rx_mgmt_auth(struct ieee80211_sub_if_data *sdata,
-				   struct ieee80211_mgmt *mgmt, size_t len)
-{
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-	u16 auth_alg, auth_transaction, status_code;
-	struct ieee80211_event event = {
-		.type = MLME_EVENT,
-		.u.mlme.data = AUTH_EVENT,
-	};
-	struct ieee80211_prep_tx_info info = {
-		.subtype = IEEE80211_STYPE_AUTH,
-	};
-
-	sdata_assert_lock(sdata);
-
-	if (len < 24 + 6)
-		return;
-
-	if (!ifmgd->auth_data || ifmgd->auth_data->done)
-		return;
-
-	if (!ether_addr_equal(ifmgd->auth_data->ap_addr, mgmt->bssid))
-		return;
-
-	auth_alg = le16_to_cpu(mgmt->u.auth.auth_alg);
-	auth_transaction = le16_to_cpu(mgmt->u.auth.auth_transaction);
-	status_code = le16_to_cpu(mgmt->u.auth.status_code);
-
-	if (auth_alg != ifmgd->auth_data->algorithm ||
-	    (auth_alg != WLAN_AUTH_SAE &&
-	     auth_transaction != ifmgd->auth_data->expected_transaction) ||
-	    (auth_alg == WLAN_AUTH_SAE &&
-	     (auth_transaction < ifmgd->auth_data->expected_transaction ||
-	      auth_transaction > 2))) {
-		sdata_info(sdata, "%pM unexpected authentication state: alg %d (expected %d) transact %d (expected %d)\n",
-			   mgmt->sa, auth_alg, ifmgd->auth_data->algorithm,
-			   auth_transaction,
-			   ifmgd->auth_data->expected_transaction);
-		goto notify_driver;
-	}
-
-	if (status_code != WLAN_STATUS_SUCCESS) {
-		cfg80211_rx_mlme_mgmt(sdata->dev, (u8 *)mgmt, len);
-
-		if (auth_alg == WLAN_AUTH_SAE &&
-		    (status_code == WLAN_STATUS_ANTI_CLOG_REQUIRED ||
-		     (auth_transaction == 1 &&
-		      (status_code == WLAN_STATUS_SAE_HASH_TO_ELEMENT ||
-		       status_code == WLAN_STATUS_SAE_PK)))) {
-			/* waiting for userspace now */
-			ifmgd->auth_data->waiting = true;
-			ifmgd->auth_data->timeout =
-				jiffies + IEEE80211_AUTH_WAIT_SAE_RETRY;
-			ifmgd->auth_data->timeout_started = true;
-			run_again(sdata, ifmgd->auth_data->timeout);
-			goto notify_driver;
-		}
-
-		sdata_info(sdata, "%pM denied authentication (status %d)\n",
-			   mgmt->sa, status_code);
-		ieee80211_destroy_auth_data(sdata, false);
-		event.u.mlme.status = MLME_DENIED;
-		event.u.mlme.reason = status_code;
-		drv_event_callback(sdata->local, sdata, &event);
-		goto notify_driver;
-	}
-
-	switch (ifmgd->auth_data->algorithm) {
-	case WLAN_AUTH_OPEN:
-	case WLAN_AUTH_LEAP:
-	case WLAN_AUTH_FT:
-	case WLAN_AUTH_SAE:
-	case WLAN_AUTH_FILS_SK:
-	case WLAN_AUTH_FILS_SK_PFS:
-	case WLAN_AUTH_FILS_PK:
-		break;
-	case WLAN_AUTH_SHARED_KEY:
-		if (ifmgd->auth_data->expected_transaction != 4) {
-			ieee80211_auth_challenge(sdata, mgmt, len);
-			/* need another frame */
-			return;
-		}
-		break;
-	default:
-		WARN_ONCE(1, "invalid auth alg %d",
-			  ifmgd->auth_data->algorithm);
-		goto notify_driver;
-	}
-
-	event.u.mlme.status = MLME_SUCCESS;
-	info.success = 1;
-	drv_event_callback(sdata->local, sdata, &event);
-	if (ifmgd->auth_data->algorithm != WLAN_AUTH_SAE ||
-	    (auth_transaction == 2 &&
-	     ifmgd->auth_data->expected_transaction == 2)) {
-		if (!ieee80211_mark_sta_auth(sdata))
-			return; /* ignore frame -- wait for timeout */
-	} else if (ifmgd->auth_data->algorithm == WLAN_AUTH_SAE &&
-		   auth_transaction == 2) {
-		sdata_info(sdata, "SAE peer confirmed\n");
-		ifmgd->auth_data->peer_confirmed = true;
-	}
-
-	cfg80211_rx_mlme_mgmt(sdata->dev, (u8 *)mgmt, len);
-notify_driver:
-	drv_mgd_complete_tx(sdata->local, sdata, &info);
-}
-
-#define case_WLAN(type) \
-	case WLAN_REASON_##type: return #type
-
-const char *ieee80211_get_reason_code_string(u16 reason_code)
-{
-	switch (reason_code) {
-	case_WLAN(UNSPECIFIED);
-	case_WLAN(PREV_AUTH_NOT_VALID);
-	case_WLAN(DEAUTH_LEAVING);
-	case_WLAN(DISASSOC_DUE_TO_INACTIVITY);
-	case_WLAN(DISASSOC_AP_BUSY);
-	case_WLAN(CLASS2_FRAME_FROM_NONAUTH_STA);
-	case_WLAN(CLASS3_FRAME_FROM_NONASSOC_STA);
-	case_WLAN(DISASSOC_STA_HAS_LEFT);
-	case_WLAN(STA_REQ_ASSOC_WITHOUT_AUTH);
-	case_WLAN(DISASSOC_BAD_POWER);
-	case_WLAN(DISASSOC_BAD_SUPP_CHAN);
-	case_WLAN(INVALID_IE);
-	case_WLAN(MIC_FAILURE);
-	case_WLAN(4WAY_HANDSHAKE_TIMEOUT);
-	case_WLAN(GROUP_KEY_HANDSHAKE_TIMEOUT);
-	case_WLAN(IE_DIFFERENT);
-	case_WLAN(INVALID_GROUP_CIPHER);
-	case_WLAN(INVALID_PAIRWISE_CIPHER);
-	case_WLAN(INVALID_AKMP);
-	case_WLAN(UNSUPP_RSN_VERSION);
-	case_WLAN(INVALID_RSN_IE_CAP);
-	case_WLAN(IEEE8021X_FAILED);
-	case_WLAN(CIPHER_SUITE_REJECTED);
-	case_WLAN(DISASSOC_UNSPECIFIED_QOS);
-	case_WLAN(DISASSOC_QAP_NO_BANDWIDTH);
-	case_WLAN(DISASSOC_LOW_ACK);
-	case_WLAN(DISASSOC_QAP_EXCEED_TXOP);
-	case_WLAN(QSTA_LEAVE_QBSS);
-	case_WLAN(QSTA_NOT_USE);
-	case_WLAN(QSTA_REQUIRE_SETUP);
-	case_WLAN(QSTA_TIMEOUT);
-	case_WLAN(QSTA_CIPHER_NOT_SUPP);
-	case_WLAN(MESH_PEER_CANCELED);
-	case_WLAN(MESH_MAX_PEERS);
-	case_WLAN(MESH_CONFIG);
-	case_WLAN(MESH_CLOSE);
-	case_WLAN(MESH_MAX_RETRIES);
-	case_WLAN(MESH_CONFIRM_TIMEOUT);
-	case_WLAN(MESH_INVALID_GTK);
-	case_WLAN(MESH_INCONSISTENT_PARAM);
-	case_WLAN(MESH_INVALID_SECURITY);
-	case_WLAN(MESH_PATH_ERROR);
-	case_WLAN(MESH_PATH_NOFORWARD);
-	case_WLAN(MESH_PATH_DEST_UNREACHABLE);
-	case_WLAN(MAC_EXISTS_IN_MBSS);
-	case_WLAN(MESH_CHAN_REGULATORY);
-	case_WLAN(MESH_CHAN);
-	default: return "<unknown>";
-	}
-}
-
-static void ieee80211_rx_mgmt_deauth(struct ieee80211_sub_if_data *sdata,
-				     struct ieee80211_mgmt *mgmt, size_t len)
-{
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-	u16 reason_code = le16_to_cpu(mgmt->u.deauth.reason_code);
-
-	sdata_assert_lock(sdata);
-
-	if (len < 24 + 2)
-		return;
-
-	if (!ether_addr_equal(mgmt->bssid, mgmt->sa)) {
-		ieee80211_tdls_handle_disconnect(sdata, mgmt->sa, reason_code);
-		return;
-	}
-
-	if (ifmgd->associated &&
-	    ether_addr_equal(mgmt->bssid, sdata->vif.cfg.ap_addr)) {
-		sdata_info(sdata, "deauthenticated from %pM (Reason: %u=%s)\n",
-			   sdata->vif.cfg.ap_addr, reason_code,
-			   ieee80211_get_reason_code_string(reason_code));
-
-		ieee80211_set_disassoc(sdata, 0, 0, false, NULL);
-
-		ieee80211_report_disconnect(sdata, (u8 *)mgmt, len, false,
-					    reason_code, false);
-		return;
-	}
-
-	if (ifmgd->assoc_data &&
-	    ether_addr_equal(mgmt->bssid, ifmgd->assoc_data->ap_addr)) {
-		sdata_info(sdata,
-			   "deauthenticated from %pM while associating (Reason: %u=%s)\n",
-			   ifmgd->assoc_data->ap_addr, reason_code,
-			   ieee80211_get_reason_code_string(reason_code));
-
-		ieee80211_destroy_assoc_data(sdata, ASSOC_ABANDON);
-
-		cfg80211_rx_mlme_mgmt(sdata->dev, (u8 *)mgmt, len);
-		return;
-	}
-}
-
-
-static void ieee80211_rx_mgmt_disassoc(struct ieee80211_sub_if_data *sdata,
-				       struct ieee80211_mgmt *mgmt, size_t len)
-{
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-	u16 reason_code;
-
-	sdata_assert_lock(sdata);
-
-	if (len < 24 + 2)
-		return;
-
-	if (!ifmgd->associated ||
-	    !ether_addr_equal(mgmt->bssid, sdata->vif.cfg.ap_addr))
-		return;
-
-	reason_code = le16_to_cpu(mgmt->u.disassoc.reason_code);
-
-	if (!ether_addr_equal(mgmt->bssid, mgmt->sa)) {
-		ieee80211_tdls_handle_disconnect(sdata, mgmt->sa, reason_code);
-		return;
-	}
-
-	sdata_info(sdata, "disassociated from %pM (Reason: %u=%s)\n",
-		   sdata->vif.cfg.ap_addr, reason_code,
-		   ieee80211_get_reason_code_string(reason_code));
-
-	ieee80211_set_disassoc(sdata, 0, 0, false, NULL);
-
-	ieee80211_report_disconnect(sdata, (u8 *)mgmt, len, false, reason_code,
-				    false);
-}
-
-static void ieee80211_get_rates(struct ieee80211_supported_band *sband,
-				u8 *supp_rates, unsigned int supp_rates_len,
-				u32 *rates, u32 *basic_rates,
-				bool *have_higher_than_11mbit,
-				int *min_rate, int *min_rate_index,
-				int shift)
-{
-	int i, j;
-
-	for (i = 0; i < supp_rates_len; i++) {
-		int rate = supp_rates[i] & 0x7f;
-		bool is_basic = !!(supp_rates[i] & 0x80);
-
-		if ((rate * 5 * (1 << shift)) > 110)
-			*have_higher_than_11mbit = true;
-
-		/*
-		 * Skip HT, VHT, HE, EHT and SAE H2E only BSS membership
-		 * selectors since they're not rates.
-		 *
-		 * Note: Even though the membership selector and the basic
-		 *	 rate flag share the same bit, they are not exactly
-		 *	 the same.
-		 */
-		if (supp_rates[i] == (0x80 | BSS_MEMBERSHIP_SELECTOR_HT_PHY) ||
-		    supp_rates[i] == (0x80 | BSS_MEMBERSHIP_SELECTOR_VHT_PHY) ||
-		    supp_rates[i] == (0x80 | BSS_MEMBERSHIP_SELECTOR_HE_PHY) ||
-		    supp_rates[i] == (0x80 | BSS_MEMBERSHIP_SELECTOR_EHT_PHY) ||
-		    supp_rates[i] == (0x80 | BSS_MEMBERSHIP_SELECTOR_SAE_H2E))
-			continue;
-
-		for (j = 0; j < sband->n_bitrates; j++) {
-			struct ieee80211_rate *br;
-			int brate;
-
-			br = &sband->bitrates[j];
-
-			brate = DIV_ROUND_UP(br->bitrate, (1 << shift) * 5);
-			if (brate == rate) {
-				*rates |= BIT(j);
-				if (is_basic)
-					*basic_rates |= BIT(j);
-				if ((rate * 5) < *min_rate) {
-					*min_rate = rate * 5;
-					*min_rate_index = j;
-				}
-				break;
-			}
-		}
-	}
-}
-
-static bool ieee80211_twt_req_supported(struct ieee80211_sub_if_data *sdata,
-					struct ieee80211_supported_band *sband,
-					const struct link_sta_info *link_sta,
-					const struct ieee802_11_elems *elems)
-{
-	const struct ieee80211_sta_he_cap *own_he_cap =
-		ieee80211_get_he_iftype_cap_vif(sband, &sdata->vif);
-
-	if (elems->ext_capab_len < 10)
-		return false;
-
-	if (!(elems->ext_capab[9] & WLAN_EXT_CAPA10_TWT_RESPONDER_SUPPORT))
-		return false;
-
-	return link_sta->pub->he_cap.he_cap_elem.mac_cap_info[0] &
-		IEEE80211_HE_MAC_CAP0_TWT_RES &&
-		own_he_cap &&
-		(own_he_cap->he_cap_elem.mac_cap_info[0] &
-			IEEE80211_HE_MAC_CAP0_TWT_REQ);
-}
-
-static u64 ieee80211_recalc_twt_req(struct ieee80211_sub_if_data *sdata,
-				    struct ieee80211_supported_band *sband,
-				    struct ieee80211_link_data *link,
-				    struct link_sta_info *link_sta,
-				    struct ieee802_11_elems *elems)
-{
-	bool twt = ieee80211_twt_req_supported(sdata, sband, link_sta, elems);
-
-	if (link->conf->twt_requester != twt) {
-		link->conf->twt_requester = twt;
-		return BSS_CHANGED_TWT;
-	}
-	return 0;
-}
-
-static bool ieee80211_twt_bcast_support(struct ieee80211_sub_if_data *sdata,
-					struct ieee80211_bss_conf *bss_conf,
-					struct ieee80211_supported_band *sband,
-					struct link_sta_info *link_sta)
-{
-	const struct ieee80211_sta_he_cap *own_he_cap =
-		ieee80211_get_he_iftype_cap_vif(sband, &sdata->vif);
-
-	return bss_conf->he_support &&
-		(link_sta->pub->he_cap.he_cap_elem.mac_cap_info[2] &
-			IEEE80211_HE_MAC_CAP2_BCAST_TWT) &&
-		own_he_cap &&
-		(own_he_cap->he_cap_elem.mac_cap_info[2] &
-			IEEE80211_HE_MAC_CAP2_BCAST_TWT);
-}
-
-static bool ieee80211_assoc_config_link(struct ieee80211_link_data *link,
-					struct link_sta_info *link_sta,
-					struct cfg80211_bss *cbss,
-					struct ieee80211_mgmt *mgmt,
-					const u8 *elem_start,
-					unsigned int elem_len,
-					u64 *changed)
-{
-	struct ieee80211_sub_if_data *sdata = link->sdata;
-	struct ieee80211_mgd_assoc_data *assoc_data = sdata->u.mgd.assoc_data;
-	struct ieee80211_bss_conf *bss_conf = link->conf;
-	struct ieee80211_local *local = sdata->local;
-	unsigned int link_id = link->link_id;
-	struct ieee80211_elems_parse_params parse_params = {
-		.start = elem_start,
-		.len = elem_len,
-		.link_id = link_id == assoc_data->assoc_link_id ? -1 : link_id,
-		.from_ap = true,
-	};
-	bool is_6ghz = cbss->channel->band == NL80211_BAND_6GHZ;
-	bool is_s1g = cbss->channel->band == NL80211_BAND_S1GHZ;
-	const struct cfg80211_bss_ies *bss_ies = NULL;
-	struct ieee80211_supported_band *sband;
-	struct ieee802_11_elems *elems;
-	const __le16 prof_bss_param_ch_present =
-		cpu_to_le16(IEEE80211_MLE_STA_CONTROL_BSS_PARAM_CHANGE_CNT_PRESENT);
-	u16 capab_info;
-	bool ret;
-
-	elems = ieee802_11_parse_elems_full(&parse_params);
-	if (!elems)
-		return false;
-
-	if (link_id == assoc_data->assoc_link_id) {
-		capab_info = le16_to_cpu(mgmt->u.assoc_resp.capab_info);
-
-		/*
-		 * we should not get to this flow unless the association was
-		 * successful, so set the status directly to success
-		 */
-		assoc_data->link[link_id].status = WLAN_STATUS_SUCCESS;
-		if (elems->ml_basic) {
-			if (!(elems->ml_basic->control &
-					cpu_to_le16(IEEE80211_MLC_BASIC_PRES_BSS_PARAM_CH_CNT))) {
-				ret = false;
-				goto out;
-			}
-			link->u.mgd.bss_param_ch_cnt =
-				ieee80211_mle_get_bss_param_ch_cnt(elems->ml_basic);
-		}
-	} else if (!elems->prof ||
-		   !(elems->prof->control & prof_bss_param_ch_present)) {
-		ret = false;
-		goto out;
-	} else {
-		const u8 *ptr = elems->prof->variable +
-				elems->prof->sta_info_len - 1;
-
-		/*
-		 * During parsing, we validated that these fields exist,
-		 * otherwise elems->prof would have been set to NULL.
-		 */
-		capab_info = get_unaligned_le16(ptr);
-		assoc_data->link[link_id].status = get_unaligned_le16(ptr + 2);
-		link->u.mgd.bss_param_ch_cnt =
-			ieee80211_mle_basic_sta_prof_bss_param_ch_cnt(elems->prof);
-
-		if (assoc_data->link[link_id].status != WLAN_STATUS_SUCCESS) {
-			link_info(link, "association response status code=%u\n",
-				  assoc_data->link[link_id].status);
-			ret = true;
-			goto out;
-		}
-	}
-
-	if (!is_s1g && !elems->supp_rates) {
-		sdata_info(sdata, "no SuppRates element in AssocResp\n");
-		ret = false;
-		goto out;
-	}
-
-	link->u.mgd.tdls_chan_switch_prohibited =
-		elems->ext_capab && elems->ext_capab_len >= 5 &&
-		(elems->ext_capab[4] & WLAN_EXT_CAPA5_TDLS_CH_SW_PROHIBITED);
-
-	/*
-	 * Some APs are erroneously not including some information in their
-	 * (re)association response frames. Try to recover by using the data
-	 * from the beacon or probe response. This seems to afflict mobile
-	 * 2G/3G/4G wifi routers, reported models include the "Onda PN51T",
-	 * "Vodafone PocketWiFi 2", "ZTE MF60" and a similar T-Mobile device.
-	 */
-	if (!is_6ghz &&
-	    ((assoc_data->wmm && !elems->wmm_param) ||
-	     (!(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT) &&
-	      (!elems->ht_cap_elem || !elems->ht_operation)) ||
-	     (!(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT) &&
-	      (!elems->vht_cap_elem || !elems->vht_operation)))) {
-		const struct cfg80211_bss_ies *ies;
-		struct ieee802_11_elems *bss_elems;
-
-		rcu_read_lock();
-		ies = rcu_dereference(cbss->ies);
-		if (ies)
-			bss_ies = kmemdup(ies, sizeof(*ies) + ies->len,
-					  GFP_ATOMIC);
-		rcu_read_unlock();
-		if (!bss_ies) {
-			ret = false;
-			goto out;
-		}
-
-		parse_params.start = bss_ies->data;
-		parse_params.len = bss_ies->len;
-		parse_params.bss = cbss;
-		bss_elems = ieee802_11_parse_elems_full(&parse_params);
-		if (!bss_elems) {
-			ret = false;
-			goto out;
-		}
-
-		if (assoc_data->wmm &&
-		    !elems->wmm_param && bss_elems->wmm_param) {
-			elems->wmm_param = bss_elems->wmm_param;
-			sdata_info(sdata,
-				   "AP bug: WMM param missing from AssocResp\n");
-		}
-
-		/*
-		 * Also check if we requested HT/VHT, otherwise the AP doesn't
-		 * have to include the IEs in the (re)association response.
-		 */
-		if (!elems->ht_cap_elem && bss_elems->ht_cap_elem &&
-		    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT)) {
-			elems->ht_cap_elem = bss_elems->ht_cap_elem;
-			sdata_info(sdata,
-				   "AP bug: HT capability missing from AssocResp\n");
-		}
-		if (!elems->ht_operation && bss_elems->ht_operation &&
-		    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT)) {
-			elems->ht_operation = bss_elems->ht_operation;
-			sdata_info(sdata,
-				   "AP bug: HT operation missing from AssocResp\n");
-		}
-		if (!elems->vht_cap_elem && bss_elems->vht_cap_elem &&
-		    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT)) {
-			elems->vht_cap_elem = bss_elems->vht_cap_elem;
-			sdata_info(sdata,
-				   "AP bug: VHT capa missing from AssocResp\n");
-		}
-		if (!elems->vht_operation && bss_elems->vht_operation &&
-		    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT)) {
-			elems->vht_operation = bss_elems->vht_operation;
-			sdata_info(sdata,
-				   "AP bug: VHT operation missing from AssocResp\n");
-		}
-
-		kfree(bss_elems);
-	}
-
-	/*
-	 * We previously checked these in the beacon/probe response, so
-	 * they should be present here. This is just a safety net.
-	 */
-	if (!is_6ghz && !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT) &&
-	    (!elems->wmm_param || !elems->ht_cap_elem || !elems->ht_operation)) {
-		sdata_info(sdata,
-			   "HT AP is missing WMM params or HT capability/operation\n");
-		ret = false;
-		goto out;
-	}
-
-	if (!is_6ghz && !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT) &&
-	    (!elems->vht_cap_elem || !elems->vht_operation)) {
-		sdata_info(sdata,
-			   "VHT AP is missing VHT capability/operation\n");
-		ret = false;
-		goto out;
-	}
-
-	if (is_6ghz && !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HE) &&
-	    !elems->he_6ghz_capa) {
-		sdata_info(sdata,
-			   "HE 6 GHz AP is missing HE 6 GHz band capability\n");
-		ret = false;
-		goto out;
-	}
-
-	if (WARN_ON(!link->conf->chandef.chan)) {
-		ret = false;
-		goto out;
-	}
-	sband = local->hw.wiphy->bands[link->conf->chandef.chan->band];
-
-	if (!(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HE) &&
-	    (!elems->he_cap || !elems->he_operation)) {
-		sdata_info(sdata,
-			   "HE AP is missing HE capability/operation\n");
-		ret = false;
-		goto out;
-	}
-
-	/* Set up internal HT/VHT capabilities */
-	if (elems->ht_cap_elem && !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT))
-		ieee80211_ht_cap_ie_to_sta_ht_cap(sdata, sband,
-						  elems->ht_cap_elem,
-						  link_sta);
-
-	if (elems->vht_cap_elem &&
-	    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT)) {
-		const struct ieee80211_vht_cap *bss_vht_cap = NULL;
-		const struct cfg80211_bss_ies *ies;
-
-		/*
-		 * Cisco AP module 9115 with FW 17.3 has a bug and sends a
-		 * too large maximum MPDU length in the association response
-		 * (indicating 12k) that it cannot actually process ...
-		 * Work around that.
-		 */
-		rcu_read_lock();
-		ies = rcu_dereference(cbss->ies);
-		if (ies) {
-			const struct element *elem;
-
-			elem = cfg80211_find_elem(WLAN_EID_VHT_CAPABILITY,
-						  ies->data, ies->len);
-			if (elem && elem->datalen >= sizeof(*bss_vht_cap))
-				bss_vht_cap = (const void *)elem->data;
-		}
-
-		ieee80211_vht_cap_ie_to_sta_vht_cap(sdata, sband,
-						    elems->vht_cap_elem,
-						    bss_vht_cap, link_sta);
-		rcu_read_unlock();
-	}
-
-	if (elems->he_operation && !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HE) &&
-	    elems->he_cap) {
-		ieee80211_he_cap_ie_to_sta_he_cap(sdata, sband,
-						  elems->he_cap,
-						  elems->he_cap_len,
-						  elems->he_6ghz_capa,
-						  link_sta);
-
-		bss_conf->he_support = link_sta->pub->he_cap.has_he;
-		if (elems->rsnx && elems->rsnx_len &&
-		    (elems->rsnx[0] & WLAN_RSNX_CAPA_PROTECTED_TWT) &&
-		    wiphy_ext_feature_isset(local->hw.wiphy,
-					    NL80211_EXT_FEATURE_PROTECTED_TWT))
-			bss_conf->twt_protected = true;
-		else
-			bss_conf->twt_protected = false;
-
-		*changed |= ieee80211_recalc_twt_req(sdata, sband, link,
-						     link_sta, elems);
-
-		if (elems->eht_operation && elems->eht_cap &&
-		    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_EHT)) {
-			ieee80211_eht_cap_ie_to_sta_eht_cap(sdata, sband,
-							    elems->he_cap,
-							    elems->he_cap_len,
-							    elems->eht_cap,
-							    elems->eht_cap_len,
-							    link_sta);
-
-			bss_conf->eht_support = link_sta->pub->eht_cap.has_eht;
-			*changed |= BSS_CHANGED_EHT_PUNCTURING;
-		} else {
-			bss_conf->eht_support = false;
-		}
-	} else {
-		bss_conf->he_support = false;
-		bss_conf->twt_requester = false;
-		bss_conf->twt_protected = false;
-		bss_conf->eht_support = false;
-	}
-
-	bss_conf->twt_broadcast =
-		ieee80211_twt_bcast_support(sdata, bss_conf, sband, link_sta);
-
-	if (bss_conf->he_support) {
-		bss_conf->he_bss_color.color =
-			le32_get_bits(elems->he_operation->he_oper_params,
-				      IEEE80211_HE_OPERATION_BSS_COLOR_MASK);
-		bss_conf->he_bss_color.partial =
-			le32_get_bits(elems->he_operation->he_oper_params,
-				      IEEE80211_HE_OPERATION_PARTIAL_BSS_COLOR);
-		bss_conf->he_bss_color.enabled =
-			!le32_get_bits(elems->he_operation->he_oper_params,
-				       IEEE80211_HE_OPERATION_BSS_COLOR_DISABLED);
-
-		if (bss_conf->he_bss_color.enabled)
-			*changed |= BSS_CHANGED_HE_BSS_COLOR;
-
-		bss_conf->htc_trig_based_pkt_ext =
-			le32_get_bits(elems->he_operation->he_oper_params,
-				      IEEE80211_HE_OPERATION_DFLT_PE_DURATION_MASK);
-		bss_conf->frame_time_rts_th =
-			le32_get_bits(elems->he_operation->he_oper_params,
-				      IEEE80211_HE_OPERATION_RTS_THRESHOLD_MASK);
-
-		bss_conf->uora_exists = !!elems->uora_element;
-		if (elems->uora_element)
-			bss_conf->uora_ocw_range = elems->uora_element[0];
-
-		ieee80211_he_op_ie_to_bss_conf(&sdata->vif, elems->he_operation);
-		ieee80211_he_spr_ie_to_bss_conf(&sdata->vif, elems->he_spr);
-		/* TODO: OPEN: what happens if BSS color disable is set? */
-	}
-
-	if (cbss->transmitted_bss) {
-		bss_conf->nontransmitted = true;
-		ether_addr_copy(bss_conf->transmitter_bssid,
-				cbss->transmitted_bss->bssid);
-		bss_conf->bssid_indicator = cbss->max_bssid_indicator;
-		bss_conf->bssid_index = cbss->bssid_index;
-	}
-
-	/*
-	 * Some APs, e.g. Netgear WNDR3700, report invalid HT operation data
-	 * in their association response, so ignore that data for our own
-	 * configuration. If it changed since the last beacon, we'll get the
-	 * next beacon and update then.
-	 */
-
-	/*
-	 * If an operating mode notification IE is present, override the
-	 * NSS calculation (that would be done in rate_control_rate_init())
-	 * and use the # of streams from that element.
-	 */
-	if (elems->opmode_notif &&
-	    !(*elems->opmode_notif & IEEE80211_OPMODE_NOTIF_RX_NSS_TYPE_BF)) {
-		u8 nss;
-
-		nss = *elems->opmode_notif & IEEE80211_OPMODE_NOTIF_RX_NSS_MASK;
-		nss >>= IEEE80211_OPMODE_NOTIF_RX_NSS_SHIFT;
-		nss += 1;
-		link_sta->pub->rx_nss = nss;
-	}
-
-	/*
-	 * Always handle WMM once after association regardless
-	 * of the first value the AP uses. Setting -1 here has
-	 * that effect because the AP values is an unsigned
-	 * 4-bit value.
-	 */
-	link->u.mgd.wmm_last_param_set = -1;
-	link->u.mgd.mu_edca_last_param_set = -1;
-
-	if (link->u.mgd.disable_wmm_tracking) {
-		ieee80211_set_wmm_default(link, false, false);
-	} else if (!ieee80211_sta_wmm_params(local, link, elems->wmm_param,
-					     elems->wmm_param_len,
-					     elems->mu_edca_param_set)) {
-		/* still enable QoS since we might have HT/VHT */
-		ieee80211_set_wmm_default(link, false, true);
-		/* disable WMM tracking in this case to disable
-		 * tracking WMM parameter changes in the beacon if
-		 * the parameters weren't actually valid. Doing so
-		 * avoids changing parameters very strangely when
-		 * the AP is going back and forth between valid and
-		 * invalid parameters.
-		 */
-		link->u.mgd.disable_wmm_tracking = true;
-	}
-
-	if (elems->max_idle_period_ie) {
-		bss_conf->max_idle_period =
-			le16_to_cpu(elems->max_idle_period_ie->max_idle_period);
-		bss_conf->protected_keep_alive =
-			!!(elems->max_idle_period_ie->idle_options &
-			   WLAN_IDLE_OPTIONS_PROTECTED_KEEP_ALIVE);
-		*changed |= BSS_CHANGED_KEEP_ALIVE;
-	} else {
-		bss_conf->max_idle_period = 0;
-		bss_conf->protected_keep_alive = false;
-	}
-
-	/* set assoc capability (AID was already set earlier),
-	 * ieee80211_set_associated() will tell the driver */
-	bss_conf->assoc_capability = capab_info;
-
-	ret = true;
-out:
-	kfree(elems);
-	kfree(bss_ies);
-	return ret;
-}
-
-static int ieee80211_mgd_setup_link_sta(struct ieee80211_link_data *link,
-					struct sta_info *sta,
-					struct link_sta_info *link_sta,
-					struct cfg80211_bss *cbss)
-{
-	struct ieee80211_sub_if_data *sdata = link->sdata;
-	struct ieee80211_local *local = sdata->local;
-	struct ieee80211_bss *bss = (void *)cbss->priv;
-	u32 rates = 0, basic_rates = 0;
-	bool have_higher_than_11mbit = false;
-	int min_rate = INT_MAX, min_rate_index = -1;
-	/* this is clearly wrong for MLO but we'll just remove it later */
-	int shift = ieee80211_vif_get_shift(&sdata->vif);
-	struct ieee80211_supported_band *sband;
-
-	memcpy(link_sta->addr, cbss->bssid, ETH_ALEN);
-	memcpy(link_sta->pub->addr, cbss->bssid, ETH_ALEN);
-
-	/* TODO: S1G Basic Rate Set is expressed elsewhere */
-	if (cbss->channel->band == NL80211_BAND_S1GHZ) {
-		ieee80211_s1g_sta_rate_init(sta);
-		return 0;
-	}
-
-	sband = local->hw.wiphy->bands[cbss->channel->band];
-
-	ieee80211_get_rates(sband, bss->supp_rates, bss->supp_rates_len,
-			    &rates, &basic_rates, &have_higher_than_11mbit,
-			    &min_rate, &min_rate_index, shift);
-
-	/*
-	 * This used to be a workaround for basic rates missing
-	 * in the association response frame. Now that we no
-	 * longer use the basic rates from there, it probably
-	 * doesn't happen any more, but keep the workaround so
-	 * in case some *other* APs are buggy in different ways
-	 * we can connect -- with a warning.
-	 * Allow this workaround only in case the AP provided at least
-	 * one rate.
-	 */
-	if (min_rate_index < 0) {
-		link_info(link, "No legacy rates in association response\n");
-		return -EINVAL;
-	} else if (!basic_rates) {
-		link_info(link, "No basic rates, using min rate instead\n");
-		basic_rates = BIT(min_rate_index);
-	}
-
-	if (rates)
-		link_sta->pub->supp_rates[cbss->channel->band] = rates;
-	else
-		link_info(link, "No rates found, keeping mandatory only\n");
-
-	link->conf->basic_rates = basic_rates;
-
-	/* cf. IEEE 802.11 9.2.12 */
-	link->operating_11g_mode = sband->band == NL80211_BAND_2GHZ &&
-				   have_higher_than_11mbit;
-
-	return 0;
-}
-
-static u8 ieee80211_max_rx_chains(struct ieee80211_link_data *link,
-				  struct cfg80211_bss *cbss)
-{
-	struct ieee80211_he_mcs_nss_supp *he_mcs_nss_supp;
-	const struct element *ht_cap_elem, *vht_cap_elem;
-	const struct cfg80211_bss_ies *ies;
-	const struct ieee80211_ht_cap *ht_cap;
-	const struct ieee80211_vht_cap *vht_cap;
-	const struct ieee80211_he_cap_elem *he_cap;
-	const struct element *he_cap_elem;
-	u16 mcs_80_map, mcs_160_map;
-	int i, mcs_nss_size;
-	bool support_160;
-	u8 chains = 1;
-
-	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT)
-		return chains;
-
-	ht_cap_elem = ieee80211_bss_get_elem(cbss, WLAN_EID_HT_CAPABILITY);
-	if (ht_cap_elem && ht_cap_elem->datalen >= sizeof(*ht_cap)) {
-		ht_cap = (void *)ht_cap_elem->data;
-		chains = ieee80211_mcs_to_chains(&ht_cap->mcs);
-		/*
-		 * TODO: use "Tx Maximum Number Spatial Streams Supported" and
-		 *	 "Tx Unequal Modulation Supported" fields.
-		 */
-	}
-
-	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT)
-		return chains;
-
-	vht_cap_elem = ieee80211_bss_get_elem(cbss, WLAN_EID_VHT_CAPABILITY);
-	if (vht_cap_elem && vht_cap_elem->datalen >= sizeof(*vht_cap)) {
-		u8 nss;
-		u16 tx_mcs_map;
-
-		vht_cap = (void *)vht_cap_elem->data;
-		tx_mcs_map = le16_to_cpu(vht_cap->supp_mcs.tx_mcs_map);
-		for (nss = 8; nss > 0; nss--) {
-			if (((tx_mcs_map >> (2 * (nss - 1))) & 3) !=
-					IEEE80211_VHT_MCS_NOT_SUPPORTED)
-				break;
-		}
-		/* TODO: use "Tx Highest Supported Long GI Data Rate" field? */
-		chains = max(chains, nss);
-	}
-
-	if (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HE)
-		return chains;
-
-	ies = rcu_dereference(cbss->ies);
-	he_cap_elem = cfg80211_find_ext_elem(WLAN_EID_EXT_HE_CAPABILITY,
-					     ies->data, ies->len);
-
-	if (!he_cap_elem || he_cap_elem->datalen < sizeof(*he_cap))
-		return chains;
-
-	/* skip one byte ext_tag_id */
-	he_cap = (void *)(he_cap_elem->data + 1);
-	mcs_nss_size = ieee80211_he_mcs_nss_size(he_cap);
-
-	/* invalid HE IE */
-	if (he_cap_elem->datalen < 1 + mcs_nss_size + sizeof(*he_cap))
-		return chains;
-
-	/* mcs_nss is right after he_cap info */
-	he_mcs_nss_supp = (void *)(he_cap + 1);
-
-	mcs_80_map = le16_to_cpu(he_mcs_nss_supp->tx_mcs_80);
-
-	for (i = 7; i >= 0; i--) {
-		u8 mcs_80 = mcs_80_map >> (2 * i) & 3;
-
-		if (mcs_80 != IEEE80211_VHT_MCS_NOT_SUPPORTED) {
-			chains = max_t(u8, chains, i + 1);
-			break;
-		}
-	}
-
-	support_160 = he_cap->phy_cap_info[0] &
-		      IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G;
-
-	if (!support_160)
-		return chains;
-
-	mcs_160_map = le16_to_cpu(he_mcs_nss_supp->tx_mcs_160);
-	for (i = 7; i >= 0; i--) {
-		u8 mcs_160 = mcs_160_map >> (2 * i) & 3;
-
-		if (mcs_160 != IEEE80211_VHT_MCS_NOT_SUPPORTED) {
-			chains = max_t(u8, chains, i + 1);
-			break;
-		}
-	}
-
-	return chains;
-}
-
-static bool
-ieee80211_verify_peer_he_mcs_support(struct ieee80211_sub_if_data *sdata,
-				     const struct cfg80211_bss_ies *ies,
-				     const struct ieee80211_he_operation *he_op)
-{
-	const struct element *he_cap_elem;
-	const struct ieee80211_he_cap_elem *he_cap;
-	struct ieee80211_he_mcs_nss_supp *he_mcs_nss_supp;
-	u16 mcs_80_map_tx, mcs_80_map_rx;
-	u16 ap_min_req_set;
-	int mcs_nss_size;
-	int nss;
-
-	he_cap_elem = cfg80211_find_ext_elem(WLAN_EID_EXT_HE_CAPABILITY,
-					     ies->data, ies->len);
-
-	if (!he_cap_elem)
-		return false;
-
-	/* invalid HE IE */
-	if (he_cap_elem->datalen < 1 + sizeof(*he_cap)) {
-		sdata_info(sdata,
-			   "Invalid HE elem, Disable HE\n");
-		return false;
-	}
-
-	/* skip one byte ext_tag_id */
-	he_cap = (void *)(he_cap_elem->data + 1);
-	mcs_nss_size = ieee80211_he_mcs_nss_size(he_cap);
-
-	/* invalid HE IE */
-	if (he_cap_elem->datalen < 1 + sizeof(*he_cap) + mcs_nss_size) {
-		sdata_info(sdata,
-			   "Invalid HE elem with nss size, Disable HE\n");
-		return false;
-	}
-
-	/* mcs_nss is right after he_cap info */
-	he_mcs_nss_supp = (void *)(he_cap + 1);
-
-	mcs_80_map_tx = le16_to_cpu(he_mcs_nss_supp->tx_mcs_80);
-	mcs_80_map_rx = le16_to_cpu(he_mcs_nss_supp->rx_mcs_80);
-
-	/* P802.11-REVme/D0.3
-	 * 27.1.1 Introduction to the HE PHY
-	 * ...
-	 * An HE STA shall support the following features:
-	 * ...
-	 * Single spatial stream HE-MCSs 0 to 7 (transmit and receive) in all
-	 * supported channel widths for HE SU PPDUs
-	 */
-	if ((mcs_80_map_tx & 0x3) == IEEE80211_HE_MCS_NOT_SUPPORTED ||
-	    (mcs_80_map_rx & 0x3) == IEEE80211_HE_MCS_NOT_SUPPORTED) {
-		sdata_info(sdata,
-			   "Missing mandatory rates for 1 Nss, rx 0x%x, tx 0x%x, disable HE\n",
-			   mcs_80_map_tx, mcs_80_map_rx);
-		return false;
-	}
-
-	if (!he_op)
-		return true;
-
-	ap_min_req_set = le16_to_cpu(he_op->he_mcs_nss_set);
-
-	/*
-	 * Apparently iPhone 13 (at least iOS version 15.3.1) sets this to all
-	 * zeroes, which is nonsense, and completely inconsistent with itself
-	 * (it doesn't have 8 streams). Accept the settings in this case anyway.
-	 */
-	if (!ap_min_req_set)
-		return true;
-
-	/* make sure the AP is consistent with itself
-	 *
-	 * P802.11-REVme/D0.3
-	 * 26.17.1 Basic HE BSS operation
-	 *
-	 * A STA that is operating in an HE BSS shall be able to receive and
-	 * transmit at each of the <HE-MCS, NSS> tuple values indicated by the
-	 * Basic HE-MCS And NSS Set field of the HE Operation parameter of the
-	 * MLME-START.request primitive and shall be able to receive at each of
-	 * the <HE-MCS, NSS> tuple values indicated by the Supported HE-MCS and
-	 * NSS Set field in the HE Capabilities parameter of the MLMESTART.request
-	 * primitive
-	 */
-	for (nss = 8; nss > 0; nss--) {
-		u8 ap_op_val = (ap_min_req_set >> (2 * (nss - 1))) & 3;
-		u8 ap_rx_val;
-		u8 ap_tx_val;
-
-		if (ap_op_val == IEEE80211_HE_MCS_NOT_SUPPORTED)
-			continue;
-
-		ap_rx_val = (mcs_80_map_rx >> (2 * (nss - 1))) & 3;
-		ap_tx_val = (mcs_80_map_tx >> (2 * (nss - 1))) & 3;
-
-		if (ap_rx_val == IEEE80211_HE_MCS_NOT_SUPPORTED ||
-		    ap_tx_val == IEEE80211_HE_MCS_NOT_SUPPORTED ||
-		    ap_rx_val < ap_op_val || ap_tx_val < ap_op_val) {
-			sdata_info(sdata,
-				   "Invalid rates for %d Nss, rx %d, tx %d oper %d, disable HE\n",
-				   nss, ap_rx_val, ap_rx_val, ap_op_val);
-			return false;
-		}
-	}
-
-	return true;
-}
-
-static bool
-ieee80211_verify_sta_he_mcs_support(struct ieee80211_sub_if_data *sdata,
-				    struct ieee80211_supported_band *sband,
-				    const struct ieee80211_he_operation *he_op)
-{
-	const struct ieee80211_sta_he_cap *sta_he_cap =
-		ieee80211_get_he_iftype_cap_vif(sband, &sdata->vif);
-	u16 ap_min_req_set;
-	int i;
-
-	if (!sta_he_cap || !he_op)
-		return false;
-
-	ap_min_req_set = le16_to_cpu(he_op->he_mcs_nss_set);
-
-	/*
-	 * Apparently iPhone 13 (at least iOS version 15.3.1) sets this to all
-	 * zeroes, which is nonsense, and completely inconsistent with itself
-	 * (it doesn't have 8 streams). Accept the settings in this case anyway.
-	 */
-	if (!ap_min_req_set)
-		return true;
-
-	/* Need to go over for 80MHz, 160MHz and for 80+80 */
-	for (i = 0; i < 3; i++) {
-		const struct ieee80211_he_mcs_nss_supp *sta_mcs_nss_supp =
-			&sta_he_cap->he_mcs_nss_supp;
-		u16 sta_mcs_map_rx =
-			le16_to_cpu(((__le16 *)sta_mcs_nss_supp)[2 * i]);
-		u16 sta_mcs_map_tx =
-			le16_to_cpu(((__le16 *)sta_mcs_nss_supp)[2 * i + 1]);
-		u8 nss;
-		bool verified = true;
-
-		/*
-		 * For each band there is a maximum of 8 spatial streams
-		 * possible. Each of the sta_mcs_map_* is a 16-bit struct built
-		 * of 2 bits per NSS (1-8), with the values defined in enum
-		 * ieee80211_he_mcs_support. Need to make sure STA TX and RX
-		 * capabilities aren't less than the AP's minimum requirements
-		 * for this HE BSS per SS.
-		 * It is enough to find one such band that meets the reqs.
-		 */
-		for (nss = 8; nss > 0; nss--) {
-			u8 sta_rx_val = (sta_mcs_map_rx >> (2 * (nss - 1))) & 3;
-			u8 sta_tx_val = (sta_mcs_map_tx >> (2 * (nss - 1))) & 3;
-			u8 ap_val = (ap_min_req_set >> (2 * (nss - 1))) & 3;
-
-			if (ap_val == IEEE80211_HE_MCS_NOT_SUPPORTED)
-				continue;
-
-			/*
-			 * Make sure the HE AP doesn't require MCSs that aren't
-			 * supported by the client as required by spec
-			 *
-			 * P802.11-REVme/D0.3
-			 * 26.17.1 Basic HE BSS operation
-			 *
-			 * An HE STA shall not attempt to join * (MLME-JOIN.request primitive)
-			 * a BSS, unless it supports (i.e., is able to both transmit and
-			 * receive using) all of the <HE-MCS, NSS> tuples in the basic
-			 * HE-MCS and NSS set.
-			 */
-			if (sta_rx_val == IEEE80211_HE_MCS_NOT_SUPPORTED ||
-			    sta_tx_val == IEEE80211_HE_MCS_NOT_SUPPORTED ||
-			    (ap_val > sta_rx_val) || (ap_val > sta_tx_val)) {
-				verified = false;
-				break;
-			}
-		}
-
-		if (verified)
-			return true;
-	}
-
-	/* If here, STA doesn't meet AP's HE min requirements */
-	return false;
-}
-
-static u8
-ieee80211_get_eht_cap_mcs_nss(const struct ieee80211_sta_he_cap *sta_he_cap,
-			      const struct ieee80211_sta_eht_cap *sta_eht_cap,
-			      unsigned int idx, int bw)
-{
-	u8 he_phy_cap0 = sta_he_cap->he_cap_elem.phy_cap_info[0];
-	u8 eht_phy_cap0 = sta_eht_cap->eht_cap_elem.phy_cap_info[0];
-
-	/* handle us being a 20 MHz-only EHT STA - with four values
-	 * for MCS 0-7, 8-9, 10-11, 12-13.
-	 */
-	if (!(he_phy_cap0 & IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_MASK_ALL))
-		return sta_eht_cap->eht_mcs_nss_supp.only_20mhz.rx_tx_max_nss[idx];
-
-	/* the others have MCS 0-9 together, rather than separately from 0-7 */
-	if (idx > 0)
-		idx--;
-
-	switch (bw) {
-	case 0:
-		return sta_eht_cap->eht_mcs_nss_supp.bw._80.rx_tx_max_nss[idx];
-	case 1:
-		if (!(he_phy_cap0 &
-		      (IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G |
-		       IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G)))
-			return 0xff; /* pass check */
-		return sta_eht_cap->eht_mcs_nss_supp.bw._160.rx_tx_max_nss[idx];
-	case 2:
-		if (!(eht_phy_cap0 & IEEE80211_EHT_PHY_CAP0_320MHZ_IN_6GHZ))
-			return 0xff; /* pass check */
-		return sta_eht_cap->eht_mcs_nss_supp.bw._320.rx_tx_max_nss[idx];
-	}
-
-	WARN_ON(1);
-	return 0;
-}
-
-static bool
-ieee80211_verify_sta_eht_mcs_support(struct ieee80211_sub_if_data *sdata,
-				     struct ieee80211_supported_band *sband,
-				     const struct ieee80211_eht_operation *eht_op)
-{
-	const struct ieee80211_sta_he_cap *sta_he_cap =
-		ieee80211_get_he_iftype_cap_vif(sband, &sdata->vif);
-	const struct ieee80211_sta_eht_cap *sta_eht_cap =
-		ieee80211_get_eht_iftype_cap_vif(sband, &sdata->vif);
-	const struct ieee80211_eht_mcs_nss_supp_20mhz_only *req;
-	unsigned int i;
-
-	if (!sta_he_cap || !sta_eht_cap || !eht_op)
-		return false;
-
-	req = &eht_op->basic_mcs_nss;
-
-	for (i = 0; i < ARRAY_SIZE(req->rx_tx_max_nss); i++) {
-		u8 req_rx_nss, req_tx_nss;
-		unsigned int bw;
-
-		req_rx_nss = u8_get_bits(req->rx_tx_max_nss[i],
-					 IEEE80211_EHT_MCS_NSS_RX);
-		req_tx_nss = u8_get_bits(req->rx_tx_max_nss[i],
-					 IEEE80211_EHT_MCS_NSS_TX);
-
-		for (bw = 0; bw < 3; bw++) {
-			u8 have, have_rx_nss, have_tx_nss;
-
-			have = ieee80211_get_eht_cap_mcs_nss(sta_he_cap,
-							     sta_eht_cap,
-							     i, bw);
-			have_rx_nss = u8_get_bits(have,
-						  IEEE80211_EHT_MCS_NSS_RX);
-			have_tx_nss = u8_get_bits(have,
-						  IEEE80211_EHT_MCS_NSS_TX);
-
-			if (req_rx_nss > have_rx_nss ||
-			    req_tx_nss > have_tx_nss)
-				return false;
-		}
-	}
-
-	return true;
-}
-
-static int ieee80211_prep_channel(struct ieee80211_sub_if_data *sdata,
-				  struct ieee80211_link_data *link,
-				  struct cfg80211_bss *cbss,
-				  ieee80211_conn_flags_t *conn_flags)
-{
-	struct ieee80211_local *local = sdata->local;
-	const struct ieee80211_ht_cap *ht_cap = NULL;
-	const struct ieee80211_ht_operation *ht_oper = NULL;
-	const struct ieee80211_vht_operation *vht_oper = NULL;
-	const struct ieee80211_he_operation *he_oper = NULL;
-	const struct ieee80211_eht_operation *eht_oper = NULL;
-	const struct ieee80211_s1g_oper_ie *s1g_oper = NULL;
-	struct ieee80211_supported_band *sband;
-	struct cfg80211_chan_def chandef;
-	bool is_6ghz = cbss->channel->band == NL80211_BAND_6GHZ;
-	bool is_5ghz = cbss->channel->band == NL80211_BAND_5GHZ;
-	struct ieee80211_bss *bss = (void *)cbss->priv;
-	struct ieee80211_elems_parse_params parse_params = {
-		.link_id = -1,
-		.from_ap = true,
-	};
-	struct ieee802_11_elems *elems;
-	const struct cfg80211_bss_ies *ies;
-	int ret;
-	u32 i;
-	bool have_80mhz;
-
-	rcu_read_lock();
-
-	ies = rcu_dereference(cbss->ies);
-	parse_params.start = ies->data;
-	parse_params.len = ies->len;
-	elems = ieee802_11_parse_elems_full(&parse_params);
-	if (!elems) {
-		rcu_read_unlock();
-		return -ENOMEM;
-	}
-
-	sband = local->hw.wiphy->bands[cbss->channel->band];
-
-	*conn_flags &= ~(IEEE80211_CONN_DISABLE_40MHZ |
-			 IEEE80211_CONN_DISABLE_80P80MHZ |
-			 IEEE80211_CONN_DISABLE_160MHZ);
-
-	/* disable HT/VHT/HE if we don't support them */
-	if (!sband->ht_cap.ht_supported && !is_6ghz) {
-		mlme_dbg(sdata, "HT not supported, disabling HT/VHT/HE/EHT\n");
-		*conn_flags |= IEEE80211_CONN_DISABLE_HT;
-		*conn_flags |= IEEE80211_CONN_DISABLE_VHT;
-		*conn_flags |= IEEE80211_CONN_DISABLE_HE;
-		*conn_flags |= IEEE80211_CONN_DISABLE_EHT;
-	}
-
-	if (!sband->vht_cap.vht_supported && is_5ghz) {
-		mlme_dbg(sdata, "VHT not supported, disabling VHT/HE/EHT\n");
-		*conn_flags |= IEEE80211_CONN_DISABLE_VHT;
-		*conn_flags |= IEEE80211_CONN_DISABLE_HE;
-		*conn_flags |= IEEE80211_CONN_DISABLE_EHT;
-	}
-
-	if (!ieee80211_get_he_iftype_cap_vif(sband, &sdata->vif)) {
-		mlme_dbg(sdata, "HE not supported, disabling HE and EHT\n");
-		*conn_flags |= IEEE80211_CONN_DISABLE_HE;
-		*conn_flags |= IEEE80211_CONN_DISABLE_EHT;
-	}
-
-	if (!ieee80211_get_eht_iftype_cap_vif(sband, &sdata->vif)) {
-		mlme_dbg(sdata, "EHT not supported, disabling EHT\n");
-		*conn_flags |= IEEE80211_CONN_DISABLE_EHT;
-	}
-
-	if (!(*conn_flags & IEEE80211_CONN_DISABLE_HT) && !is_6ghz) {
-		ht_oper = elems->ht_operation;
-		ht_cap = elems->ht_cap_elem;
-
-		if (!ht_cap) {
-			*conn_flags |= IEEE80211_CONN_DISABLE_HT;
-			ht_oper = NULL;
-		}
-	}
-
-	if (!(*conn_flags & IEEE80211_CONN_DISABLE_VHT) && !is_6ghz) {
-		vht_oper = elems->vht_operation;
-		if (vht_oper && !ht_oper) {
-			vht_oper = NULL;
-			sdata_info(sdata,
-				   "AP advertised VHT without HT, disabling HT/VHT/HE\n");
-			*conn_flags |= IEEE80211_CONN_DISABLE_HT;
-			*conn_flags |= IEEE80211_CONN_DISABLE_VHT;
-			*conn_flags |= IEEE80211_CONN_DISABLE_HE;
-			*conn_flags |= IEEE80211_CONN_DISABLE_EHT;
-		}
-
-		if (!elems->vht_cap_elem) {
-			*conn_flags |= IEEE80211_CONN_DISABLE_VHT;
-			vht_oper = NULL;
-		}
-	}
-
-	if (!(*conn_flags & IEEE80211_CONN_DISABLE_HE)) {
-		he_oper = elems->he_operation;
-
-		if (link && is_6ghz) {
-			struct ieee80211_bss_conf *bss_conf;
-			u8 j = 0;
-
-			bss_conf = link->conf;
-
-			if (elems->pwr_constr_elem)
-				bss_conf->pwr_reduction = *elems->pwr_constr_elem;
-
-			BUILD_BUG_ON(ARRAY_SIZE(bss_conf->tx_pwr_env) !=
-				     ARRAY_SIZE(elems->tx_pwr_env));
-
-			for (i = 0; i < elems->tx_pwr_env_num; i++) {
-				if (elems->tx_pwr_env_len[i] >
-				    sizeof(bss_conf->tx_pwr_env[j]))
-					continue;
-
-				bss_conf->tx_pwr_env_num++;
-				memcpy(&bss_conf->tx_pwr_env[j], elems->tx_pwr_env[i],
-				       elems->tx_pwr_env_len[i]);
-				j++;
-			}
-		}
-
-		if (!ieee80211_verify_peer_he_mcs_support(sdata, ies, he_oper) ||
-		    !ieee80211_verify_sta_he_mcs_support(sdata, sband, he_oper))
-			*conn_flags |= IEEE80211_CONN_DISABLE_HE |
-				       IEEE80211_CONN_DISABLE_EHT;
-	}
-
-	/*
-	 * EHT requires HE to be supported as well. Specifically for 6 GHz
-	 * channels, the operation channel information can only be deduced from
-	 * both the 6 GHz operation information (from the HE operation IE) and
-	 * EHT operation.
-	 */
-	if (!(*conn_flags &
-			(IEEE80211_CONN_DISABLE_HE |
-			 IEEE80211_CONN_DISABLE_EHT)) &&
-	    he_oper) {
-		const struct cfg80211_bss_ies *cbss_ies;
-		const struct element *eht_ml_elem;
-		const u8 *eht_oper_ie;
-
-		cbss_ies = rcu_dereference(cbss->ies);
-		eht_oper_ie = cfg80211_find_ext_ie(WLAN_EID_EXT_EHT_OPERATION,
-						   cbss_ies->data, cbss_ies->len);
-		if (eht_oper_ie && eht_oper_ie[1] >=
-		    1 + sizeof(struct ieee80211_eht_operation))
-			eht_oper = (void *)(eht_oper_ie + 3);
-		else
-			eht_oper = NULL;
-
-		if (!ieee80211_verify_sta_eht_mcs_support(sdata, sband, eht_oper))
-			*conn_flags |= IEEE80211_CONN_DISABLE_EHT;
-
-		eht_ml_elem = cfg80211_find_ext_elem(WLAN_EID_EXT_EHT_MULTI_LINK,
-						     cbss_ies->data, cbss_ies->len);
-
-		/* data + 1 / datalen - 1 since it's an extended element */
-		if (!(*conn_flags & IEEE80211_CONN_DISABLE_EHT) &&
-		    eht_ml_elem &&
-		    ieee80211_mle_type_ok(eht_ml_elem->data + 1,
-					  IEEE80211_ML_CONTROL_TYPE_BASIC,
-					  eht_ml_elem->datalen - 1)) {
-			sdata->vif.cfg.eml_cap =
-				ieee80211_mle_get_eml_cap(eht_ml_elem->data + 1);
-			sdata->vif.cfg.eml_med_sync_delay =
-				ieee80211_mle_get_eml_med_sync_delay(eht_ml_elem->data + 1);
-		}
-	}
-
-	/* Allow VHT if at least one channel on the sband supports 80 MHz */
-	have_80mhz = false;
-	for (i = 0; i < sband->n_channels; i++) {
-		if (sband->channels[i].flags & (IEEE80211_CHAN_DISABLED |
-						IEEE80211_CHAN_NO_80MHZ))
-			continue;
-
-		have_80mhz = true;
-		break;
-	}
-
-	if (!have_80mhz) {
-		sdata_info(sdata, "80 MHz not supported, disabling VHT\n");
-		*conn_flags |= IEEE80211_CONN_DISABLE_VHT;
-	}
-
-	if (sband->band == NL80211_BAND_S1GHZ) {
-		s1g_oper = elems->s1g_oper;
-		if (!s1g_oper)
-			sdata_info(sdata,
-				   "AP missing S1G operation element?\n");
-	}
-
-	*conn_flags |=
-		ieee80211_determine_chantype(sdata, link, *conn_flags,
-					     sband,
-					     cbss->channel,
-					     bss->vht_cap_info,
-					     ht_oper, vht_oper,
-					     he_oper, eht_oper,
-					     s1g_oper,
-					     &chandef, false);
-
-	if (link)
-		link->needed_rx_chains =
-			min(ieee80211_max_rx_chains(link, cbss),
-			    local->rx_chains);
-
-	rcu_read_unlock();
-	/* the element data was RCU protected so no longer valid anyway */
-	kfree(elems);
-	elems = NULL;
-
-	if (*conn_flags & IEEE80211_CONN_DISABLE_HE && is_6ghz) {
-		sdata_info(sdata, "Rejecting non-HE 6/7 GHz connection");
-		return -EINVAL;
-	}
-
-	if (!link)
-		return 0;
-
-	/* will change later if needed */
-	link->smps_mode = IEEE80211_SMPS_OFF;
-
-	mutex_lock(&local->mtx);
-	/*
-	 * If this fails (possibly due to channel context sharing
-	 * on incompatible channels, e.g. 80+80 and 160 sharing the
-	 * same control channel) try to use a smaller bandwidth.
-	 */
-	ret = ieee80211_link_use_channel(link, &chandef,
-					 IEEE80211_CHANCTX_SHARED);
-
-	/* don't downgrade for 5 and 10 MHz channels, though. */
-	if (chandef.width == NL80211_CHAN_WIDTH_5 ||
-	    chandef.width == NL80211_CHAN_WIDTH_10)
-		goto out;
-
-	while (ret && chandef.width != NL80211_CHAN_WIDTH_20_NOHT) {
-		*conn_flags |=
-			ieee80211_chandef_downgrade(&chandef);
-		ret = ieee80211_link_use_channel(link, &chandef,
-						 IEEE80211_CHANCTX_SHARED);
-	}
- out:
-	mutex_unlock(&local->mtx);
-	return ret;
-}
-
-static bool ieee80211_get_dtim(const struct cfg80211_bss_ies *ies,
-			       u8 *dtim_count, u8 *dtim_period)
-{
-	const u8 *tim_ie = cfg80211_find_ie(WLAN_EID_TIM, ies->data, ies->len);
-	const u8 *idx_ie = cfg80211_find_ie(WLAN_EID_MULTI_BSSID_IDX, ies->data,
-					 ies->len);
-	const struct ieee80211_tim_ie *tim = NULL;
-	const struct ieee80211_bssid_index *idx;
-	bool valid = tim_ie && tim_ie[1] >= 2;
-
-	if (valid)
-		tim = (void *)(tim_ie + 2);
-
-	if (dtim_count)
-		*dtim_count = valid ? tim->dtim_count : 0;
-
-	if (dtim_period)
-		*dtim_period = valid ? tim->dtim_period : 0;
-
-	/* Check if value is overridden by non-transmitted profile */
-	if (!idx_ie || idx_ie[1] < 3)
-		return valid;
-
-	idx = (void *)(idx_ie + 2);
-
-	if (dtim_count)
-		*dtim_count = idx->dtim_count;
-
-	if (dtim_period)
-		*dtim_period = idx->dtim_period;
-
-	return true;
-}
-
-static bool ieee80211_assoc_success(struct ieee80211_sub_if_data *sdata,
-				    struct ieee80211_mgmt *mgmt,
-				    struct ieee802_11_elems *elems,
-				    const u8 *elem_start, unsigned int elem_len)
-{
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-	struct ieee80211_mgd_assoc_data *assoc_data = ifmgd->assoc_data;
-	struct ieee80211_local *local = sdata->local;
-	unsigned int link_id;
-	struct sta_info *sta;
-	u64 changed[IEEE80211_MLD_MAX_NUM_LINKS] = {};
-	u16 valid_links = 0, dormant_links = 0;
-	int err;
-
-	mutex_lock(&sdata->local->sta_mtx);
-	/*
-	 * station info was already allocated and inserted before
-	 * the association and should be available to us
-	 */
-	sta = sta_info_get(sdata, assoc_data->ap_addr);
-	if (WARN_ON(!sta))
-		goto out_err;
-
-	if (ieee80211_vif_is_mld(&sdata->vif)) {
-		for (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {
-			if (!assoc_data->link[link_id].bss)
-				continue;
-
-			valid_links |= BIT(link_id);
-			if (assoc_data->link[link_id].disabled)
-				dormant_links |= BIT(link_id);
-
-			if (link_id != assoc_data->assoc_link_id) {
-				err = ieee80211_sta_allocate_link(sta, link_id);
-				if (err)
-					goto out_err;
-			}
-		}
-
-		ieee80211_vif_set_links(sdata, valid_links, dormant_links);
-	}
-
-	for (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {
-		struct cfg80211_bss *cbss = assoc_data->link[link_id].bss;
-		struct ieee80211_link_data *link;
-		struct link_sta_info *link_sta;
-
-		if (!cbss)
-			continue;
-
-		link = sdata_dereference(sdata->link[link_id], sdata);
-		if (WARN_ON(!link))
-			goto out_err;
-
-		if (ieee80211_vif_is_mld(&sdata->vif))
-			link_info(link,
-				  "local address %pM, AP link address %pM%s\n",
-				  link->conf->addr,
-				  assoc_data->link[link_id].bss->bssid,
-				  link_id == assoc_data->assoc_link_id ?
-					" (assoc)" : "");
-
-		link_sta = rcu_dereference_protected(sta->link[link_id],
-						     lockdep_is_held(&local->sta_mtx));
-		if (WARN_ON(!link_sta))
-			goto out_err;
-
-		if (!link->u.mgd.have_beacon) {
-			const struct cfg80211_bss_ies *ies;
-
-			rcu_read_lock();
-			ies = rcu_dereference(cbss->beacon_ies);
-			if (ies)
-				link->u.mgd.have_beacon = true;
-			else
-				ies = rcu_dereference(cbss->ies);
-			ieee80211_get_dtim(ies,
-					   &link->conf->sync_dtim_count,
-					   &link->u.mgd.dtim_period);
-			link->conf->beacon_int = cbss->beacon_interval;
-			rcu_read_unlock();
-		}
-
-		link->conf->dtim_period = link->u.mgd.dtim_period ?: 1;
-
-		if (link_id != assoc_data->assoc_link_id) {
-			err = ieee80211_prep_channel(sdata, link, cbss,
-						     &link->u.mgd.conn_flags);
-			if (err) {
-				link_info(link, "prep_channel failed\n");
-				goto out_err;
-			}
-		}
-
-		err = ieee80211_mgd_setup_link_sta(link, sta, link_sta,
-						   assoc_data->link[link_id].bss);
-		if (err)
-			goto out_err;
-
-		if (!ieee80211_assoc_config_link(link, link_sta,
-						 assoc_data->link[link_id].bss,
-						 mgmt, elem_start, elem_len,
-						 &changed[link_id]))
-			goto out_err;
-
-		if (assoc_data->link[link_id].status != WLAN_STATUS_SUCCESS) {
-			valid_links &= ~BIT(link_id);
-			ieee80211_sta_remove_link(sta, link_id);
-			continue;
-		}
-
-		if (link_id != assoc_data->assoc_link_id) {
-			err = ieee80211_sta_activate_link(sta, link_id);
-			if (err)
-				goto out_err;
-		}
-	}
-
-	/* links might have changed due to rejected ones, set them again */
-	ieee80211_vif_set_links(sdata, valid_links, dormant_links);
-
-	rate_control_rate_init(sta);
-
-	if (ifmgd->flags & IEEE80211_STA_MFP_ENABLED) {
-		set_sta_flag(sta, WLAN_STA_MFP);
-		sta->sta.mfp = true;
-	} else {
-		sta->sta.mfp = false;
-	}
-
-	ieee80211_sta_set_max_amsdu_subframes(sta, elems->ext_capab,
-					      elems->ext_capab_len);
-
-	sta->sta.wme = (elems->wmm_param || elems->s1g_capab) &&
-		       local->hw.queues >= IEEE80211_NUM_ACS;
-
-	err = sta_info_move_state(sta, IEEE80211_STA_ASSOC);
-	if (!err && !(ifmgd->flags & IEEE80211_STA_CONTROL_PORT))
-		err = sta_info_move_state(sta, IEEE80211_STA_AUTHORIZED);
-	if (err) {
-		sdata_info(sdata,
-			   "failed to move station %pM to desired state\n",
-			   sta->sta.addr);
-		WARN_ON(__sta_info_destroy(sta));
-		goto out_err;
-	}
-
-	if (sdata->wdev.use_4addr)
-		drv_sta_set_4addr(local, sdata, &sta->sta, true);
-
-	mutex_unlock(&sdata->local->sta_mtx);
-
-	ieee80211_set_associated(sdata, assoc_data, changed);
-
-	/*
-	 * If we're using 4-addr mode, let the AP know that we're
-	 * doing so, so that it can create the STA VLAN on its side
-	 */
-	if (ifmgd->use_4addr)
-		ieee80211_send_4addr_nullfunc(local, sdata);
-
-	/*
-	 * Start timer to probe the connection to the AP now.
-	 * Also start the timer that will detect beacon loss.
-	 */
-	ieee80211_sta_reset_beacon_monitor(sdata);
-	ieee80211_sta_reset_conn_monitor(sdata);
-
-	return true;
-out_err:
-	eth_zero_addr(sdata->vif.cfg.ap_addr);
-	mutex_unlock(&sdata->local->sta_mtx);
-	return false;
-}
-
-static void ieee80211_rx_mgmt_assoc_resp(struct ieee80211_sub_if_data *sdata,
-					 struct ieee80211_mgmt *mgmt,
-					 size_t len)
-{
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-	struct ieee80211_mgd_assoc_data *assoc_data = ifmgd->assoc_data;
-	u16 capab_info, status_code, aid;
-	struct ieee80211_elems_parse_params parse_params = {
-		.bss = NULL,
-		.link_id = -1,
-		.from_ap = true,
-	};
-	struct ieee802_11_elems *elems;
-	int ac;
-	const u8 *elem_start;
-	unsigned int elem_len;
-	bool reassoc;
-	struct ieee80211_event event = {
-		.type = MLME_EVENT,
-		.u.mlme.data = ASSOC_EVENT,
-	};
-	struct ieee80211_prep_tx_info info = {};
-	struct cfg80211_rx_assoc_resp resp = {
-		.uapsd_queues = -1,
-	};
-	u8 ap_mld_addr[ETH_ALEN] __aligned(2);
-	unsigned int link_id;
-
-	sdata_assert_lock(sdata);
-
-	if (!assoc_data)
-		return;
-
-	if (!ether_addr_equal(assoc_data->ap_addr, mgmt->bssid) ||
-	    !ether_addr_equal(assoc_data->ap_addr, mgmt->sa))
-		return;
-
-	/*
-	 * AssocResp and ReassocResp have identical structure, so process both
-	 * of them in this function.
-	 */
-
-	if (len < 24 + 6)
-		return;
-
-	reassoc = ieee80211_is_reassoc_resp(mgmt->frame_control);
-	capab_info = le16_to_cpu(mgmt->u.assoc_resp.capab_info);
-	status_code = le16_to_cpu(mgmt->u.assoc_resp.status_code);
-	if (assoc_data->s1g)
-		elem_start = mgmt->u.s1g_assoc_resp.variable;
-	else
-		elem_start = mgmt->u.assoc_resp.variable;
-
-	/*
-	 * Note: this may not be perfect, AP might misbehave - if
-	 * anyone needs to rely on perfect complete notification
-	 * with the exact right subtype, then we need to track what
-	 * we actually transmitted.
-	 */
-	info.subtype = reassoc ? IEEE80211_STYPE_REASSOC_REQ :
-				 IEEE80211_STYPE_ASSOC_REQ;
-
-	if (assoc_data->fils_kek_len &&
-	    fils_decrypt_assoc_resp(sdata, (u8 *)mgmt, &len, assoc_data) < 0)
-		return;
-
-	elem_len = len - (elem_start - (u8 *)mgmt);
-	parse_params.start = elem_start;
-	parse_params.len = elem_len;
-	elems = ieee802_11_parse_elems_full(&parse_params);
-	if (!elems)
-		goto notify_driver;
-
-	if (elems->aid_resp)
-		aid = le16_to_cpu(elems->aid_resp->aid);
-	else if (assoc_data->s1g)
-		aid = 0; /* TODO */
-	else
-		aid = le16_to_cpu(mgmt->u.assoc_resp.aid);
-
-	/*
-	 * The 5 MSB of the AID field are reserved
-	 * (802.11-2016 9.4.1.8 AID field)
-	 */
-	aid &= 0x7ff;
-
-	sdata_info(sdata,
-		   "RX %sssocResp from %pM (capab=0x%x status=%d aid=%d)\n",
-		   reassoc ? "Rea" : "A", assoc_data->ap_addr,
-		   capab_info, status_code, (u16)(aid & ~(BIT(15) | BIT(14))));
-
-	ifmgd->broken_ap = false;
-
-	if (status_code == WLAN_STATUS_ASSOC_REJECTED_TEMPORARILY &&
-	    elems->timeout_int &&
-	    elems->timeout_int->type == WLAN_TIMEOUT_ASSOC_COMEBACK) {
-		u32 tu, ms;
-
-		cfg80211_assoc_comeback(sdata->dev, assoc_data->ap_addr,
-					le32_to_cpu(elems->timeout_int->value));
-
-		tu = le32_to_cpu(elems->timeout_int->value);
-		ms = tu * 1024 / 1000;
-		sdata_info(sdata,
-			   "%pM rejected association temporarily; comeback duration %u TU (%u ms)\n",
-			   assoc_data->ap_addr, tu, ms);
-		assoc_data->timeout = jiffies + msecs_to_jiffies(ms);
-		assoc_data->timeout_started = true;
-		if (ms > IEEE80211_ASSOC_TIMEOUT)
-			run_again(sdata, assoc_data->timeout);
-		goto notify_driver;
-	}
-
-	if (status_code != WLAN_STATUS_SUCCESS) {
-		sdata_info(sdata, "%pM denied association (code=%d)\n",
-			   assoc_data->ap_addr, status_code);
-		event.u.mlme.status = MLME_DENIED;
-		event.u.mlme.reason = status_code;
-		drv_event_callback(sdata->local, sdata, &event);
-	} else {
-		if (aid == 0 || aid > IEEE80211_MAX_AID) {
-			sdata_info(sdata,
-				   "invalid AID value %d (out of range), turn off PS\n",
-				   aid);
-			aid = 0;
-			ifmgd->broken_ap = true;
-		}
-
-		if (ieee80211_vif_is_mld(&sdata->vif)) {
-			if (!elems->ml_basic) {
-				sdata_info(sdata,
-					   "MLO association with %pM but no multi-link element in response!\n",
-					   assoc_data->ap_addr);
-				goto abandon_assoc;
-			}
-
-			if (le16_get_bits(elems->ml_basic->control,
-					  IEEE80211_ML_CONTROL_TYPE) !=
-					IEEE80211_ML_CONTROL_TYPE_BASIC) {
-				sdata_info(sdata,
-					   "bad multi-link element (control=0x%x)\n",
-					   le16_to_cpu(elems->ml_basic->control));
-				goto abandon_assoc;
-			} else {
-				struct ieee80211_mle_basic_common_info *common;
-
-				common = (void *)elems->ml_basic->variable;
-
-				if (memcmp(assoc_data->ap_addr,
-					   common->mld_mac_addr, ETH_ALEN)) {
-					sdata_info(sdata,
-						   "AP MLD MAC address mismatch: got %pM expected %pM\n",
-						   common->mld_mac_addr,
-						   assoc_data->ap_addr);
-					goto abandon_assoc;
-				}
-			}
-		}
-
-		sdata->vif.cfg.aid = aid;
-
-		if (!ieee80211_assoc_success(sdata, mgmt, elems,
-					     elem_start, elem_len)) {
-			/* oops -- internal error -- send timeout for now */
-			ieee80211_destroy_assoc_data(sdata, ASSOC_TIMEOUT);
-			goto notify_driver;
-		}
-		event.u.mlme.status = MLME_SUCCESS;
-		drv_event_callback(sdata->local, sdata, &event);
-		sdata_info(sdata, "associated\n");
-
-		info.success = 1;
-	}
-
-	for (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {
-		struct ieee80211_link_data *link;
-
-		if (!assoc_data->link[link_id].bss)
-			continue;
-
-		resp.links[link_id].bss = assoc_data->link[link_id].bss;
-		ether_addr_copy(resp.links[link_id].addr,
-				assoc_data->link[link_id].addr);
-		resp.links[link_id].status = assoc_data->link[link_id].status;
-
-		link = sdata_dereference(sdata->link[link_id], sdata);
-		if (!link)
-			continue;
-
-		/* get uapsd queues configuration - same for all links */
-		resp.uapsd_queues = 0;
-		for (ac = 0; ac < IEEE80211_NUM_ACS; ac++)
-			if (link->tx_conf[ac].uapsd)
-				resp.uapsd_queues |= ieee80211_ac_to_qos_mask[ac];
-	}
-
-	if (ieee80211_vif_is_mld(&sdata->vif)) {
-		ether_addr_copy(ap_mld_addr, sdata->vif.cfg.ap_addr);
-		resp.ap_mld_addr = ap_mld_addr;
-	}
-
-	ieee80211_destroy_assoc_data(sdata,
-				     status_code == WLAN_STATUS_SUCCESS ?
-					ASSOC_SUCCESS :
-					ASSOC_REJECTED);
-
-	resp.buf = (u8 *)mgmt;
-	resp.len = len;
-	resp.req_ies = ifmgd->assoc_req_ies;
-	resp.req_ies_len = ifmgd->assoc_req_ies_len;
-	cfg80211_rx_assoc_resp(sdata->dev, &resp);
-notify_driver:
-	drv_mgd_complete_tx(sdata->local, sdata, &info);
-	kfree(elems);
-	return;
-abandon_assoc:
-	ieee80211_destroy_assoc_data(sdata, ASSOC_ABANDON);
-	goto notify_driver;
-}
-
-static void ieee80211_rx_bss_info(struct ieee80211_link_data *link,
-				  struct ieee80211_mgmt *mgmt, size_t len,
-				  struct ieee80211_rx_status *rx_status)
-{
-	struct ieee80211_sub_if_data *sdata = link->sdata;
-	struct ieee80211_local *local = sdata->local;
-	struct ieee80211_bss *bss;
-	struct ieee80211_channel *channel;
-
-	sdata_assert_lock(sdata);
-
-	channel = ieee80211_get_channel_khz(local->hw.wiphy,
-					ieee80211_rx_status_to_khz(rx_status));
-	if (!channel)
-		return;
-
-	bss = ieee80211_bss_info_update(local, rx_status, mgmt, len, channel);
-	if (bss) {
-		link->conf->beacon_rate = bss->beacon_rate;
-		ieee80211_rx_bss_put(local, bss);
-	}
-}
-
-
-static void ieee80211_rx_mgmt_probe_resp(struct ieee80211_link_data *link,
-					 struct sk_buff *skb)
-{
-	struct ieee80211_sub_if_data *sdata = link->sdata;
-	struct ieee80211_mgmt *mgmt = (void *)skb->data;
-	struct ieee80211_if_managed *ifmgd;
-	struct ieee80211_rx_status *rx_status = (void *) skb->cb;
-	struct ieee80211_channel *channel;
-	size_t baselen, len = skb->len;
-
-	ifmgd = &sdata->u.mgd;
-
-	sdata_assert_lock(sdata);
-
-	/*
-	 * According to Draft P802.11ax D6.0 clause 26.17.2.3.2:
-	 * "If a 6 GHz AP receives a Probe Request frame  and responds with
-	 * a Probe Response frame [..], the Address 1 field of the Probe
-	 * Response frame shall be set to the broadcast address [..]"
-	 * So, on 6GHz band we should also accept broadcast responses.
-	 */
-	channel = ieee80211_get_channel(sdata->local->hw.wiphy,
-					rx_status->freq);
-	if (!channel)
-		return;
-
-	if (!ether_addr_equal(mgmt->da, sdata->vif.addr) &&
-	    (channel->band != NL80211_BAND_6GHZ ||
-	     !is_broadcast_ether_addr(mgmt->da)))
-		return; /* ignore ProbeResp to foreign address */
-
-	baselen = (u8 *) mgmt->u.probe_resp.variable - (u8 *) mgmt;
-	if (baselen > len)
-		return;
-
-	ieee80211_rx_bss_info(link, mgmt, len, rx_status);
-
-	if (ifmgd->associated &&
-	    ether_addr_equal(mgmt->bssid, link->u.mgd.bssid))
-		ieee80211_reset_ap_probe(sdata);
-}
-
-/*
- * This is the canonical list of information elements we care about,
- * the filter code also gives us all changes to the Microsoft OUI
- * (00:50:F2) vendor IE which is used for WMM which we need to track,
- * as well as the DTPC IE (part of the Cisco OUI) used for signaling
- * changes to requested client power.
- *
- * We implement beacon filtering in software since that means we can
- * avoid processing the frame here and in cfg80211, and userspace
- * will not be able to tell whether the hardware supports it or not.
- *
- * XXX: This list needs to be dynamic -- userspace needs to be able to
- *	add items it requires. It also needs to be able to tell us to
- *	look out for other vendor IEs.
- */
-static const u64 care_about_ies =
-	(1ULL << WLAN_EID_COUNTRY) |
-	(1ULL << WLAN_EID_ERP_INFO) |
-	(1ULL << WLAN_EID_CHANNEL_SWITCH) |
-	(1ULL << WLAN_EID_PWR_CONSTRAINT) |
-	(1ULL << WLAN_EID_HT_CAPABILITY) |
-	(1ULL << WLAN_EID_HT_OPERATION) |
-	(1ULL << WLAN_EID_EXT_CHANSWITCH_ANN);
-
-static void ieee80211_handle_beacon_sig(struct ieee80211_link_data *link,
-					struct ieee80211_if_managed *ifmgd,
-					struct ieee80211_bss_conf *bss_conf,
-					struct ieee80211_local *local,
-					struct ieee80211_rx_status *rx_status)
-{
-	struct ieee80211_sub_if_data *sdata = link->sdata;
-
-	/* Track average RSSI from the Beacon frames of the current AP */
-
-	if (!link->u.mgd.tracking_signal_avg) {
-		link->u.mgd.tracking_signal_avg = true;
-		ewma_beacon_signal_init(&link->u.mgd.ave_beacon_signal);
-		link->u.mgd.last_cqm_event_signal = 0;
-		link->u.mgd.count_beacon_signal = 1;
-		link->u.mgd.last_ave_beacon_signal = 0;
-	} else {
-		link->u.mgd.count_beacon_signal++;
-	}
-
-	ewma_beacon_signal_add(&link->u.mgd.ave_beacon_signal,
-			       -rx_status->signal);
-
-	if (ifmgd->rssi_min_thold != ifmgd->rssi_max_thold &&
-	    link->u.mgd.count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT) {
-		int sig = -ewma_beacon_signal_read(&link->u.mgd.ave_beacon_signal);
-		int last_sig = link->u.mgd.last_ave_beacon_signal;
-		struct ieee80211_event event = {
-			.type = RSSI_EVENT,
-		};
-
-		/*
-		 * if signal crosses either of the boundaries, invoke callback
-		 * with appropriate parameters
-		 */
-		if (sig > ifmgd->rssi_max_thold &&
-		    (last_sig <= ifmgd->rssi_min_thold || last_sig == 0)) {
-			link->u.mgd.last_ave_beacon_signal = sig;
-			event.u.rssi.data = RSSI_EVENT_HIGH;
-			drv_event_callback(local, sdata, &event);
-		} else if (sig < ifmgd->rssi_min_thold &&
-			   (last_sig >= ifmgd->rssi_max_thold ||
-			   last_sig == 0)) {
-			link->u.mgd.last_ave_beacon_signal = sig;
-			event.u.rssi.data = RSSI_EVENT_LOW;
-			drv_event_callback(local, sdata, &event);
-		}
-	}
-
-	if (bss_conf->cqm_rssi_thold &&
-	    link->u.mgd.count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT &&
-	    !(sdata->vif.driver_flags & IEEE80211_VIF_SUPPORTS_CQM_RSSI)) {
-		int sig = -ewma_beacon_signal_read(&link->u.mgd.ave_beacon_signal);
-		int last_event = link->u.mgd.last_cqm_event_signal;
-		int thold = bss_conf->cqm_rssi_thold;
-		int hyst = bss_conf->cqm_rssi_hyst;
-
-		if (sig < thold &&
-		    (last_event == 0 || sig < last_event - hyst)) {
-			link->u.mgd.last_cqm_event_signal = sig;
-			ieee80211_cqm_rssi_notify(
-				&sdata->vif,
-				NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW,
-				sig, GFP_KERNEL);
-		} else if (sig > thold &&
-			   (last_event == 0 || sig > last_event + hyst)) {
-			link->u.mgd.last_cqm_event_signal = sig;
-			ieee80211_cqm_rssi_notify(
-				&sdata->vif,
-				NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH,
-				sig, GFP_KERNEL);
-		}
-	}
-
-	if (bss_conf->cqm_rssi_low &&
-	    link->u.mgd.count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT) {
-		int sig = -ewma_beacon_signal_read(&link->u.mgd.ave_beacon_signal);
-		int last_event = link->u.mgd.last_cqm_event_signal;
-		int low = bss_conf->cqm_rssi_low;
-		int high = bss_conf->cqm_rssi_high;
-
-		if (sig < low &&
-		    (last_event == 0 || last_event >= low)) {
-			link->u.mgd.last_cqm_event_signal = sig;
-			ieee80211_cqm_rssi_notify(
-				&sdata->vif,
-				NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW,
-				sig, GFP_KERNEL);
-		} else if (sig > high &&
-			   (last_event == 0 || last_event <= high)) {
-			link->u.mgd.last_cqm_event_signal = sig;
-			ieee80211_cqm_rssi_notify(
-				&sdata->vif,
-				NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH,
-				sig, GFP_KERNEL);
-		}
-	}
-}
-
-static bool ieee80211_rx_our_beacon(const u8 *tx_bssid,
-				    struct cfg80211_bss *bss)
-{
-	if (ether_addr_equal(tx_bssid, bss->bssid))
-		return true;
-	if (!bss->transmitted_bss)
-		return false;
-	return ether_addr_equal(tx_bssid, bss->transmitted_bss->bssid);
-}
-
-static bool ieee80211_config_puncturing(struct ieee80211_link_data *link,
-					const struct ieee80211_eht_operation *eht_oper,
-					u64 *changed)
-{
-	u16 bitmap = 0, extracted;
-
-	if ((eht_oper->params & IEEE80211_EHT_OPER_INFO_PRESENT) &&
-	    (eht_oper->params &
-	     IEEE80211_EHT_OPER_DISABLED_SUBCHANNEL_BITMAP_PRESENT)) {
-		const struct ieee80211_eht_operation_info *info =
-			(void *)eht_oper->optional;
-		const u8 *disable_subchannel_bitmap = info->optional;
-
-		bitmap = get_unaligned_le16(disable_subchannel_bitmap);
-	}
-
-	extracted = ieee80211_extract_dis_subch_bmap(eht_oper,
-						     &link->conf->chandef,
-						     bitmap);
-
-	/* accept if there are no changes */
-	if (!(*changed & BSS_CHANGED_BANDWIDTH) &&
-	    extracted == link->conf->eht_puncturing)
-		return true;
-
-	if (!cfg80211_valid_disable_subchannel_bitmap(&bitmap,
-						      &link->conf->chandef)) {
-		link_info(link,
-			  "Got an invalid disable subchannel bitmap from AP %pM: bitmap = 0x%x, bw = 0x%x. disconnect\n",
-			  link->u.mgd.bssid,
-			  bitmap,
-			  link->conf->chandef.width);
-		return false;
-	}
-
-	ieee80211_handle_puncturing_bitmap(link, eht_oper, bitmap, changed);
-	return true;
-}
-
-static void ieee80211_ml_reconf_work(struct wiphy *wiphy,
-				     struct wiphy_work *work)
-{
-	struct ieee80211_sub_if_data *sdata =
-		container_of(work, struct ieee80211_sub_if_data,
-			     u.mgd.ml_reconf_work.work);
-	u16 new_valid_links, new_active_links, new_dormant_links;
-	int ret;
-
-	sdata_lock(sdata);
-	if (!sdata->u.mgd.removed_links) {
-		sdata_unlock(sdata);
-		return;
-	}
-
-	sdata_info(sdata,
-		   "MLO Reconfiguration: work: valid=0x%x, removed=0x%x\n",
-		   sdata->vif.valid_links, sdata->u.mgd.removed_links);
-
-	new_valid_links = sdata->vif.valid_links & ~sdata->u.mgd.removed_links;
-	if (new_valid_links == sdata->vif.valid_links) {
-		sdata_unlock(sdata);
-		return;
-	}
-
-	if (!new_valid_links ||
-	    !(new_valid_links & ~sdata->vif.dormant_links)) {
-		sdata_info(sdata, "No valid links after reconfiguration\n");
-		ret = -EINVAL;
-		goto out;
-	}
-
-	new_active_links = sdata->vif.active_links & ~sdata->u.mgd.removed_links;
-	if (new_active_links != sdata->vif.active_links) {
-		if (!new_active_links)
-			new_active_links =
-				BIT(ffs(new_valid_links &
-					~sdata->vif.dormant_links) - 1);
-
-		ret = __ieee80211_set_active_links(&sdata->vif,
-						   new_active_links);
-		if (ret) {
-			sdata_info(sdata,
-				   "Failed setting active links\n");
-			goto out;
-		}
-	}
-
-	new_dormant_links = sdata->vif.dormant_links & ~sdata->u.mgd.removed_links;
-
-	ret = ieee80211_vif_set_links(sdata, new_valid_links,
-				      new_dormant_links);
-	if (ret)
-		sdata_info(sdata, "Failed setting valid links\n");
-
-out:
-	if (!ret)
-		cfg80211_links_removed(sdata->dev, sdata->u.mgd.removed_links);
-	else
-		___ieee80211_disconnect(sdata);
-
-	sdata->u.mgd.removed_links = 0;
-
-	sdata_unlock(sdata);
-}
-
-static void ieee80211_ml_reconfiguration(struct ieee80211_sub_if_data *sdata,
-					 struct ieee802_11_elems *elems)
-{
-	const struct ieee80211_multi_link_elem *ml;
-	const struct element *sub;
-	ssize_t ml_len;
-	unsigned long removed_links = 0;
-	u16 link_removal_timeout[IEEE80211_MLD_MAX_NUM_LINKS] = {};
-	u8 link_id;
-	u32 delay;
-
-	if (!ieee80211_vif_is_mld(&sdata->vif) || !elems->ml_reconf)
-		return;
-
-	ml_len = cfg80211_defragment_element(elems->ml_reconf_elem,
-					     elems->ie_start,
-					     elems->total_len,
-					     elems->scratch_pos,
-					     elems->scratch + elems->scratch_len -
-					     elems->scratch_pos,
-					     WLAN_EID_FRAGMENT);
-	if (ml_len < 0)
-		return;
-
-	elems->ml_reconf = (const void *)elems->scratch_pos;
-	elems->ml_reconf_len = ml_len;
-	ml = elems->ml_reconf;
-
-	/* Directly parse the sub elements as the common information doesn't
-	 * hold any useful information.
-	 */
-	for_each_mle_subelement(sub, (u8 *)ml, ml_len) {
-		struct ieee80211_mle_per_sta_profile *prof = (void *)sub->data;
-		u8 *pos = prof->variable;
-		u16 control;
-
-		if (sub->id != IEEE80211_MLE_SUBELEM_PER_STA_PROFILE)
-			continue;
-
-		if (!ieee80211_mle_reconf_sta_prof_size_ok(sub->data,
-							   sub->datalen))
-			return;
-
-		control = le16_to_cpu(prof->control);
-		link_id = control & IEEE80211_MLE_STA_RECONF_CONTROL_LINK_ID;
-
-		removed_links |= BIT(link_id);
-
-		/* the MAC address should not be included, but handle it */
-		if (control &
-		    IEEE80211_MLE_STA_RECONF_CONTROL_STA_MAC_ADDR_PRESENT)
-			pos += 6;
-
-		/* According to Draft P802.11be_D3.0, the control should
-		 * include the AP Removal Timer present. If the AP Removal Timer
-		 * is not present assume immediate removal.
-		 */
-		if (control &
-		    IEEE80211_MLE_STA_RECONF_CONTROL_AP_REM_TIMER_PRESENT)
-			link_removal_timeout[link_id] = get_unaligned_le16(pos);
-	}
-
-	removed_links &= sdata->vif.valid_links;
-	if (!removed_links) {
-		/* In case the removal was cancelled, abort it */
-		if (sdata->u.mgd.removed_links) {
-			sdata->u.mgd.removed_links = 0;
-			wiphy_delayed_work_cancel(sdata->local->hw.wiphy,
-						  &sdata->u.mgd.ml_reconf_work);
-		}
-		return;
-	}
-
-	delay = 0;
-	for_each_set_bit(link_id, &removed_links, IEEE80211_MLD_MAX_NUM_LINKS) {
-		struct ieee80211_bss_conf *link_conf =
-			sdata_dereference(sdata->vif.link_conf[link_id], sdata);
-		u32 link_delay;
-
-		if (!link_conf) {
-			removed_links &= ~BIT(link_id);
-			continue;
-		}
-
-		if (link_removal_timeout[link_id] < 1)
-			link_delay = 0;
-		else
-			link_delay = link_conf->beacon_int *
-				(link_removal_timeout[link_id] - 1);
-
-		if (!delay)
-			delay = link_delay;
-		else
-			delay = min(delay, link_delay);
-	}
-
-	sdata->u.mgd.removed_links = removed_links;
-	wiphy_delayed_work_queue(sdata->local->hw.wiphy,
-				 &sdata->u.mgd.ml_reconf_work,
-				 TU_TO_JIFFIES(delay));
-}
-
-static void ieee80211_rx_mgmt_beacon(struct ieee80211_link_data *link,
-				     struct ieee80211_hdr *hdr, size_t len,
-				     struct ieee80211_rx_status *rx_status)
-{
-	struct ieee80211_sub_if_data *sdata = link->sdata;
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-	struct ieee80211_bss_conf *bss_conf = &sdata->vif.bss_conf;
-	struct ieee80211_vif_cfg *vif_cfg = &sdata->vif.cfg;
-	struct ieee80211_mgmt *mgmt = (void *) hdr;
-	size_t baselen;
-	struct ieee802_11_elems *elems;
-	struct ieee80211_local *local = sdata->local;
-	struct ieee80211_chanctx_conf *chanctx_conf;
-	struct ieee80211_supported_band *sband;
-	struct ieee80211_channel *chan;
-	struct link_sta_info *link_sta;
-	struct sta_info *sta;
-	u64 changed = 0;
-	bool erp_valid;
-	u8 erp_value = 0;
-	u32 ncrc = 0;
-	u8 *bssid, *variable = mgmt->u.beacon.variable;
-	u8 deauth_buf[IEEE80211_DEAUTH_FRAME_LEN];
-	struct ieee80211_elems_parse_params parse_params = {
-		.link_id = -1,
-		.from_ap = true,
-	};
-
-	sdata_assert_lock(sdata);
-
-	/* Process beacon from the current BSS */
-	bssid = ieee80211_get_bssid(hdr, len, sdata->vif.type);
-	if (ieee80211_is_s1g_beacon(mgmt->frame_control)) {
-		struct ieee80211_ext *ext = (void *) mgmt;
-
-		if (ieee80211_is_s1g_short_beacon(ext->frame_control))
-			variable = ext->u.s1g_short_beacon.variable;
-		else
-			variable = ext->u.s1g_beacon.variable;
-	}
-
-	baselen = (u8 *) variable - (u8 *) mgmt;
-	if (baselen > len)
-		return;
-
-	parse_params.start = variable;
-	parse_params.len = len - baselen;
-
-	rcu_read_lock();
-	chanctx_conf = rcu_dereference(link->conf->chanctx_conf);
-	if (!chanctx_conf) {
-		rcu_read_unlock();
-		return;
-	}
-
-	if (ieee80211_rx_status_to_khz(rx_status) !=
-	    ieee80211_channel_to_khz(chanctx_conf->def.chan)) {
-		rcu_read_unlock();
-		return;
-	}
-	chan = chanctx_conf->def.chan;
-	rcu_read_unlock();
-
-	if (ifmgd->assoc_data && ifmgd->assoc_data->need_beacon &&
-	    !WARN_ON(ieee80211_vif_is_mld(&sdata->vif)) &&
-	    ieee80211_rx_our_beacon(bssid, ifmgd->assoc_data->link[0].bss)) {
-		parse_params.bss = ifmgd->assoc_data->link[0].bss;
-		elems = ieee802_11_parse_elems_full(&parse_params);
-		if (!elems)
-			return;
-
-		ieee80211_rx_bss_info(link, mgmt, len, rx_status);
-
-		if (elems->dtim_period)
-			link->u.mgd.dtim_period = elems->dtim_period;
-		link->u.mgd.have_beacon = true;
-		ifmgd->assoc_data->need_beacon = false;
-		if (ieee80211_hw_check(&local->hw, TIMING_BEACON_ONLY) &&
-		    !ieee80211_is_s1g_beacon(hdr->frame_control)) {
-			link->conf->sync_tsf =
-				le64_to_cpu(mgmt->u.beacon.timestamp);
-			link->conf->sync_device_ts =
-				rx_status->device_timestamp;
-			link->conf->sync_dtim_count = elems->dtim_count;
-		}
-
-		if (elems->mbssid_config_ie)
-			bss_conf->profile_periodicity =
-				elems->mbssid_config_ie->profile_periodicity;
-		else
-			bss_conf->profile_periodicity = 0;
-
-		if (elems->ext_capab_len >= 11 &&
-		    (elems->ext_capab[10] & WLAN_EXT_CAPA11_EMA_SUPPORT))
-			bss_conf->ema_ap = true;
-		else
-			bss_conf->ema_ap = false;
-
-		/* continue assoc process */
-		ifmgd->assoc_data->timeout = jiffies;
-		ifmgd->assoc_data->timeout_started = true;
-		run_again(sdata, ifmgd->assoc_data->timeout);
-		kfree(elems);
-		return;
-	}
-
-	if (!ifmgd->associated ||
-	    !ieee80211_rx_our_beacon(bssid, link->u.mgd.bss))
-		return;
-	bssid = link->u.mgd.bssid;
-
-	if (!(rx_status->flag & RX_FLAG_NO_SIGNAL_VAL))
-		ieee80211_handle_beacon_sig(link, ifmgd, bss_conf,
-					    local, rx_status);
-
-	if (ifmgd->flags & IEEE80211_STA_CONNECTION_POLL) {
-		mlme_dbg_ratelimited(sdata,
-				     "cancelling AP probe due to a received beacon\n");
-		ieee80211_reset_ap_probe(sdata);
-	}
-
-	/*
-	 * Push the beacon loss detection into the future since
-	 * we are processing a beacon from the AP just now.
-	 */
-	ieee80211_sta_reset_beacon_monitor(sdata);
-
-	/* TODO: CRC urrently not calculated on S1G Beacon Compatibility
-	 * element (which carries the beacon interval). Don't forget to add a
-	 * bit to care_about_ies[] above if mac80211 is interested in a
-	 * changing S1G element.
-	 */
-	if (!ieee80211_is_s1g_beacon(hdr->frame_control))
-		ncrc = crc32_be(0, (void *)&mgmt->u.beacon.beacon_int, 4);
-	parse_params.bss = link->u.mgd.bss;
-	parse_params.filter = care_about_ies;
-	parse_params.crc = ncrc;
-	elems = ieee802_11_parse_elems_full(&parse_params);
-	if (!elems)
-		return;
-	ncrc = elems->crc;
-
-	if (ieee80211_hw_check(&local->hw, PS_NULLFUNC_STACK) &&
-	    ieee80211_check_tim(elems->tim, elems->tim_len, vif_cfg->aid)) {
-		if (local->hw.conf.dynamic_ps_timeout > 0) {
-			if (local->hw.conf.flags & IEEE80211_CONF_PS) {
-				local->hw.conf.flags &= ~IEEE80211_CONF_PS;
-				ieee80211_hw_config(local,
-						    IEEE80211_CONF_CHANGE_PS);
-			}
-			ieee80211_send_nullfunc(local, sdata, false);
-		} else if (!local->pspolling && sdata->u.mgd.powersave) {
-			local->pspolling = true;
-
-			/*
-			 * Here is assumed that the driver will be
-			 * able to send ps-poll frame and receive a
-			 * response even though power save mode is
-			 * enabled, but some drivers might require
-			 * to disable power save here. This needs
-			 * to be investigated.
-			 */
-			ieee80211_send_pspoll(local, sdata);
-		}
-	}
-
-	if (sdata->vif.p2p ||
-	    sdata->vif.driver_flags & IEEE80211_VIF_GET_NOA_UPDATE) {
-		struct ieee80211_p2p_noa_attr noa = {};
-		int ret;
-
-		ret = cfg80211_get_p2p_attr(variable,
-					    len - baselen,
-					    IEEE80211_P2P_ATTR_ABSENCE_NOTICE,
-					    (u8 *) &noa, sizeof(noa));
-		if (ret >= 2) {
-			if (link->u.mgd.p2p_noa_index != noa.index) {
-				/* valid noa_attr and index changed */
-				link->u.mgd.p2p_noa_index = noa.index;
-				memcpy(&bss_conf->p2p_noa_attr, &noa, sizeof(noa));
-				changed |= BSS_CHANGED_P2P_PS;
-				/*
-				 * make sure we update all information, the CRC
-				 * mechanism doesn't look at P2P attributes.
-				 */
-				link->u.mgd.beacon_crc_valid = false;
-			}
-		} else if (link->u.mgd.p2p_noa_index != -1) {
-			/* noa_attr not found and we had valid noa_attr before */
-			link->u.mgd.p2p_noa_index = -1;
-			memset(&bss_conf->p2p_noa_attr, 0, sizeof(bss_conf->p2p_noa_attr));
-			changed |= BSS_CHANGED_P2P_PS;
-			link->u.mgd.beacon_crc_valid = false;
-		}
-	}
-
-	if (link->u.mgd.csa_waiting_bcn)
-		ieee80211_chswitch_post_beacon(link);
-
-	/*
-	 * Update beacon timing and dtim count on every beacon appearance. This
-	 * will allow the driver to use the most updated values. Do it before
-	 * comparing this one with last received beacon.
-	 * IMPORTANT: These parameters would possibly be out of sync by the time
-	 * the driver will use them. The synchronized view is currently
-	 * guaranteed only in certain callbacks.
-	 */
-	if (ieee80211_hw_check(&local->hw, TIMING_BEACON_ONLY) &&
-	    !ieee80211_is_s1g_beacon(hdr->frame_control)) {
-		link->conf->sync_tsf =
-			le64_to_cpu(mgmt->u.beacon.timestamp);
-		link->conf->sync_device_ts =
-			rx_status->device_timestamp;
-		link->conf->sync_dtim_count = elems->dtim_count;
-	}
-
-	if ((ncrc == link->u.mgd.beacon_crc && link->u.mgd.beacon_crc_valid) ||
-	    ieee80211_is_s1g_short_beacon(mgmt->frame_control))
-		goto free;
-	link->u.mgd.beacon_crc = ncrc;
-	link->u.mgd.beacon_crc_valid = true;
-
-	ieee80211_rx_bss_info(link, mgmt, len, rx_status);
-
-	ieee80211_sta_process_chanswitch(link, rx_status->mactime,
-					 rx_status->device_timestamp,
-					 elems, true);
-
-	if (!link->u.mgd.disable_wmm_tracking &&
-	    ieee80211_sta_wmm_params(local, link, elems->wmm_param,
-				     elems->wmm_param_len,
-				     elems->mu_edca_param_set))
-		changed |= BSS_CHANGED_QOS;
-
-	/*
-	 * If we haven't had a beacon before, tell the driver about the
-	 * DTIM period (and beacon timing if desired) now.
-	 */
-	if (!link->u.mgd.have_beacon) {
-		/* a few bogus AP send dtim_period = 0 or no TIM IE */
-		bss_conf->dtim_period = elems->dtim_period ?: 1;
-
-		changed |= BSS_CHANGED_BEACON_INFO;
-		link->u.mgd.have_beacon = true;
-
-		mutex_lock(&local->iflist_mtx);
-		ieee80211_recalc_ps(local);
-		mutex_unlock(&local->iflist_mtx);
-
-		ieee80211_recalc_ps_vif(sdata);
-	}
-
-	if (elems->erp_info) {
-		erp_valid = true;
-		erp_value = elems->erp_info[0];
-	} else {
-		erp_valid = false;
-	}
-
-	if (!ieee80211_is_s1g_beacon(hdr->frame_control))
-		changed |= ieee80211_handle_bss_capability(link,
-				le16_to_cpu(mgmt->u.beacon.capab_info),
-				erp_valid, erp_value);
-
-	mutex_lock(&local->sta_mtx);
-	sta = sta_info_get(sdata, sdata->vif.cfg.ap_addr);
-	if (WARN_ON(!sta)) {
-		mutex_unlock(&local->sta_mtx);
-		goto free;
-	}
-	link_sta = rcu_dereference_protected(sta->link[link->link_id],
-					     lockdep_is_held(&local->sta_mtx));
-	if (WARN_ON(!link_sta)) {
-		mutex_unlock(&local->sta_mtx);
-		goto free;
-	}
-
-	if (WARN_ON(!link->conf->chandef.chan))
-		goto free;
-
-	sband = local->hw.wiphy->bands[link->conf->chandef.chan->band];
-
-	changed |= ieee80211_recalc_twt_req(sdata, sband, link, link_sta, elems);
-
-	if (ieee80211_config_bw(link, elems->ht_cap_elem,
-				elems->vht_cap_elem, elems->ht_operation,
-				elems->vht_operation, elems->he_operation,
-				elems->eht_operation,
-				elems->s1g_oper, bssid, &changed)) {
-		mutex_unlock(&local->sta_mtx);
-		sdata_info(sdata,
-			   "failed to follow AP %pM bandwidth change, disconnect\n",
-			   bssid);
-		ieee80211_set_disassoc(sdata, IEEE80211_STYPE_DEAUTH,
-				       WLAN_REASON_DEAUTH_LEAVING,
-				       true, deauth_buf);
-		ieee80211_report_disconnect(sdata, deauth_buf,
-					    sizeof(deauth_buf), true,
-					    WLAN_REASON_DEAUTH_LEAVING,
-					    false);
-		goto free;
-	}
-
-	if (elems->opmode_notif)
-		ieee80211_vht_handle_opmode(sdata, link_sta,
-					    *elems->opmode_notif,
-					    rx_status->band);
-	mutex_unlock(&local->sta_mtx);
-
-	changed |= ieee80211_handle_pwr_constr(link, chan, mgmt,
-					       elems->country_elem,
-					       elems->country_elem_len,
-					       elems->pwr_constr_elem,
-					       elems->cisco_dtpc_elem);
-
-	if (elems->eht_operation &&
-	    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_EHT)) {
-		if (!ieee80211_config_puncturing(link, elems->eht_operation,
-						 &changed)) {
-			ieee80211_set_disassoc(sdata, IEEE80211_STYPE_DEAUTH,
-					       WLAN_REASON_DEAUTH_LEAVING,
-					       true, deauth_buf);
-			ieee80211_report_disconnect(sdata, deauth_buf,
-						    sizeof(deauth_buf), true,
-						    WLAN_REASON_DEAUTH_LEAVING,
-						    false);
-			goto free;
-		}
-	}
-
-	ieee80211_ml_reconfiguration(sdata, elems);
-
-	ieee80211_link_info_change_notify(sdata, link, changed);
-free:
-	kfree(elems);
-}
-
-void ieee80211_sta_rx_queued_ext(struct ieee80211_sub_if_data *sdata,
-				 struct sk_buff *skb)
-{
-	struct ieee80211_link_data *link = &sdata->deflink;
-	struct ieee80211_rx_status *rx_status;
-	struct ieee80211_hdr *hdr;
-	u16 fc;
-
-	rx_status = (struct ieee80211_rx_status *) skb->cb;
-	hdr = (struct ieee80211_hdr *) skb->data;
-	fc = le16_to_cpu(hdr->frame_control);
-
-	sdata_lock(sdata);
-	switch (fc & IEEE80211_FCTL_STYPE) {
-	case IEEE80211_STYPE_S1G_BEACON:
-		ieee80211_rx_mgmt_beacon(link, hdr, skb->len, rx_status);
-		break;
-	}
-	sdata_unlock(sdata);
-}
-
-void ieee80211_sta_rx_queued_mgmt(struct ieee80211_sub_if_data *sdata,
-				  struct sk_buff *skb)
-{
-	struct ieee80211_link_data *link = &sdata->deflink;
-	struct ieee80211_rx_status *rx_status;
-	struct ieee80211_mgmt *mgmt;
-	u16 fc;
-	int ies_len;
-
-	rx_status = (struct ieee80211_rx_status *) skb->cb;
-	mgmt = (struct ieee80211_mgmt *) skb->data;
-	fc = le16_to_cpu(mgmt->frame_control);
-
-	sdata_lock(sdata);
-
-	if (rx_status->link_valid) {
-		link = sdata_dereference(sdata->link[rx_status->link_id],
-					 sdata);
-		if (!link)
-			goto out;
-	}
-
-	switch (fc & IEEE80211_FCTL_STYPE) {
-	case IEEE80211_STYPE_BEACON:
-		ieee80211_rx_mgmt_beacon(link, (void *)mgmt,
-					 skb->len, rx_status);
-		break;
-	case IEEE80211_STYPE_PROBE_RESP:
-		ieee80211_rx_mgmt_probe_resp(link, skb);
-		break;
-	case IEEE80211_STYPE_AUTH:
-		ieee80211_rx_mgmt_auth(sdata, mgmt, skb->len);
-		break;
-	case IEEE80211_STYPE_DEAUTH:
-		ieee80211_rx_mgmt_deauth(sdata, mgmt, skb->len);
-		break;
-	case IEEE80211_STYPE_DISASSOC:
-		ieee80211_rx_mgmt_disassoc(sdata, mgmt, skb->len);
-		break;
-	case IEEE80211_STYPE_ASSOC_RESP:
-	case IEEE80211_STYPE_REASSOC_RESP:
-		ieee80211_rx_mgmt_assoc_resp(sdata, mgmt, skb->len);
-		break;
-	case IEEE80211_STYPE_ACTION:
-		if (!sdata->u.mgd.associated ||
-		    !ether_addr_equal(mgmt->bssid, sdata->vif.cfg.ap_addr))
-			break;
-
-		if (mgmt->u.action.category == WLAN_CATEGORY_SPECTRUM_MGMT) {
-			struct ieee802_11_elems *elems;
-
-			ies_len = skb->len -
-				  offsetof(struct ieee80211_mgmt,
-					   u.action.u.chan_switch.variable);
-
-			if (ies_len < 0)
-				break;
-
-			/* CSA IE cannot be overridden, no need for BSSID */
-			elems = ieee802_11_parse_elems(
-					mgmt->u.action.u.chan_switch.variable,
-					ies_len, true, NULL);
-
-			if (elems && !elems->parse_error)
-				ieee80211_sta_process_chanswitch(link,
-								 rx_status->mactime,
-								 rx_status->device_timestamp,
-								 elems, false);
-			kfree(elems);
-		} else if (mgmt->u.action.category == WLAN_CATEGORY_PUBLIC) {
-			struct ieee802_11_elems *elems;
-
-			ies_len = skb->len -
-				  offsetof(struct ieee80211_mgmt,
-					   u.action.u.ext_chan_switch.variable);
-
-			if (ies_len < 0)
-				break;
-
-			/*
-			 * extended CSA IE can't be overridden, no need for
-			 * BSSID
-			 */
-			elems = ieee802_11_parse_elems(
-					mgmt->u.action.u.ext_chan_switch.variable,
-					ies_len, true, NULL);
-
-			if (elems && !elems->parse_error) {
-				/* for the handling code pretend it was an IE */
-				elems->ext_chansw_ie =
-					&mgmt->u.action.u.ext_chan_switch.data;
-
-				ieee80211_sta_process_chanswitch(link,
-								 rx_status->mactime,
-								 rx_status->device_timestamp,
-								 elems, false);
-			}
-
-			kfree(elems);
-		}
-		break;
-	}
-out:
-	sdata_unlock(sdata);
-}
-
-static void ieee80211_sta_timer(struct timer_list *t)
-{
-	struct ieee80211_sub_if_data *sdata =
-		from_timer(sdata, t, u.mgd.timer);
-
-	wiphy_work_queue(sdata->local->hw.wiphy, &sdata->work);
-}
-
-void ieee80211_sta_connection_lost(struct ieee80211_sub_if_data *sdata,
-				   u8 reason, bool tx)
-{
-	u8 frame_buf[IEEE80211_DEAUTH_FRAME_LEN];
-
-	ieee80211_set_disassoc(sdata, IEEE80211_STYPE_DEAUTH, reason,
-			       tx, frame_buf);
-
-	ieee80211_report_disconnect(sdata, frame_buf, sizeof(frame_buf), true,
-				    reason, false);
-}
-
-static int ieee80211_auth(struct ieee80211_sub_if_data *sdata)
-{
-	struct ieee80211_local *local = sdata->local;
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-	struct ieee80211_mgd_auth_data *auth_data = ifmgd->auth_data;
-	u32 tx_flags = 0;
-	u16 trans = 1;
-	u16 status = 0;
-	struct ieee80211_prep_tx_info info = {
-		.subtype = IEEE80211_STYPE_AUTH,
-	};
-
-	sdata_assert_lock(sdata);
-
-	if (WARN_ON_ONCE(!auth_data))
-		return -EINVAL;
-
-	auth_data->tries++;
-
-	if (auth_data->tries > IEEE80211_AUTH_MAX_TRIES) {
-		sdata_info(sdata, "authentication with %pM timed out\n",
-			   auth_data->ap_addr);
-
-		/*
-		 * Most likely AP is not in the range so remove the
-		 * bss struct for that AP.
-		 */
-		cfg80211_unlink_bss(local->hw.wiphy, auth_data->bss);
-
-		return -ETIMEDOUT;
-	}
-
-	if (auth_data->algorithm == WLAN_AUTH_SAE)
-		info.duration = jiffies_to_msecs(IEEE80211_AUTH_TIMEOUT_SAE);
-
-	drv_mgd_prepare_tx(local, sdata, &info);
-
-	sdata_info(sdata, "send auth to %pM (try %d/%d)\n",
-		   auth_data->ap_addr, auth_data->tries,
-		   IEEE80211_AUTH_MAX_TRIES);
-
-	auth_data->expected_transaction = 2;
-
-	if (auth_data->algorithm == WLAN_AUTH_SAE) {
-		trans = auth_data->sae_trans;
-		status = auth_data->sae_status;
-		auth_data->expected_transaction = trans;
-	}
-
-	if (ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS))
-		tx_flags = IEEE80211_TX_CTL_REQ_TX_STATUS |
-			   IEEE80211_TX_INTFL_MLME_CONN_TX;
-
-	ieee80211_send_auth(sdata, trans, auth_data->algorithm, status,
-			    auth_data->data, auth_data->data_len,
-			    auth_data->ap_addr, auth_data->ap_addr,
-			    NULL, 0, 0, tx_flags);
-
-	if (tx_flags == 0) {
-		if (auth_data->algorithm == WLAN_AUTH_SAE)
-			auth_data->timeout = jiffies +
-				IEEE80211_AUTH_TIMEOUT_SAE;
-		else
-			auth_data->timeout = jiffies + IEEE80211_AUTH_TIMEOUT;
-	} else {
-		auth_data->timeout =
-			round_jiffies_up(jiffies + IEEE80211_AUTH_TIMEOUT_LONG);
-	}
-
-	auth_data->timeout_started = true;
-	run_again(sdata, auth_data->timeout);
-
-	return 0;
-}
-
-static int ieee80211_do_assoc(struct ieee80211_sub_if_data *sdata)
-{
-	struct ieee80211_mgd_assoc_data *assoc_data = sdata->u.mgd.assoc_data;
-	struct ieee80211_local *local = sdata->local;
-	int ret;
-
-	sdata_assert_lock(sdata);
-
-	assoc_data->tries++;
-	if (assoc_data->tries > IEEE80211_ASSOC_MAX_TRIES) {
-		sdata_info(sdata, "association with %pM timed out\n",
-			   assoc_data->ap_addr);
-
-		/*
-		 * Most likely AP is not in the range so remove the
-		 * bss struct for that AP.
-		 */
-		cfg80211_unlink_bss(local->hw.wiphy,
-				    assoc_data->link[assoc_data->assoc_link_id].bss);
-
-		return -ETIMEDOUT;
-	}
-
-	sdata_info(sdata, "associate with %pM (try %d/%d)\n",
-		   assoc_data->ap_addr, assoc_data->tries,
-		   IEEE80211_ASSOC_MAX_TRIES);
-	ret = ieee80211_send_assoc(sdata);
-	if (ret)
-		return ret;
-
-	if (!ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS)) {
-		assoc_data->timeout = jiffies + IEEE80211_ASSOC_TIMEOUT;
-		assoc_data->timeout_started = true;
-		run_again(sdata, assoc_data->timeout);
-	} else {
-		assoc_data->timeout =
-			round_jiffies_up(jiffies +
-					 IEEE80211_ASSOC_TIMEOUT_LONG);
-		assoc_data->timeout_started = true;
-		run_again(sdata, assoc_data->timeout);
-	}
-
-	return 0;
-}
-
-void ieee80211_mgd_conn_tx_status(struct ieee80211_sub_if_data *sdata,
-				  __le16 fc, bool acked)
-{
-	struct ieee80211_local *local = sdata->local;
-
-	sdata->u.mgd.status_fc = fc;
-	sdata->u.mgd.status_acked = acked;
-	sdata->u.mgd.status_received = true;
-
-	wiphy_work_queue(local->hw.wiphy, &sdata->work);
-}
-
-void ieee80211_sta_work(struct ieee80211_sub_if_data *sdata)
-{
-	struct ieee80211_local *local = sdata->local;
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-
-	sdata_lock(sdata);
-
-	if (ifmgd->status_received) {
-		__le16 fc = ifmgd->status_fc;
-		bool status_acked = ifmgd->status_acked;
-
-		ifmgd->status_received = false;
-		if (ifmgd->auth_data && ieee80211_is_auth(fc)) {
-			if (status_acked) {
-				if (ifmgd->auth_data->algorithm ==
-				    WLAN_AUTH_SAE)
-					ifmgd->auth_data->timeout =
-						jiffies +
-						IEEE80211_AUTH_TIMEOUT_SAE;
-				else
-					ifmgd->auth_data->timeout =
-						jiffies +
-						IEEE80211_AUTH_TIMEOUT_SHORT;
-				run_again(sdata, ifmgd->auth_data->timeout);
-			} else {
-				ifmgd->auth_data->timeout = jiffies - 1;
-			}
-			ifmgd->auth_data->timeout_started = true;
-		} else if (ifmgd->assoc_data &&
-			   (ieee80211_is_assoc_req(fc) ||
-			    ieee80211_is_reassoc_req(fc))) {
-			if (status_acked) {
-				ifmgd->assoc_data->timeout =
-					jiffies + IEEE80211_ASSOC_TIMEOUT_SHORT;
-				run_again(sdata, ifmgd->assoc_data->timeout);
-			} else {
-				ifmgd->assoc_data->timeout = jiffies - 1;
-			}
-			ifmgd->assoc_data->timeout_started = true;
-		}
-	}
-
-	if (ifmgd->auth_data && ifmgd->auth_data->timeout_started &&
-	    time_after(jiffies, ifmgd->auth_data->timeout)) {
-		if (ifmgd->auth_data->done || ifmgd->auth_data->waiting) {
-			/*
-			 * ok ... we waited for assoc or continuation but
-			 * userspace didn't do it, so kill the auth data
-			 */
-			ieee80211_destroy_auth_data(sdata, false);
-		} else if (ieee80211_auth(sdata)) {
-			u8 ap_addr[ETH_ALEN];
-			struct ieee80211_event event = {
-				.type = MLME_EVENT,
-				.u.mlme.data = AUTH_EVENT,
-				.u.mlme.status = MLME_TIMEOUT,
-			};
-
-			memcpy(ap_addr, ifmgd->auth_data->ap_addr, ETH_ALEN);
-
-			ieee80211_destroy_auth_data(sdata, false);
-
-			cfg80211_auth_timeout(sdata->dev, ap_addr);
-			drv_event_callback(sdata->local, sdata, &event);
-		}
-	} else if (ifmgd->auth_data && ifmgd->auth_data->timeout_started)
-		run_again(sdata, ifmgd->auth_data->timeout);
-
-	if (ifmgd->assoc_data && ifmgd->assoc_data->timeout_started &&
-	    time_after(jiffies, ifmgd->assoc_data->timeout)) {
-		if ((ifmgd->assoc_data->need_beacon &&
-		     !sdata->deflink.u.mgd.have_beacon) ||
-		    ieee80211_do_assoc(sdata)) {
-			struct ieee80211_event event = {
-				.type = MLME_EVENT,
-				.u.mlme.data = ASSOC_EVENT,
-				.u.mlme.status = MLME_TIMEOUT,
-			};
-
-			ieee80211_destroy_assoc_data(sdata, ASSOC_TIMEOUT);
-			drv_event_callback(sdata->local, sdata, &event);
-		}
-	} else if (ifmgd->assoc_data && ifmgd->assoc_data->timeout_started)
-		run_again(sdata, ifmgd->assoc_data->timeout);
-
-	if (ifmgd->flags & IEEE80211_STA_CONNECTION_POLL &&
-	    ifmgd->associated) {
-		u8 *bssid = sdata->deflink.u.mgd.bssid;
-		int max_tries;
-
-		if (ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS))
-			max_tries = max_nullfunc_tries;
-		else
-			max_tries = max_probe_tries;
-
-		/* ACK received for nullfunc probing frame */
-		if (!ifmgd->probe_send_count)
-			ieee80211_reset_ap_probe(sdata);
-		else if (ifmgd->nullfunc_failed) {
-			if (ifmgd->probe_send_count < max_tries) {
-				mlme_dbg(sdata,
-					 "No ack for nullfunc frame to AP %pM, try %d/%i\n",
-					 bssid, ifmgd->probe_send_count,
-					 max_tries);
-				ieee80211_mgd_probe_ap_send(sdata);
-			} else {
-				mlme_dbg(sdata,
-					 "No ack for nullfunc frame to AP %pM, disconnecting.\n",
-					 bssid);
-				ieee80211_sta_connection_lost(sdata,
-					WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY,
-					false);
-			}
-		} else if (time_is_after_jiffies(ifmgd->probe_timeout))
-			run_again(sdata, ifmgd->probe_timeout);
-		else if (ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS)) {
-			mlme_dbg(sdata,
-				 "Failed to send nullfunc to AP %pM after %dms, disconnecting\n",
-				 bssid, probe_wait_ms);
-			ieee80211_sta_connection_lost(sdata,
-				WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY, false);
-		} else if (ifmgd->probe_send_count < max_tries) {
-			mlme_dbg(sdata,
-				 "No probe response from AP %pM after %dms, try %d/%i\n",
-				 bssid, probe_wait_ms,
-				 ifmgd->probe_send_count, max_tries);
-			ieee80211_mgd_probe_ap_send(sdata);
-		} else {
-			/*
-			 * We actually lost the connection ... or did we?
-			 * Let's make sure!
-			 */
-			mlme_dbg(sdata,
-				 "No probe response from AP %pM after %dms, disconnecting.\n",
-				 bssid, probe_wait_ms);
-
-			ieee80211_sta_connection_lost(sdata,
-				WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY, false);
-		}
-	}
-
-	sdata_unlock(sdata);
-}
-
-static void ieee80211_sta_bcn_mon_timer(struct timer_list *t)
-{
-	struct ieee80211_sub_if_data *sdata =
-		from_timer(sdata, t, u.mgd.bcn_mon_timer);
-
-	if (WARN_ON(ieee80211_vif_is_mld(&sdata->vif)))
-		return;
-
-	if (sdata->vif.bss_conf.csa_active &&
-	    !sdata->deflink.u.mgd.csa_waiting_bcn)
-		return;
-
-	if (sdata->vif.driver_flags & IEEE80211_VIF_BEACON_FILTER)
-		return;
-
-	sdata->u.mgd.connection_loss = false;
-	wiphy_work_queue(sdata->local->hw.wiphy,
-			 &sdata->u.mgd.beacon_connection_loss_work);
-}
-
-static void ieee80211_sta_conn_mon_timer(struct timer_list *t)
-{
-	struct ieee80211_sub_if_data *sdata =
-		from_timer(sdata, t, u.mgd.conn_mon_timer);
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-	struct ieee80211_local *local = sdata->local;
-	struct sta_info *sta;
-	unsigned long timeout;
-
-	if (WARN_ON(ieee80211_vif_is_mld(&sdata->vif)))
-		return;
-
-	if (sdata->vif.bss_conf.csa_active &&
-	    !sdata->deflink.u.mgd.csa_waiting_bcn)
-		return;
-
-	sta = sta_info_get(sdata, sdata->vif.cfg.ap_addr);
-	if (!sta)
-		return;
-
-	timeout = sta->deflink.status_stats.last_ack;
-	if (time_before(sta->deflink.status_stats.last_ack, sta->deflink.rx_stats.last_rx))
-		timeout = sta->deflink.rx_stats.last_rx;
-	timeout += IEEE80211_CONNECTION_IDLE_TIME;
-
-	/* If timeout is after now, then update timer to fire at
-	 * the later date, but do not actually probe at this time.
-	 */
-	if (time_is_after_jiffies(timeout)) {
-		mod_timer(&ifmgd->conn_mon_timer, round_jiffies_up(timeout));
-		return;
-	}
-
-	ieee80211_queue_work(&local->hw, &ifmgd->monitor_work);
-}
-
-static void ieee80211_sta_monitor_work(struct work_struct *work)
-{
-	struct ieee80211_sub_if_data *sdata =
-		container_of(work, struct ieee80211_sub_if_data,
-			     u.mgd.monitor_work);
-
-	ieee80211_mgd_probe_ap(sdata, false);
-}
-
-static void ieee80211_restart_sta_timer(struct ieee80211_sub_if_data *sdata)
-{
-	if (sdata->vif.type == NL80211_IFTYPE_STATION) {
-		__ieee80211_stop_poll(sdata);
-
-		/* let's probe the connection once */
-		if (!ieee80211_hw_check(&sdata->local->hw, CONNECTION_MONITOR))
-			ieee80211_queue_work(&sdata->local->hw,
-					     &sdata->u.mgd.monitor_work);
-	}
-}
-
-#ifdef CONFIG_PM
-void ieee80211_mgd_quiesce(struct ieee80211_sub_if_data *sdata)
-{
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-	u8 frame_buf[IEEE80211_DEAUTH_FRAME_LEN];
-
-	sdata_lock(sdata);
-
-	if (ifmgd->auth_data || ifmgd->assoc_data) {
-		const u8 *ap_addr = ifmgd->auth_data ?
-				ifmgd->auth_data->ap_addr :
-				ifmgd->assoc_data->ap_addr;
-
-		/*
-		 * If we are trying to authenticate / associate while suspending,
-		 * cfg80211 won't know and won't actually abort those attempts,
-		 * thus we need to do that ourselves.
-		 */
-		ieee80211_send_deauth_disassoc(sdata, ap_addr, ap_addr,
-					       IEEE80211_STYPE_DEAUTH,
-					       WLAN_REASON_DEAUTH_LEAVING,
-					       false, frame_buf);
-		if (ifmgd->assoc_data)
-			ieee80211_destroy_assoc_data(sdata, ASSOC_ABANDON);
-		if (ifmgd->auth_data)
-			ieee80211_destroy_auth_data(sdata, false);
-		cfg80211_tx_mlme_mgmt(sdata->dev, frame_buf,
-				      IEEE80211_DEAUTH_FRAME_LEN,
-				      false);
-	}
-
-	/* This is a bit of a hack - we should find a better and more generic
-	 * solution to this. Normally when suspending, cfg80211 will in fact
-	 * deauthenticate. However, it doesn't (and cannot) stop an ongoing
-	 * auth (not so important) or assoc (this is the problem) process.
-	 *
-	 * As a consequence, it can happen that we are in the process of both
-	 * associating and suspending, and receive an association response
-	 * after cfg80211 has checked if it needs to disconnect, but before
-	 * we actually set the flag to drop incoming frames. This will then
-	 * cause the workqueue flush to process the association response in
-	 * the suspend, resulting in a successful association just before it
-	 * tries to remove the interface from the driver, which now though
-	 * has a channel context assigned ... this results in issues.
-	 *
-	 * To work around this (for now) simply deauth here again if we're
-	 * now connected.
-	 */
-	if (ifmgd->associated && !sdata->local->wowlan) {
-		u8 bssid[ETH_ALEN];
-		struct cfg80211_deauth_request req = {
-			.reason_code = WLAN_REASON_DEAUTH_LEAVING,
-			.bssid = bssid,
-		};
-
-		memcpy(bssid, sdata->vif.cfg.ap_addr, ETH_ALEN);
-		ieee80211_mgd_deauth(sdata, &req);
-	}
-
-	sdata_unlock(sdata);
-}
-#endif
-
-void ieee80211_sta_restart(struct ieee80211_sub_if_data *sdata)
-{
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-
-	sdata_lock(sdata);
-	if (!ifmgd->associated) {
-		sdata_unlock(sdata);
-		return;
-	}
-
-	if (sdata->flags & IEEE80211_SDATA_DISCONNECT_RESUME) {
-		sdata->flags &= ~IEEE80211_SDATA_DISCONNECT_RESUME;
-		mlme_dbg(sdata, "driver requested disconnect after resume\n");
-		ieee80211_sta_connection_lost(sdata,
-					      WLAN_REASON_UNSPECIFIED,
-					      true);
-		sdata_unlock(sdata);
-		return;
-	}
-
-	if (sdata->flags & IEEE80211_SDATA_DISCONNECT_HW_RESTART) {
-		sdata->flags &= ~IEEE80211_SDATA_DISCONNECT_HW_RESTART;
-		mlme_dbg(sdata, "driver requested disconnect after hardware restart\n");
-		ieee80211_sta_connection_lost(sdata,
-					      WLAN_REASON_UNSPECIFIED,
-					      true);
-		sdata_unlock(sdata);
-		return;
-	}
-
-	sdata_unlock(sdata);
-}
-
-static void ieee80211_request_smps_mgd_work(struct wiphy *wiphy,
-					    struct wiphy_work *work)
-{
-	struct ieee80211_link_data *link =
-		container_of(work, struct ieee80211_link_data,
-			     u.mgd.request_smps_work);
-
-	sdata_lock(link->sdata);
-	__ieee80211_request_smps_mgd(link->sdata, link,
-				     link->u.mgd.driver_smps_mode);
-	sdata_unlock(link->sdata);
-}
-
-/* interface setup */
-void ieee80211_sta_setup_sdata(struct ieee80211_sub_if_data *sdata)
-{
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-
-	INIT_WORK(&ifmgd->monitor_work, ieee80211_sta_monitor_work);
-	wiphy_work_init(&ifmgd->beacon_connection_loss_work,
-			ieee80211_beacon_connection_loss_work);
-	wiphy_work_init(&ifmgd->csa_connection_drop_work,
-			ieee80211_csa_connection_drop_work);
-	INIT_DELAYED_WORK(&ifmgd->tdls_peer_del_work,
-			  ieee80211_tdls_peer_del_work);
-	wiphy_delayed_work_init(&ifmgd->ml_reconf_work,
-				ieee80211_ml_reconf_work);
-	timer_setup(&ifmgd->timer, ieee80211_sta_timer, 0);
-	timer_setup(&ifmgd->bcn_mon_timer, ieee80211_sta_bcn_mon_timer, 0);
-	timer_setup(&ifmgd->conn_mon_timer, ieee80211_sta_conn_mon_timer, 0);
-	INIT_DELAYED_WORK(&ifmgd->tx_tspec_wk,
-			  ieee80211_sta_handle_tspec_ac_params_wk);
-
-	ifmgd->flags = 0;
-	ifmgd->powersave = sdata->wdev.ps;
-	ifmgd->uapsd_queues = sdata->local->hw.uapsd_queues;
-	ifmgd->uapsd_max_sp_len = sdata->local->hw.uapsd_max_sp_len;
-	/* Setup TDLS data */
-	spin_lock_init(&ifmgd->teardown_lock);
-	ifmgd->teardown_skb = NULL;
-	ifmgd->orig_teardown_skb = NULL;
-}
-
-void ieee80211_mgd_setup_link(struct ieee80211_link_data *link)
-{
-	struct ieee80211_sub_if_data *sdata = link->sdata;
-	struct ieee80211_local *local = sdata->local;
-	unsigned int link_id = link->link_id;
-
-	link->u.mgd.p2p_noa_index = -1;
-	link->u.mgd.conn_flags = 0;
-	link->conf->bssid = link->u.mgd.bssid;
-
-	wiphy_work_init(&link->u.mgd.request_smps_work,
-			ieee80211_request_smps_mgd_work);
-	if (local->hw.wiphy->features & NL80211_FEATURE_DYNAMIC_SMPS)
-		link->u.mgd.req_smps = IEEE80211_SMPS_AUTOMATIC;
-	else
-		link->u.mgd.req_smps = IEEE80211_SMPS_OFF;
-
-	wiphy_delayed_work_init(&link->u.mgd.chswitch_work,
-				ieee80211_chswitch_work);
-
-	if (sdata->u.mgd.assoc_data)
-		ether_addr_copy(link->conf->addr,
-				sdata->u.mgd.assoc_data->link[link_id].addr);
-	else if (!is_valid_ether_addr(link->conf->addr))
-		eth_random_addr(link->conf->addr);
-}
-
-/* scan finished notification */
-void ieee80211_mlme_notify_scan_completed(struct ieee80211_local *local)
-{
-	struct ieee80211_sub_if_data *sdata;
-
-	/* Restart STA timers */
-	rcu_read_lock();
-	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
-		if (ieee80211_sdata_running(sdata))
-			ieee80211_restart_sta_timer(sdata);
-	}
-	rcu_read_unlock();
-}
-
-static int ieee80211_prep_connection(struct ieee80211_sub_if_data *sdata,
-				     struct cfg80211_bss *cbss, s8 link_id,
-				     const u8 *ap_mld_addr, bool assoc,
-				     bool override)
-{
-	struct ieee80211_local *local = sdata->local;
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-	struct ieee80211_bss *bss = (void *)cbss->priv;
-	struct sta_info *new_sta = NULL;
-	struct ieee80211_link_data *link;
-	bool have_sta = false;
-	bool mlo;
-	int err;
-
-	if (link_id >= 0) {
-		mlo = true;
-		if (WARN_ON(!ap_mld_addr))
-			return -EINVAL;
-		err = ieee80211_vif_set_links(sdata, BIT(link_id), 0);
-	} else {
-		if (WARN_ON(ap_mld_addr))
-			return -EINVAL;
-		ap_mld_addr = cbss->bssid;
-		err = ieee80211_vif_set_links(sdata, 0, 0);
-		link_id = 0;
-		mlo = false;
-	}
-
-	if (err)
-		return err;
-
-	link = sdata_dereference(sdata->link[link_id], sdata);
-	if (WARN_ON(!link)) {
-		err = -ENOLINK;
-		goto out_err;
-	}
-
-	if (WARN_ON(!ifmgd->auth_data && !ifmgd->assoc_data)) {
-		err = -EINVAL;
-		goto out_err;
-	}
-
-	/* If a reconfig is happening, bail out */
-	if (local->in_reconfig) {
-		err = -EBUSY;
-		goto out_err;
-	}
-
-	if (assoc) {
-		rcu_read_lock();
-		have_sta = sta_info_get(sdata, ap_mld_addr);
-		rcu_read_unlock();
-	}
-
-	if (!have_sta) {
-		if (mlo)
-			new_sta = sta_info_alloc_with_link(sdata, ap_mld_addr,
-							   link_id, cbss->bssid,
-							   GFP_KERNEL);
-		else
-			new_sta = sta_info_alloc(sdata, ap_mld_addr, GFP_KERNEL);
-
-		if (!new_sta) {
-			err = -ENOMEM;
-			goto out_err;
-		}
-
-		new_sta->sta.mlo = mlo;
-	}
-
-	/*
-	 * Set up the information for the new channel before setting the
-	 * new channel. We can't - completely race-free - change the basic
-	 * rates bitmap and the channel (sband) that it refers to, but if
-	 * we set it up before we at least avoid calling into the driver's
-	 * bss_info_changed() method with invalid information (since we do
-	 * call that from changing the channel - only for IDLE and perhaps
-	 * some others, but ...).
-	 *
-	 * So to avoid that, just set up all the new information before the
-	 * channel, but tell the driver to apply it only afterwards, since
-	 * it might need the new channel for that.
-	 */
-	if (new_sta) {
-		const struct cfg80211_bss_ies *ies;
-		struct link_sta_info *link_sta;
-
-		rcu_read_lock();
-		link_sta = rcu_dereference(new_sta->link[link_id]);
-		if (WARN_ON(!link_sta)) {
-			rcu_read_unlock();
-			sta_info_free(local, new_sta);
-			err = -EINVAL;
-			goto out_err;
-		}
-
-		err = ieee80211_mgd_setup_link_sta(link, new_sta,
-						   link_sta, cbss);
-		if (err) {
-			rcu_read_unlock();
-			sta_info_free(local, new_sta);
-			goto out_err;
-		}
-
-		memcpy(link->u.mgd.bssid, cbss->bssid, ETH_ALEN);
-
-		/* set timing information */
-		link->conf->beacon_int = cbss->beacon_interval;
-		ies = rcu_dereference(cbss->beacon_ies);
-		if (ies) {
-			link->conf->sync_tsf = ies->tsf;
-			link->conf->sync_device_ts =
-				bss->device_ts_beacon;
-
-			ieee80211_get_dtim(ies,
-					   &link->conf->sync_dtim_count,
-					   NULL);
-		} else if (!ieee80211_hw_check(&sdata->local->hw,
-					       TIMING_BEACON_ONLY)) {
-			ies = rcu_dereference(cbss->proberesp_ies);
-			/* must be non-NULL since beacon IEs were NULL */
-			link->conf->sync_tsf = ies->tsf;
-			link->conf->sync_device_ts =
-				bss->device_ts_presp;
-			link->conf->sync_dtim_count = 0;
-		} else {
-			link->conf->sync_tsf = 0;
-			link->conf->sync_device_ts = 0;
-			link->conf->sync_dtim_count = 0;
-		}
-		rcu_read_unlock();
-	}
-
-	if (new_sta || override) {
-		err = ieee80211_prep_channel(sdata, link, cbss,
-					     &link->u.mgd.conn_flags);
-		if (err) {
-			if (new_sta)
-				sta_info_free(local, new_sta);
-			goto out_err;
-		}
-	}
-
-	if (new_sta) {
-		/*
-		 * tell driver about BSSID, basic rates and timing
-		 * this was set up above, before setting the channel
-		 */
-		ieee80211_link_info_change_notify(sdata, link,
-						  BSS_CHANGED_BSSID |
-						  BSS_CHANGED_BASIC_RATES |
-						  BSS_CHANGED_BEACON_INT);
-
-		if (assoc)
-			sta_info_pre_move_state(new_sta, IEEE80211_STA_AUTH);
-
-		err = sta_info_insert(new_sta);
-		new_sta = NULL;
-		if (err) {
-			sdata_info(sdata,
-				   "failed to insert STA entry for the AP (error %d)\n",
-				   err);
-			goto out_release_chan;
-		}
-	} else
-		WARN_ON_ONCE(!ether_addr_equal(link->u.mgd.bssid, cbss->bssid));
-
-	/* Cancel scan to ensure that nothing interferes with connection */
-	if (local->scanning)
-		ieee80211_scan_cancel(local);
-
-	return 0;
-
-out_release_chan:
-	ieee80211_link_release_channel(link);
-out_err:
-	ieee80211_vif_set_links(sdata, 0, 0);
-	return err;
-}
-
-/* config hooks */
-int ieee80211_mgd_auth(struct ieee80211_sub_if_data *sdata,
-		       struct cfg80211_auth_request *req)
-{
-	struct ieee80211_local *local = sdata->local;
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-	struct ieee80211_mgd_auth_data *auth_data;
-	u16 auth_alg;
-	int err;
-	bool cont_auth;
-
-	/* prepare auth data structure */
-
-	switch (req->auth_type) {
-	case NL80211_AUTHTYPE_OPEN_SYSTEM:
-		auth_alg = WLAN_AUTH_OPEN;
-		break;
-	case NL80211_AUTHTYPE_SHARED_KEY:
-		if (fips_enabled)
-			return -EOPNOTSUPP;
-		auth_alg = WLAN_AUTH_SHARED_KEY;
-		break;
-	case NL80211_AUTHTYPE_FT:
-		auth_alg = WLAN_AUTH_FT;
-		break;
-	case NL80211_AUTHTYPE_NETWORK_EAP:
-		auth_alg = WLAN_AUTH_LEAP;
-		break;
-	case NL80211_AUTHTYPE_SAE:
-		auth_alg = WLAN_AUTH_SAE;
-		break;
-	case NL80211_AUTHTYPE_FILS_SK:
-		auth_alg = WLAN_AUTH_FILS_SK;
-		break;
-	case NL80211_AUTHTYPE_FILS_SK_PFS:
-		auth_alg = WLAN_AUTH_FILS_SK_PFS;
-		break;
-	case NL80211_AUTHTYPE_FILS_PK:
-		auth_alg = WLAN_AUTH_FILS_PK;
-		break;
-	default:
-		return -EOPNOTSUPP;
-	}
-
-	if (ifmgd->assoc_data)
-		return -EBUSY;
-
-	auth_data = kzalloc(sizeof(*auth_data) + req->auth_data_len +
-			    req->ie_len, GFP_KERNEL);
-	if (!auth_data)
-		return -ENOMEM;
-
-	memcpy(auth_data->ap_addr,
-	       req->ap_mld_addr ?: req->bss->bssid,
-	       ETH_ALEN);
-	auth_data->bss = req->bss;
-	auth_data->link_id = req->link_id;
-
-	if (req->auth_data_len >= 4) {
-		if (req->auth_type == NL80211_AUTHTYPE_SAE) {
-			__le16 *pos = (__le16 *) req->auth_data;
-
-			auth_data->sae_trans = le16_to_cpu(pos[0]);
-			auth_data->sae_status = le16_to_cpu(pos[1]);
-		}
-		memcpy(auth_data->data, req->auth_data + 4,
-		       req->auth_data_len - 4);
-		auth_data->data_len += req->auth_data_len - 4;
-	}
-
-	/* Check if continuing authentication or trying to authenticate with the
-	 * same BSS that we were in the process of authenticating with and avoid
-	 * removal and re-addition of the STA entry in
-	 * ieee80211_prep_connection().
-	 */
-	cont_auth = ifmgd->auth_data && req->bss == ifmgd->auth_data->bss &&
-		    ifmgd->auth_data->link_id == req->link_id;
-
-	if (req->ie && req->ie_len) {
-		memcpy(&auth_data->data[auth_data->data_len],
-		       req->ie, req->ie_len);
-		auth_data->data_len += req->ie_len;
-	}
-
-	if (req->key && req->key_len) {
-		auth_data->key_len = req->key_len;
-		auth_data->key_idx = req->key_idx;
-		memcpy(auth_data->key, req->key, req->key_len);
-	}
-
-	auth_data->algorithm = auth_alg;
-
-	/* try to authenticate/probe */
-
-	if (ifmgd->auth_data) {
-		if (cont_auth && req->auth_type == NL80211_AUTHTYPE_SAE) {
-			auth_data->peer_confirmed =
-				ifmgd->auth_data->peer_confirmed;
-		}
-		ieee80211_destroy_auth_data(sdata, cont_auth);
-	}
-
-	/* prep auth_data so we don't go into idle on disassoc */
-	ifmgd->auth_data = auth_data;
-
-	/* If this is continuation of an ongoing SAE authentication exchange
-	 * (i.e., request to send SAE Confirm) and the peer has already
-	 * confirmed, mark authentication completed since we are about to send
-	 * out SAE Confirm.
-	 */
-	if (cont_auth && req->auth_type == NL80211_AUTHTYPE_SAE &&
-	    auth_data->peer_confirmed && auth_data->sae_trans == 2)
-		ieee80211_mark_sta_auth(sdata);
-
-	if (ifmgd->associated) {
-		u8 frame_buf[IEEE80211_DEAUTH_FRAME_LEN];
-
-		sdata_info(sdata,
-			   "disconnect from AP %pM for new auth to %pM\n",
-			   sdata->vif.cfg.ap_addr, auth_data->ap_addr);
-		ieee80211_set_disassoc(sdata, IEEE80211_STYPE_DEAUTH,
-				       WLAN_REASON_UNSPECIFIED,
-				       false, frame_buf);
-
-		ieee80211_report_disconnect(sdata, frame_buf,
-					    sizeof(frame_buf), true,
-					    WLAN_REASON_UNSPECIFIED,
-					    false);
-	}
-
-	sdata_info(sdata, "authenticate with %pM\n", auth_data->ap_addr);
-
-	/* needed for transmitting the auth frame(s) properly */
-	memcpy(sdata->vif.cfg.ap_addr, auth_data->ap_addr, ETH_ALEN);
-
-	err = ieee80211_prep_connection(sdata, req->bss, req->link_id,
-					req->ap_mld_addr, cont_auth, false);
-	if (err)
-		goto err_clear;
-
-	err = ieee80211_auth(sdata);
-	if (err) {
-		sta_info_destroy_addr(sdata, auth_data->ap_addr);
-		goto err_clear;
-	}
-
-	/* hold our own reference */
-	cfg80211_ref_bss(local->hw.wiphy, auth_data->bss);
-	return 0;
-
- err_clear:
-	if (!ieee80211_vif_is_mld(&sdata->vif)) {
-		eth_zero_addr(sdata->deflink.u.mgd.bssid);
-		ieee80211_link_info_change_notify(sdata, &sdata->deflink,
-						  BSS_CHANGED_BSSID);
-		mutex_lock(&sdata->local->mtx);
-		ieee80211_link_release_channel(&sdata->deflink);
-		mutex_unlock(&sdata->local->mtx);
-	}
-	ifmgd->auth_data = NULL;
-	kfree(auth_data);
-	return err;
-}
-
-static ieee80211_conn_flags_t
-ieee80211_setup_assoc_link(struct ieee80211_sub_if_data *sdata,
-			   struct ieee80211_mgd_assoc_data *assoc_data,
-			   struct cfg80211_assoc_request *req,
-			   ieee80211_conn_flags_t conn_flags,
-			   unsigned int link_id)
-{
-	struct ieee80211_local *local = sdata->local;
-	const struct cfg80211_bss_ies *beacon_ies;
-	struct ieee80211_supported_band *sband;
-	const struct element *ht_elem, *vht_elem;
-	struct ieee80211_link_data *link;
-	struct cfg80211_bss *cbss;
-	struct ieee80211_bss *bss;
-	bool is_5ghz, is_6ghz;
-
-	cbss = assoc_data->link[link_id].bss;
-	if (WARN_ON(!cbss))
-		return 0;
-
-	bss = (void *)cbss->priv;
-
-	sband = local->hw.wiphy->bands[cbss->channel->band];
-	if (WARN_ON(!sband))
-		return 0;
-
-	link = sdata_dereference(sdata->link[link_id], sdata);
-	if (WARN_ON(!link))
-		return 0;
-
-	is_5ghz = cbss->channel->band == NL80211_BAND_5GHZ;
-	is_6ghz = cbss->channel->band == NL80211_BAND_6GHZ;
-
-	/* for MLO connections assume advertising all rates is OK */
-	if (!req->ap_mld_addr) {
-		assoc_data->supp_rates = bss->supp_rates;
-		assoc_data->supp_rates_len = bss->supp_rates_len;
-	}
-
-	/* copy and link elems for the STA profile */
-	if (req->links[link_id].elems_len) {
-		memcpy(assoc_data->ie_pos, req->links[link_id].elems,
-		       req->links[link_id].elems_len);
-		assoc_data->link[link_id].elems = assoc_data->ie_pos;
-		assoc_data->link[link_id].elems_len = req->links[link_id].elems_len;
-		assoc_data->ie_pos += req->links[link_id].elems_len;
-	}
-
-	rcu_read_lock();
-	ht_elem = ieee80211_bss_get_elem(cbss, WLAN_EID_HT_OPERATION);
-	if (ht_elem && ht_elem->datalen >= sizeof(struct ieee80211_ht_operation))
-		assoc_data->link[link_id].ap_ht_param =
-			((struct ieee80211_ht_operation *)(ht_elem->data))->ht_param;
-	else if (!is_6ghz)
-		conn_flags |= IEEE80211_CONN_DISABLE_HT;
-	vht_elem = ieee80211_bss_get_elem(cbss, WLAN_EID_VHT_CAPABILITY);
-	if (vht_elem && vht_elem->datalen >= sizeof(struct ieee80211_vht_cap)) {
-		memcpy(&assoc_data->link[link_id].ap_vht_cap, vht_elem->data,
-		       sizeof(struct ieee80211_vht_cap));
-	} else if (is_5ghz) {
-		link_info(link,
-			  "VHT capa missing/short, disabling VHT/HE/EHT\n");
-		conn_flags |= IEEE80211_CONN_DISABLE_VHT |
-			      IEEE80211_CONN_DISABLE_HE |
-			      IEEE80211_CONN_DISABLE_EHT;
-	}
-	rcu_read_unlock();
-
-	link->u.mgd.beacon_crc_valid = false;
-	link->u.mgd.dtim_period = 0;
-	link->u.mgd.have_beacon = false;
-
-	/* override HT/VHT configuration only if the AP and we support it */
-	if (!(conn_flags & IEEE80211_CONN_DISABLE_HT)) {
-		struct ieee80211_sta_ht_cap sta_ht_cap;
-
-		memcpy(&sta_ht_cap, &sband->ht_cap, sizeof(sta_ht_cap));
-		ieee80211_apply_htcap_overrides(sdata, &sta_ht_cap);
-	}
-
-	link->conf->eht_puncturing = 0;
-
-	rcu_read_lock();
-	beacon_ies = rcu_dereference(cbss->beacon_ies);
-	if (beacon_ies) {
-		const struct ieee80211_eht_operation *eht_oper;
-		const struct element *elem;
-		u8 dtim_count = 0;
-
-		ieee80211_get_dtim(beacon_ies, &dtim_count,
-				   &link->u.mgd.dtim_period);
-
-		sdata->deflink.u.mgd.have_beacon = true;
-
-		if (ieee80211_hw_check(&local->hw, TIMING_BEACON_ONLY)) {
-			link->conf->sync_tsf = beacon_ies->tsf;
-			link->conf->sync_device_ts = bss->device_ts_beacon;
-			link->conf->sync_dtim_count = dtim_count;
-		}
-
-		elem = cfg80211_find_ext_elem(WLAN_EID_EXT_MULTIPLE_BSSID_CONFIGURATION,
-					      beacon_ies->data, beacon_ies->len);
-		if (elem && elem->datalen >= 3)
-			link->conf->profile_periodicity = elem->data[2];
-		else
-			link->conf->profile_periodicity = 0;
-
-		elem = cfg80211_find_elem(WLAN_EID_EXT_CAPABILITY,
-					  beacon_ies->data, beacon_ies->len);
-		if (elem && elem->datalen >= 11 &&
-		    (elem->data[10] & WLAN_EXT_CAPA11_EMA_SUPPORT))
-			link->conf->ema_ap = true;
-		else
-			link->conf->ema_ap = false;
-
-		elem = cfg80211_find_ext_elem(WLAN_EID_EXT_EHT_OPERATION,
-					      beacon_ies->data, beacon_ies->len);
-		eht_oper = (const void *)(elem->data + 1);
-
-		if (elem &&
-		    ieee80211_eht_oper_size_ok((const void *)(elem->data + 1),
-					       elem->datalen - 1) &&
-		    (eht_oper->params & IEEE80211_EHT_OPER_INFO_PRESENT) &&
-		    (eht_oper->params & IEEE80211_EHT_OPER_DISABLED_SUBCHANNEL_BITMAP_PRESENT)) {
-			const struct ieee80211_eht_operation_info *info =
-				(void *)eht_oper->optional;
-			const u8 *disable_subchannel_bitmap = info->optional;
-			u16 bitmap;
-
-			bitmap = get_unaligned_le16(disable_subchannel_bitmap);
-			if (cfg80211_valid_disable_subchannel_bitmap(&bitmap,
-								     &link->conf->chandef))
-				ieee80211_handle_puncturing_bitmap(link,
-								   eht_oper,
-								   bitmap,
-								   NULL);
-			else
-				conn_flags |= IEEE80211_CONN_DISABLE_EHT;
-		}
-	}
-	rcu_read_unlock();
-
-	if (bss->corrupt_data) {
-		char *corrupt_type = "data";
-
-		if (bss->corrupt_data & IEEE80211_BSS_CORRUPT_BEACON) {
-			if (bss->corrupt_data & IEEE80211_BSS_CORRUPT_PROBE_RESP)
-				corrupt_type = "beacon and probe response";
-			else
-				corrupt_type = "beacon";
-		} else if (bss->corrupt_data & IEEE80211_BSS_CORRUPT_PROBE_RESP) {
-			corrupt_type = "probe response";
-		}
-		sdata_info(sdata, "associating to AP %pM with corrupt %s\n",
-			   cbss->bssid, corrupt_type);
-	}
-
-	if (link->u.mgd.req_smps == IEEE80211_SMPS_AUTOMATIC) {
-		if (sdata->u.mgd.powersave)
-			link->smps_mode = IEEE80211_SMPS_DYNAMIC;
-		else
-			link->smps_mode = IEEE80211_SMPS_OFF;
-	} else {
-		link->smps_mode = link->u.mgd.req_smps;
-	}
-
-	return conn_flags;
-}
-
-int ieee80211_mgd_assoc(struct ieee80211_sub_if_data *sdata,
-			struct cfg80211_assoc_request *req)
-{
-	unsigned int assoc_link_id = req->link_id < 0 ? 0 : req->link_id;
-	struct ieee80211_local *local = sdata->local;
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-	struct ieee80211_mgd_assoc_data *assoc_data;
-	const struct element *ssid_elem;
-	struct ieee80211_vif_cfg *vif_cfg = &sdata->vif.cfg;
-	ieee80211_conn_flags_t conn_flags = 0;
-	struct ieee80211_link_data *link;
-	struct cfg80211_bss *cbss;
-	struct ieee80211_bss *bss;
-	bool override;
-	int i, err;
-	size_t size = sizeof(*assoc_data) + req->ie_len;
-
-	for (i = 0; i < IEEE80211_MLD_MAX_NUM_LINKS; i++)
-		size += req->links[i].elems_len;
-
-	/* FIXME: no support for 4-addr MLO yet */
-	if (sdata->u.mgd.use_4addr && req->link_id >= 0)
-		return -EOPNOTSUPP;
-
-	assoc_data = kzalloc(size, GFP_KERNEL);
-	if (!assoc_data)
-		return -ENOMEM;
-
-	cbss = req->link_id < 0 ? req->bss : req->links[req->link_id].bss;
-
-	rcu_read_lock();
-	ssid_elem = ieee80211_bss_get_elem(cbss, WLAN_EID_SSID);
-	if (!ssid_elem || ssid_elem->datalen > sizeof(assoc_data->ssid)) {
-		rcu_read_unlock();
-		kfree(assoc_data);
-		return -EINVAL;
-	}
-	memcpy(assoc_data->ssid, ssid_elem->data, ssid_elem->datalen);
-	assoc_data->ssid_len = ssid_elem->datalen;
-	memcpy(vif_cfg->ssid, assoc_data->ssid, assoc_data->ssid_len);
-	vif_cfg->ssid_len = assoc_data->ssid_len;
-	rcu_read_unlock();
-
-	if (req->ap_mld_addr) {
-		for (i = 0; i < IEEE80211_MLD_MAX_NUM_LINKS; i++) {
-			if (!req->links[i].bss)
-				continue;
-			link = sdata_dereference(sdata->link[i], sdata);
-			if (link)
-				ether_addr_copy(assoc_data->link[i].addr,
-						link->conf->addr);
-			else
-				eth_random_addr(assoc_data->link[i].addr);
-		}
-	} else {
-		memcpy(assoc_data->link[0].addr, sdata->vif.addr, ETH_ALEN);
-	}
-
-	assoc_data->s1g = cbss->channel->band == NL80211_BAND_S1GHZ;
-
-	memcpy(assoc_data->ap_addr,
-	       req->ap_mld_addr ?: req->bss->bssid,
-	       ETH_ALEN);
-
-	if (ifmgd->associated) {
-		u8 frame_buf[IEEE80211_DEAUTH_FRAME_LEN];
-
-		sdata_info(sdata,
-			   "disconnect from AP %pM for new assoc to %pM\n",
-			   sdata->vif.cfg.ap_addr, assoc_data->ap_addr);
-		ieee80211_set_disassoc(sdata, IEEE80211_STYPE_DEAUTH,
-				       WLAN_REASON_UNSPECIFIED,
-				       false, frame_buf);
-
-		ieee80211_report_disconnect(sdata, frame_buf,
-					    sizeof(frame_buf), true,
-					    WLAN_REASON_UNSPECIFIED,
-					    false);
-	}
-
-	if (ifmgd->auth_data && !ifmgd->auth_data->done) {
-		err = -EBUSY;
-		goto err_free;
-	}
-
-	if (ifmgd->assoc_data) {
-		err = -EBUSY;
-		goto err_free;
-	}
-
-	if (ifmgd->auth_data) {
-		bool match;
-
-		/* keep sta info, bssid if matching */
-		match = ether_addr_equal(ifmgd->auth_data->ap_addr,
-					 assoc_data->ap_addr) &&
-			ifmgd->auth_data->link_id == req->link_id;
-		ieee80211_destroy_auth_data(sdata, match);
-	}
-
-	/* prepare assoc data */
-
-	bss = (void *)cbss->priv;
-	assoc_data->wmm = bss->wmm_used &&
-			  (local->hw.queues >= IEEE80211_NUM_ACS);
-
-	/*
-	 * IEEE802.11n does not allow TKIP/WEP as pairwise ciphers in HT mode.
-	 * We still associate in non-HT mode (11a/b/g) if any one of these
-	 * ciphers is configured as pairwise.
-	 * We can set this to true for non-11n hardware, that'll be checked
-	 * separately along with the peer capabilities.
-	 */
-	for (i = 0; i < req->crypto.n_ciphers_pairwise; i++) {
-		if (req->crypto.ciphers_pairwise[i] == WLAN_CIPHER_SUITE_WEP40 ||
-		    req->crypto.ciphers_pairwise[i] == WLAN_CIPHER_SUITE_TKIP ||
-		    req->crypto.ciphers_pairwise[i] == WLAN_CIPHER_SUITE_WEP104) {
-			conn_flags |= IEEE80211_CONN_DISABLE_HT;
-			conn_flags |= IEEE80211_CONN_DISABLE_VHT;
-			conn_flags |= IEEE80211_CONN_DISABLE_HE;
-			conn_flags |= IEEE80211_CONN_DISABLE_EHT;
-			netdev_info(sdata->dev,
-				    "disabling HT/VHT/HE due to WEP/TKIP use\n");
-		}
-	}
-
-	/* also disable HT/VHT/HE/EHT if the AP doesn't use WMM */
-	if (!bss->wmm_used) {
-		conn_flags |= IEEE80211_CONN_DISABLE_HT;
-		conn_flags |= IEEE80211_CONN_DISABLE_VHT;
-		conn_flags |= IEEE80211_CONN_DISABLE_HE;
-		conn_flags |= IEEE80211_CONN_DISABLE_EHT;
-		netdev_info(sdata->dev,
-			    "disabling HT/VHT/HE as WMM/QoS is not supported by the AP\n");
-	}
-
-	if (req->flags & ASSOC_REQ_DISABLE_HT) {
-		mlme_dbg(sdata, "HT disabled by flag, disabling HT/VHT/HE\n");
-		conn_flags |= IEEE80211_CONN_DISABLE_HT;
-		conn_flags |= IEEE80211_CONN_DISABLE_VHT;
-		conn_flags |= IEEE80211_CONN_DISABLE_HE;
-		conn_flags |= IEEE80211_CONN_DISABLE_EHT;
-	}
-
-	if (req->flags & ASSOC_REQ_DISABLE_VHT) {
-		mlme_dbg(sdata, "VHT disabled by flag, disabling VHT\n");
-		conn_flags |= IEEE80211_CONN_DISABLE_VHT;
-	}
-
-	if (req->flags & ASSOC_REQ_DISABLE_HE) {
-		mlme_dbg(sdata, "HE disabled by flag, disabling HE/EHT\n");
-		conn_flags |= IEEE80211_CONN_DISABLE_HE;
-		conn_flags |= IEEE80211_CONN_DISABLE_EHT;
-	}
-
-	if (req->flags & ASSOC_REQ_DISABLE_EHT)
-		conn_flags |= IEEE80211_CONN_DISABLE_EHT;
-
-	memcpy(&ifmgd->ht_capa, &req->ht_capa, sizeof(ifmgd->ht_capa));
-	memcpy(&ifmgd->ht_capa_mask, &req->ht_capa_mask,
-	       sizeof(ifmgd->ht_capa_mask));
-
-	memcpy(&ifmgd->vht_capa, &req->vht_capa, sizeof(ifmgd->vht_capa));
-	memcpy(&ifmgd->vht_capa_mask, &req->vht_capa_mask,
-	       sizeof(ifmgd->vht_capa_mask));
-
-	memcpy(&ifmgd->s1g_capa, &req->s1g_capa, sizeof(ifmgd->s1g_capa));
-	memcpy(&ifmgd->s1g_capa_mask, &req->s1g_capa_mask,
-	       sizeof(ifmgd->s1g_capa_mask));
-
-	if (req->ie && req->ie_len) {
-		memcpy(assoc_data->ie, req->ie, req->ie_len);
-		assoc_data->ie_len = req->ie_len;
-		assoc_data->ie_pos = assoc_data->ie + assoc_data->ie_len;
-	} else {
-		assoc_data->ie_pos = assoc_data->ie;
-	}
-
-	if (req->fils_kek) {
-		/* should already be checked in cfg80211 - so warn */
-		if (WARN_ON(req->fils_kek_len > FILS_MAX_KEK_LEN)) {
-			err = -EINVAL;
-			goto err_free;
-		}
-		memcpy(assoc_data->fils_kek, req->fils_kek,
-		       req->fils_kek_len);
-		assoc_data->fils_kek_len = req->fils_kek_len;
-	}
-
-	if (req->fils_nonces)
-		memcpy(assoc_data->fils_nonces, req->fils_nonces,
-		       2 * FILS_NONCE_LEN);
-
-	/* default timeout */
-	assoc_data->timeout = jiffies;
-	assoc_data->timeout_started = true;
-
-	assoc_data->assoc_link_id = assoc_link_id;
-
-	if (req->ap_mld_addr) {
-		for (i = 0; i < ARRAY_SIZE(assoc_data->link); i++) {
-			assoc_data->link[i].conn_flags = conn_flags;
-			assoc_data->link[i].bss = req->links[i].bss;
-			assoc_data->link[i].disabled = req->links[i].disabled;
-		}
-
-		/* if there was no authentication, set up the link */
-		err = ieee80211_vif_set_links(sdata, BIT(assoc_link_id), 0);
-		if (err)
-			goto err_clear;
-	} else {
-		assoc_data->link[0].conn_flags = conn_flags;
-		assoc_data->link[0].bss = cbss;
-	}
-
-	link = sdata_dereference(sdata->link[assoc_link_id], sdata);
-	if (WARN_ON(!link)) {
-		err = -EINVAL;
-		goto err_clear;
-	}
-
-	/* keep old conn_flags from ieee80211_prep_channel() from auth */
-	conn_flags |= link->u.mgd.conn_flags;
-	conn_flags |= ieee80211_setup_assoc_link(sdata, assoc_data, req,
-						 conn_flags, assoc_link_id);
-	override = link->u.mgd.conn_flags != conn_flags;
-	link->u.mgd.conn_flags |= conn_flags;
-
-	if (WARN((sdata->vif.driver_flags & IEEE80211_VIF_SUPPORTS_UAPSD) &&
-		 ieee80211_hw_check(&local->hw, PS_NULLFUNC_STACK),
-	     "U-APSD not supported with HW_PS_NULLFUNC_STACK\n"))
-		sdata->vif.driver_flags &= ~IEEE80211_VIF_SUPPORTS_UAPSD;
-
-	if (bss->wmm_used && bss->uapsd_supported &&
-	    (sdata->vif.driver_flags & IEEE80211_VIF_SUPPORTS_UAPSD)) {
-		assoc_data->uapsd = true;
-		ifmgd->flags |= IEEE80211_STA_UAPSD_ENABLED;
-	} else {
-		assoc_data->uapsd = false;
-		ifmgd->flags &= ~IEEE80211_STA_UAPSD_ENABLED;
-	}
-
-	if (req->prev_bssid)
-		memcpy(assoc_data->prev_ap_addr, req->prev_bssid, ETH_ALEN);
-
-	if (req->use_mfp) {
-		ifmgd->mfp = IEEE80211_MFP_REQUIRED;
-		ifmgd->flags |= IEEE80211_STA_MFP_ENABLED;
-	} else {
-		ifmgd->mfp = IEEE80211_MFP_DISABLED;
-		ifmgd->flags &= ~IEEE80211_STA_MFP_ENABLED;
-	}
-
-	if (req->flags & ASSOC_REQ_USE_RRM)
-		ifmgd->flags |= IEEE80211_STA_ENABLE_RRM;
-	else
-		ifmgd->flags &= ~IEEE80211_STA_ENABLE_RRM;
-
-	if (req->crypto.control_port)
-		ifmgd->flags |= IEEE80211_STA_CONTROL_PORT;
-	else
-		ifmgd->flags &= ~IEEE80211_STA_CONTROL_PORT;
-
-	sdata->control_port_protocol = req->crypto.control_port_ethertype;
-	sdata->control_port_no_encrypt = req->crypto.control_port_no_encrypt;
-	sdata->control_port_over_nl80211 =
-					req->crypto.control_port_over_nl80211;
-	sdata->control_port_no_preauth = req->crypto.control_port_no_preauth;
-
-	/* kick off associate process */
-	ifmgd->assoc_data = assoc_data;
-
-	for (i = 0; i < ARRAY_SIZE(assoc_data->link); i++) {
-		if (!assoc_data->link[i].bss)
-			continue;
-		if (i == assoc_data->assoc_link_id)
-			continue;
-		/* only calculate the flags, hence link == NULL */
-		err = ieee80211_prep_channel(sdata, NULL, assoc_data->link[i].bss,
-					     &assoc_data->link[i].conn_flags);
-		if (err)
-			goto err_clear;
-	}
-
-	/* needed for transmitting the assoc frames properly */
-	memcpy(sdata->vif.cfg.ap_addr, assoc_data->ap_addr, ETH_ALEN);
-
-	err = ieee80211_prep_connection(sdata, cbss, req->link_id,
-					req->ap_mld_addr, true, override);
-	if (err)
-		goto err_clear;
-
-	assoc_data->link[assoc_data->assoc_link_id].conn_flags =
-		link->u.mgd.conn_flags;
-
-	if (ieee80211_hw_check(&sdata->local->hw, NEED_DTIM_BEFORE_ASSOC)) {
-		const struct cfg80211_bss_ies *beacon_ies;
-
-		rcu_read_lock();
-		beacon_ies = rcu_dereference(req->bss->beacon_ies);
-		if (!beacon_ies) {
-			/*
-			 * Wait up to one beacon interval ...
-			 * should this be more if we miss one?
-			 */
-			sdata_info(sdata, "waiting for beacon from %pM\n",
-				   link->u.mgd.bssid);
-			assoc_data->timeout = TU_TO_EXP_TIME(req->bss->beacon_interval);
-			assoc_data->timeout_started = true;
-			assoc_data->need_beacon = true;
-		}
-		rcu_read_unlock();
-	}
-
-	run_again(sdata, assoc_data->timeout);
-
-	return 0;
- err_clear:
-	eth_zero_addr(sdata->deflink.u.mgd.bssid);
-	ieee80211_link_info_change_notify(sdata, &sdata->deflink,
-					  BSS_CHANGED_BSSID);
-	ifmgd->assoc_data = NULL;
- err_free:
-	kfree(assoc_data);
-	return err;
-}
-
-int ieee80211_mgd_deauth(struct ieee80211_sub_if_data *sdata,
-			 struct cfg80211_deauth_request *req)
-{
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-	u8 frame_buf[IEEE80211_DEAUTH_FRAME_LEN];
-	bool tx = !req->local_state_change;
-	struct ieee80211_prep_tx_info info = {
-		.subtype = IEEE80211_STYPE_DEAUTH,
-	};
-
-	if (ifmgd->auth_data &&
-	    ether_addr_equal(ifmgd->auth_data->ap_addr, req->bssid)) {
-		sdata_info(sdata,
-			   "aborting authentication with %pM by local choice (Reason: %u=%s)\n",
-			   req->bssid, req->reason_code,
-			   ieee80211_get_reason_code_string(req->reason_code));
-
-		drv_mgd_prepare_tx(sdata->local, sdata, &info);
-		ieee80211_send_deauth_disassoc(sdata, req->bssid, req->bssid,
-					       IEEE80211_STYPE_DEAUTH,
-					       req->reason_code, tx,
-					       frame_buf);
-		ieee80211_destroy_auth_data(sdata, false);
-		ieee80211_report_disconnect(sdata, frame_buf,
-					    sizeof(frame_buf), true,
-					    req->reason_code, false);
-		drv_mgd_complete_tx(sdata->local, sdata, &info);
-		return 0;
-	}
-
-	if (ifmgd->assoc_data &&
-	    ether_addr_equal(ifmgd->assoc_data->ap_addr, req->bssid)) {
-		sdata_info(sdata,
-			   "aborting association with %pM by local choice (Reason: %u=%s)\n",
-			   req->bssid, req->reason_code,
-			   ieee80211_get_reason_code_string(req->reason_code));
-
-		drv_mgd_prepare_tx(sdata->local, sdata, &info);
-		ieee80211_send_deauth_disassoc(sdata, req->bssid, req->bssid,
-					       IEEE80211_STYPE_DEAUTH,
-					       req->reason_code, tx,
-					       frame_buf);
-		ieee80211_destroy_assoc_data(sdata, ASSOC_ABANDON);
-		ieee80211_report_disconnect(sdata, frame_buf,
-					    sizeof(frame_buf), true,
-					    req->reason_code, false);
-		drv_mgd_complete_tx(sdata->local, sdata, &info);
-		return 0;
-	}
-
-	if (ifmgd->associated &&
-	    ether_addr_equal(sdata->vif.cfg.ap_addr, req->bssid)) {
-		sdata_info(sdata,
-			   "deauthenticating from %pM by local choice (Reason: %u=%s)\n",
-			   req->bssid, req->reason_code,
-			   ieee80211_get_reason_code_string(req->reason_code));
-
-		ieee80211_set_disassoc(sdata, IEEE80211_STYPE_DEAUTH,
-				       req->reason_code, tx, frame_buf);
-		ieee80211_report_disconnect(sdata, frame_buf,
-					    sizeof(frame_buf), true,
-					    req->reason_code, false);
-		drv_mgd_complete_tx(sdata->local, sdata, &info);
-		return 0;
-	}
-
-	return -ENOTCONN;
-}
-
-int ieee80211_mgd_disassoc(struct ieee80211_sub_if_data *sdata,
-			   struct cfg80211_disassoc_request *req)
-{
-	u8 frame_buf[IEEE80211_DEAUTH_FRAME_LEN];
-
-	if (!sdata->u.mgd.associated ||
-	    memcmp(sdata->vif.cfg.ap_addr, req->ap_addr, ETH_ALEN))
-		return -ENOTCONN;
-
-	sdata_info(sdata,
-		   "disassociating from %pM by local choice (Reason: %u=%s)\n",
-		   req->ap_addr, req->reason_code,
-		   ieee80211_get_reason_code_string(req->reason_code));
-
-	ieee80211_set_disassoc(sdata, IEEE80211_STYPE_DISASSOC,
-			       req->reason_code, !req->local_state_change,
-			       frame_buf);
-
-	ieee80211_report_disconnect(sdata, frame_buf, sizeof(frame_buf), true,
-				    req->reason_code, false);
-
-	return 0;
-}
-
-void ieee80211_mgd_stop_link(struct ieee80211_link_data *link)
-{
-	wiphy_work_cancel(link->sdata->local->hw.wiphy,
-			  &link->u.mgd.request_smps_work);
-	wiphy_delayed_work_cancel(link->sdata->local->hw.wiphy,
-				  &link->u.mgd.chswitch_work);
-}
-
-void ieee80211_mgd_stop(struct ieee80211_sub_if_data *sdata)
-{
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-
-	/*
-	 * Make sure some work items will not run after this,
-	 * they will not do anything but might not have been
-	 * cancelled when disconnecting.
-	 */
-	cancel_work_sync(&ifmgd->monitor_work);
-	wiphy_work_cancel(sdata->local->hw.wiphy,
-			  &ifmgd->beacon_connection_loss_work);
-	wiphy_work_cancel(sdata->local->hw.wiphy,
-			  &ifmgd->csa_connection_drop_work);
-	cancel_delayed_work_sync(&ifmgd->tdls_peer_del_work);
-	wiphy_delayed_work_cancel(sdata->local->hw.wiphy,
-				  &ifmgd->ml_reconf_work);
-
-	sdata_lock(sdata);
-	if (ifmgd->assoc_data)
-		ieee80211_destroy_assoc_data(sdata, ASSOC_TIMEOUT);
-	if (ifmgd->auth_data)
-		ieee80211_destroy_auth_data(sdata, false);
-	spin_lock_bh(&ifmgd->teardown_lock);
-	if (ifmgd->teardown_skb) {
-		kfree_skb(ifmgd->teardown_skb);
-		ifmgd->teardown_skb = NULL;
-		ifmgd->orig_teardown_skb = NULL;
-	}
-	kfree(ifmgd->assoc_req_ies);
-	ifmgd->assoc_req_ies = NULL;
-	ifmgd->assoc_req_ies_len = 0;
-	spin_unlock_bh(&ifmgd->teardown_lock);
-	del_timer_sync(&ifmgd->timer);
-	sdata_unlock(sdata);
-}
-
-void ieee80211_cqm_rssi_notify(struct ieee80211_vif *vif,
-			       enum nl80211_cqm_rssi_threshold_event rssi_event,
-			       s32 rssi_level,
-			       gfp_t gfp)
-{
-	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
-
-	trace_api_cqm_rssi_notify(sdata, rssi_event, rssi_level);
-
-	cfg80211_cqm_rssi_notify(sdata->dev, rssi_event, rssi_level, gfp);
-}
-EXPORT_SYMBOL(ieee80211_cqm_rssi_notify);
-
-void ieee80211_cqm_beacon_loss_notify(struct ieee80211_vif *vif, gfp_t gfp)
-{
-	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
-
-	trace_api_cqm_beacon_loss_notify(sdata->local, sdata);
-
-	cfg80211_cqm_beacon_loss_notify(sdata->dev, gfp);
-}
-EXPORT_SYMBOL(ieee80211_cqm_beacon_loss_notify);
-
-static void _ieee80211_enable_rssi_reports(struct ieee80211_sub_if_data *sdata,
-					    int rssi_min_thold,
-					    int rssi_max_thold)
-{
-	trace_api_enable_rssi_reports(sdata, rssi_min_thold, rssi_max_thold);
-
-	if (WARN_ON(sdata->vif.type != NL80211_IFTYPE_STATION))
-		return;
-
-	/*
-	 * Scale up threshold values before storing it, as the RSSI averaging
-	 * algorithm uses a scaled up value as well. Change this scaling
-	 * factor if the RSSI averaging algorithm changes.
-	 */
-	sdata->u.mgd.rssi_min_thold = rssi_min_thold*16;
-	sdata->u.mgd.rssi_max_thold = rssi_max_thold*16;
-}
-
-void ieee80211_enable_rssi_reports(struct ieee80211_vif *vif,
-				    int rssi_min_thold,
-				    int rssi_max_thold)
-{
-	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
-
-	WARN_ON(rssi_min_thold == rssi_max_thold ||
-		rssi_min_thold > rssi_max_thold);
-
-	_ieee80211_enable_rssi_reports(sdata, rssi_min_thold,
-				       rssi_max_thold);
-}
-EXPORT_SYMBOL(ieee80211_enable_rssi_reports);
-
-void ieee80211_disable_rssi_reports(struct ieee80211_vif *vif)
-{
-	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
-
-	_ieee80211_enable_rssi_reports(sdata, 0, 0);
-}
-EXPORT_SYMBOL(ieee80211_disable_rssi_reports);
diff --git a/net/mac80211/util.c.orig b/net/mac80211/util.c.orig
deleted file mode 100644
index 154b41af4157..000000000000
--- a/net/mac80211/util.c.orig
+++ /dev/null
@@ -1,5168 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * Copyright 2002-2005, Instant802 Networks, Inc.
- * Copyright 2005-2006, Devicescape Software, Inc.
- * Copyright 2006-2007	Jiri Benc <jbenc@suse.cz>
- * Copyright 2007	Johannes Berg <johannes@sipsolutions.net>
- * Copyright 2013-2014  Intel Mobile Communications GmbH
- * Copyright (C) 2015-2017	Intel Deutschland GmbH
- * Copyright (C) 2018-2023 Intel Corporation
- *
- * utilities for mac80211
- */
-
-#include <net/mac80211.h>
-#include <linux/netdevice.h>
-#include <linux/export.h>
-#include <linux/types.h>
-#include <linux/slab.h>
-#include <linux/skbuff.h>
-#include <linux/etherdevice.h>
-#include <linux/if_arp.h>
-#include <linux/bitmap.h>
-#include <linux/crc32.h>
-#include <net/net_namespace.h>
-#include <net/cfg80211.h>
-#include <net/rtnetlink.h>
-
-#include "ieee80211_i.h"
-#include "driver-ops.h"
-#include "rate.h"
-#include "mesh.h"
-#include "wme.h"
-#include "led.h"
-#include "wep.h"
-
-/* privid for wiphys to determine whether they belong to us or not */
-const void *const mac80211_wiphy_privid = &mac80211_wiphy_privid;
-
-struct ieee80211_hw *wiphy_to_ieee80211_hw(struct wiphy *wiphy)
-{
-	struct ieee80211_local *local;
-
-	local = wiphy_priv(wiphy);
-	return &local->hw;
-}
-EXPORT_SYMBOL(wiphy_to_ieee80211_hw);
-
-u8 *ieee80211_get_bssid(struct ieee80211_hdr *hdr, size_t len,
-			enum nl80211_iftype type)
-{
-	__le16 fc = hdr->frame_control;
-
-	if (ieee80211_is_data(fc)) {
-		if (len < 24) /* drop incorrect hdr len (data) */
-			return NULL;
-
-		if (ieee80211_has_a4(fc))
-			return NULL;
-		if (ieee80211_has_tods(fc))
-			return hdr->addr1;
-		if (ieee80211_has_fromds(fc))
-			return hdr->addr2;
-
-		return hdr->addr3;
-	}
-
-	if (ieee80211_is_s1g_beacon(fc)) {
-		struct ieee80211_ext *ext = (void *) hdr;
-
-		return ext->u.s1g_beacon.sa;
-	}
-
-	if (ieee80211_is_mgmt(fc)) {
-		if (len < 24) /* drop incorrect hdr len (mgmt) */
-			return NULL;
-		return hdr->addr3;
-	}
-
-	if (ieee80211_is_ctl(fc)) {
-		if (ieee80211_is_pspoll(fc))
-			return hdr->addr1;
-
-		if (ieee80211_is_back_req(fc)) {
-			switch (type) {
-			case NL80211_IFTYPE_STATION:
-				return hdr->addr2;
-			case NL80211_IFTYPE_AP:
-			case NL80211_IFTYPE_AP_VLAN:
-				return hdr->addr1;
-			default:
-				break; /* fall through to the return */
-			}
-		}
-	}
-
-	return NULL;
-}
-EXPORT_SYMBOL(ieee80211_get_bssid);
-
-void ieee80211_tx_set_protected(struct ieee80211_tx_data *tx)
-{
-	struct sk_buff *skb;
-	struct ieee80211_hdr *hdr;
-
-	skb_queue_walk(&tx->skbs, skb) {
-		hdr = (struct ieee80211_hdr *) skb->data;
-		hdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_PROTECTED);
-	}
-}
-
-int ieee80211_frame_duration(enum nl80211_band band, size_t len,
-			     int rate, int erp, int short_preamble,
-			     int shift)
-{
-	int dur;
-
-	/* calculate duration (in microseconds, rounded up to next higher
-	 * integer if it includes a fractional microsecond) to send frame of
-	 * len bytes (does not include FCS) at the given rate. Duration will
-	 * also include SIFS.
-	 *
-	 * rate is in 100 kbps, so divident is multiplied by 10 in the
-	 * DIV_ROUND_UP() operations.
-	 *
-	 * shift may be 2 for 5 MHz channels or 1 for 10 MHz channels, and
-	 * is assumed to be 0 otherwise.
-	 */
-
-	if (band == NL80211_BAND_5GHZ || erp) {
-		/*
-		 * OFDM:
-		 *
-		 * N_DBPS = DATARATE x 4
-		 * N_SYM = Ceiling((16+8xLENGTH+6) / N_DBPS)
-		 *	(16 = SIGNAL time, 6 = tail bits)
-		 * TXTIME = T_PREAMBLE + T_SIGNAL + T_SYM x N_SYM + Signal Ext
-		 *
-		 * T_SYM = 4 usec
-		 * 802.11a - 18.5.2: aSIFSTime = 16 usec
-		 * 802.11g - 19.8.4: aSIFSTime = 10 usec +
-		 *	signal ext = 6 usec
-		 */
-		dur = 16; /* SIFS + signal ext */
-		dur += 16; /* IEEE 802.11-2012 18.3.2.4: T_PREAMBLE = 16 usec */
-		dur += 4; /* IEEE 802.11-2012 18.3.2.4: T_SIGNAL = 4 usec */
-
-		/* IEEE 802.11-2012 18.3.2.4: all values above are:
-		 *  * times 4 for 5 MHz
-		 *  * times 2 for 10 MHz
-		 */
-		dur *= 1 << shift;
-
-		/* rates should already consider the channel bandwidth,
-		 * don't apply divisor again.
-		 */
-		dur += 4 * DIV_ROUND_UP((16 + 8 * (len + 4) + 6) * 10,
-					4 * rate); /* T_SYM x N_SYM */
-	} else {
-		/*
-		 * 802.11b or 802.11g with 802.11b compatibility:
-		 * 18.3.4: TXTIME = PreambleLength + PLCPHeaderTime +
-		 * Ceiling(((LENGTH+PBCC)x8)/DATARATE). PBCC=0.
-		 *
-		 * 802.11 (DS): 15.3.3, 802.11b: 18.3.4
-		 * aSIFSTime = 10 usec
-		 * aPreambleLength = 144 usec or 72 usec with short preamble
-		 * aPLCPHeaderLength = 48 usec or 24 usec with short preamble
-		 */
-		dur = 10; /* aSIFSTime = 10 usec */
-		dur += short_preamble ? (72 + 24) : (144 + 48);
-
-		dur += DIV_ROUND_UP(8 * (len + 4) * 10, rate);
-	}
-
-	return dur;
-}
-
-/* Exported duration function for driver use */
-__le16 ieee80211_generic_frame_duration(struct ieee80211_hw *hw,
-					struct ieee80211_vif *vif,
-					enum nl80211_band band,
-					size_t frame_len,
-					struct ieee80211_rate *rate)
-{
-	struct ieee80211_sub_if_data *sdata;
-	u16 dur;
-	int erp, shift = 0;
-	bool short_preamble = false;
-
-	erp = 0;
-	if (vif) {
-		sdata = vif_to_sdata(vif);
-		short_preamble = sdata->vif.bss_conf.use_short_preamble;
-		if (sdata->deflink.operating_11g_mode)
-			erp = rate->flags & IEEE80211_RATE_ERP_G;
-		shift = ieee80211_vif_get_shift(vif);
-	}
-
-	dur = ieee80211_frame_duration(band, frame_len, rate->bitrate, erp,
-				       short_preamble, shift);
-
-	return cpu_to_le16(dur);
-}
-EXPORT_SYMBOL(ieee80211_generic_frame_duration);
-
-__le16 ieee80211_rts_duration(struct ieee80211_hw *hw,
-			      struct ieee80211_vif *vif, size_t frame_len,
-			      const struct ieee80211_tx_info *frame_txctl)
-{
-	struct ieee80211_local *local = hw_to_local(hw);
-	struct ieee80211_rate *rate;
-	struct ieee80211_sub_if_data *sdata;
-	bool short_preamble;
-	int erp, shift = 0, bitrate;
-	u16 dur;
-	struct ieee80211_supported_band *sband;
-
-	sband = local->hw.wiphy->bands[frame_txctl->band];
-
-	short_preamble = false;
-
-	rate = &sband->bitrates[frame_txctl->control.rts_cts_rate_idx];
-
-	erp = 0;
-	if (vif) {
-		sdata = vif_to_sdata(vif);
-		short_preamble = sdata->vif.bss_conf.use_short_preamble;
-		if (sdata->deflink.operating_11g_mode)
-			erp = rate->flags & IEEE80211_RATE_ERP_G;
-		shift = ieee80211_vif_get_shift(vif);
-	}
-
-	bitrate = DIV_ROUND_UP(rate->bitrate, 1 << shift);
-
-	/* CTS duration */
-	dur = ieee80211_frame_duration(sband->band, 10, bitrate,
-				       erp, short_preamble, shift);
-	/* Data frame duration */
-	dur += ieee80211_frame_duration(sband->band, frame_len, bitrate,
-					erp, short_preamble, shift);
-	/* ACK duration */
-	dur += ieee80211_frame_duration(sband->band, 10, bitrate,
-					erp, short_preamble, shift);
-
-	return cpu_to_le16(dur);
-}
-EXPORT_SYMBOL(ieee80211_rts_duration);
-
-__le16 ieee80211_ctstoself_duration(struct ieee80211_hw *hw,
-				    struct ieee80211_vif *vif,
-				    size_t frame_len,
-				    const struct ieee80211_tx_info *frame_txctl)
-{
-	struct ieee80211_local *local = hw_to_local(hw);
-	struct ieee80211_rate *rate;
-	struct ieee80211_sub_if_data *sdata;
-	bool short_preamble;
-	int erp, shift = 0, bitrate;
-	u16 dur;
-	struct ieee80211_supported_band *sband;
-
-	sband = local->hw.wiphy->bands[frame_txctl->band];
-
-	short_preamble = false;
-
-	rate = &sband->bitrates[frame_txctl->control.rts_cts_rate_idx];
-	erp = 0;
-	if (vif) {
-		sdata = vif_to_sdata(vif);
-		short_preamble = sdata->vif.bss_conf.use_short_preamble;
-		if (sdata->deflink.operating_11g_mode)
-			erp = rate->flags & IEEE80211_RATE_ERP_G;
-		shift = ieee80211_vif_get_shift(vif);
-	}
-
-	bitrate = DIV_ROUND_UP(rate->bitrate, 1 << shift);
-
-	/* Data frame duration */
-	dur = ieee80211_frame_duration(sband->band, frame_len, bitrate,
-				       erp, short_preamble, shift);
-	if (!(frame_txctl->flags & IEEE80211_TX_CTL_NO_ACK)) {
-		/* ACK duration */
-		dur += ieee80211_frame_duration(sband->band, 10, bitrate,
-						erp, short_preamble, shift);
-	}
-
-	return cpu_to_le16(dur);
-}
-EXPORT_SYMBOL(ieee80211_ctstoself_duration);
-
-static void wake_tx_push_queue(struct ieee80211_local *local,
-			       struct ieee80211_sub_if_data *sdata,
-			       struct ieee80211_txq *queue)
-{
-	struct ieee80211_tx_control control = {
-		.sta = queue->sta,
-	};
-	struct sk_buff *skb;
-
-	while (1) {
-		skb = ieee80211_tx_dequeue(&local->hw, queue);
-		if (!skb)
-			break;
-
-		drv_tx(local, &control, skb);
-	}
-}
-
-/* wake_tx_queue handler for driver not implementing a custom one*/
-void ieee80211_handle_wake_tx_queue(struct ieee80211_hw *hw,
-				    struct ieee80211_txq *txq)
-{
-	struct ieee80211_local *local = hw_to_local(hw);
-	struct ieee80211_sub_if_data *sdata = vif_to_sdata(txq->vif);
-	struct ieee80211_txq *queue;
-
-	spin_lock(&local->handle_wake_tx_queue_lock);
-
-	/* Use ieee80211_next_txq() for airtime fairness accounting */
-	ieee80211_txq_schedule_start(hw, txq->ac);
-	while ((queue = ieee80211_next_txq(hw, txq->ac))) {
-		wake_tx_push_queue(local, sdata, queue);
-		ieee80211_return_txq(hw, queue, false);
-	}
-	ieee80211_txq_schedule_end(hw, txq->ac);
-	spin_unlock(&local->handle_wake_tx_queue_lock);
-}
-EXPORT_SYMBOL(ieee80211_handle_wake_tx_queue);
-
-static void __ieee80211_wake_txqs(struct ieee80211_sub_if_data *sdata, int ac)
-{
-	struct ieee80211_local *local = sdata->local;
-	struct ieee80211_vif *vif = &sdata->vif;
-	struct fq *fq = &local->fq;
-	struct ps_data *ps = NULL;
-	struct txq_info *txqi;
-	struct sta_info *sta;
-	int i;
-
-	local_bh_disable();
-	spin_lock(&fq->lock);
-
-	if (!test_bit(SDATA_STATE_RUNNING, &sdata->state))
-		goto out;
-
-	if (sdata->vif.type == NL80211_IFTYPE_AP)
-		ps = &sdata->bss->ps;
-
-	list_for_each_entry_rcu(sta, &local->sta_list, list) {
-		if (sdata != sta->sdata)
-			continue;
-
-		for (i = 0; i < ARRAY_SIZE(sta->sta.txq); i++) {
-			struct ieee80211_txq *txq = sta->sta.txq[i];
-
-			if (!txq)
-				continue;
-
-			txqi = to_txq_info(txq);
-
-			if (ac != txq->ac)
-				continue;
-
-			if (!test_and_clear_bit(IEEE80211_TXQ_DIRTY,
-						&txqi->flags))
-				continue;
-
-			spin_unlock(&fq->lock);
-			drv_wake_tx_queue(local, txqi);
-			spin_lock(&fq->lock);
-		}
-	}
-
-	if (!vif->txq)
-		goto out;
-
-	txqi = to_txq_info(vif->txq);
-
-	if (!test_and_clear_bit(IEEE80211_TXQ_DIRTY, &txqi->flags) ||
-	    (ps && atomic_read(&ps->num_sta_ps)) || ac != vif->txq->ac)
-		goto out;
-
-	spin_unlock(&fq->lock);
-
-	drv_wake_tx_queue(local, txqi);
-	local_bh_enable();
-	return;
-out:
-	spin_unlock(&fq->lock);
-	local_bh_enable();
-}
-
-static void
-__releases(&local->queue_stop_reason_lock)
-__acquires(&local->queue_stop_reason_lock)
-_ieee80211_wake_txqs(struct ieee80211_local *local, unsigned long *flags)
-{
-	struct ieee80211_sub_if_data *sdata;
-	int n_acs = IEEE80211_NUM_ACS;
-	int i;
-
-	rcu_read_lock();
-
-	if (local->hw.queues < IEEE80211_NUM_ACS)
-		n_acs = 1;
-
-	for (i = 0; i < local->hw.queues; i++) {
-		if (local->queue_stop_reasons[i])
-			continue;
-
-		spin_unlock_irqrestore(&local->queue_stop_reason_lock, *flags);
-		list_for_each_entry_rcu(sdata, &local->interfaces, list) {
-			int ac;
-
-			for (ac = 0; ac < n_acs; ac++) {
-				int ac_queue = sdata->vif.hw_queue[ac];
-
-				if (ac_queue == i ||
-				    sdata->vif.cab_queue == i)
-					__ieee80211_wake_txqs(sdata, ac);
-			}
-		}
-		spin_lock_irqsave(&local->queue_stop_reason_lock, *flags);
-	}
-
-	rcu_read_unlock();
-}
-
-void ieee80211_wake_txqs(struct tasklet_struct *t)
-{
-	struct ieee80211_local *local = from_tasklet(local, t,
-						     wake_txqs_tasklet);
-	unsigned long flags;
-
-	spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
-	_ieee80211_wake_txqs(local, &flags);
-	spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
-}
-
-static void __ieee80211_wake_queue(struct ieee80211_hw *hw, int queue,
-				   enum queue_stop_reason reason,
-				   bool refcounted,
-				   unsigned long *flags)
-{
-	struct ieee80211_local *local = hw_to_local(hw);
-
-	trace_wake_queue(local, queue, reason);
-
-	if (WARN_ON(queue >= hw->queues))
-		return;
-
-	if (!test_bit(reason, &local->queue_stop_reasons[queue]))
-		return;
-
-	if (!refcounted) {
-		local->q_stop_reasons[queue][reason] = 0;
-	} else {
-		local->q_stop_reasons[queue][reason]--;
-		if (WARN_ON(local->q_stop_reasons[queue][reason] < 0))
-			local->q_stop_reasons[queue][reason] = 0;
-	}
-
-	if (local->q_stop_reasons[queue][reason] == 0)
-		__clear_bit(reason, &local->queue_stop_reasons[queue]);
-
-	if (local->queue_stop_reasons[queue] != 0)
-		/* someone still has this queue stopped */
-		return;
-
-	if (!skb_queue_empty(&local->pending[queue]))
-		tasklet_schedule(&local->tx_pending_tasklet);
-
-	/*
-	 * Calling _ieee80211_wake_txqs here can be a problem because it may
-	 * release queue_stop_reason_lock which has been taken by
-	 * __ieee80211_wake_queue's caller. It is certainly not very nice to
-	 * release someone's lock, but it is fine because all the callers of
-	 * __ieee80211_wake_queue call it right before releasing the lock.
-	 */
-	if (reason == IEEE80211_QUEUE_STOP_REASON_DRIVER)
-		tasklet_schedule(&local->wake_txqs_tasklet);
-	else
-		_ieee80211_wake_txqs(local, flags);
-}
-
-void ieee80211_wake_queue_by_reason(struct ieee80211_hw *hw, int queue,
-				    enum queue_stop_reason reason,
-				    bool refcounted)
-{
-	struct ieee80211_local *local = hw_to_local(hw);
-	unsigned long flags;
-
-	spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
-	__ieee80211_wake_queue(hw, queue, reason, refcounted, &flags);
-	spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
-}
-
-void ieee80211_wake_queue(struct ieee80211_hw *hw, int queue)
-{
-	ieee80211_wake_queue_by_reason(hw, queue,
-				       IEEE80211_QUEUE_STOP_REASON_DRIVER,
-				       false);
-}
-EXPORT_SYMBOL(ieee80211_wake_queue);
-
-static void __ieee80211_stop_queue(struct ieee80211_hw *hw, int queue,
-				   enum queue_stop_reason reason,
-				   bool refcounted)
-{
-	struct ieee80211_local *local = hw_to_local(hw);
-
-	trace_stop_queue(local, queue, reason);
-
-	if (WARN_ON(queue >= hw->queues))
-		return;
-
-	if (!refcounted)
-		local->q_stop_reasons[queue][reason] = 1;
-	else
-		local->q_stop_reasons[queue][reason]++;
-
-	set_bit(reason, &local->queue_stop_reasons[queue]);
-}
-
-void ieee80211_stop_queue_by_reason(struct ieee80211_hw *hw, int queue,
-				    enum queue_stop_reason reason,
-				    bool refcounted)
-{
-	struct ieee80211_local *local = hw_to_local(hw);
-	unsigned long flags;
-
-	spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
-	__ieee80211_stop_queue(hw, queue, reason, refcounted);
-	spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
-}
-
-void ieee80211_stop_queue(struct ieee80211_hw *hw, int queue)
-{
-	ieee80211_stop_queue_by_reason(hw, queue,
-				       IEEE80211_QUEUE_STOP_REASON_DRIVER,
-				       false);
-}
-EXPORT_SYMBOL(ieee80211_stop_queue);
-
-void ieee80211_add_pending_skb(struct ieee80211_local *local,
-			       struct sk_buff *skb)
-{
-	struct ieee80211_hw *hw = &local->hw;
-	unsigned long flags;
-	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
-	int queue = info->hw_queue;
-
-	if (WARN_ON(!info->control.vif)) {
-		ieee80211_free_txskb(&local->hw, skb);
-		return;
-	}
-
-	spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
-	__ieee80211_stop_queue(hw, queue, IEEE80211_QUEUE_STOP_REASON_SKB_ADD,
-			       false);
-	__skb_queue_tail(&local->pending[queue], skb);
-	__ieee80211_wake_queue(hw, queue, IEEE80211_QUEUE_STOP_REASON_SKB_ADD,
-			       false, &flags);
-	spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
-}
-
-void ieee80211_add_pending_skbs(struct ieee80211_local *local,
-				struct sk_buff_head *skbs)
-{
-	struct ieee80211_hw *hw = &local->hw;
-	struct sk_buff *skb;
-	unsigned long flags;
-	int queue, i;
-
-	spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
-	while ((skb = skb_dequeue(skbs))) {
-		struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
-
-		if (WARN_ON(!info->control.vif)) {
-			ieee80211_free_txskb(&local->hw, skb);
-			continue;
-		}
-
-		queue = info->hw_queue;
-
-		__ieee80211_stop_queue(hw, queue,
-				IEEE80211_QUEUE_STOP_REASON_SKB_ADD,
-				false);
-
-		__skb_queue_tail(&local->pending[queue], skb);
-	}
-
-	for (i = 0; i < hw->queues; i++)
-		__ieee80211_wake_queue(hw, i,
-			IEEE80211_QUEUE_STOP_REASON_SKB_ADD,
-			false, &flags);
-	spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
-}
-
-void ieee80211_stop_queues_by_reason(struct ieee80211_hw *hw,
-				     unsigned long queues,
-				     enum queue_stop_reason reason,
-				     bool refcounted)
-{
-	struct ieee80211_local *local = hw_to_local(hw);
-	unsigned long flags;
-	int i;
-
-	spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
-
-	for_each_set_bit(i, &queues, hw->queues)
-		__ieee80211_stop_queue(hw, i, reason, refcounted);
-
-	spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
-}
-
-void ieee80211_stop_queues(struct ieee80211_hw *hw)
-{
-	ieee80211_stop_queues_by_reason(hw, IEEE80211_MAX_QUEUE_MAP,
-					IEEE80211_QUEUE_STOP_REASON_DRIVER,
-					false);
-}
-EXPORT_SYMBOL(ieee80211_stop_queues);
-
-int ieee80211_queue_stopped(struct ieee80211_hw *hw, int queue)
-{
-	struct ieee80211_local *local = hw_to_local(hw);
-	unsigned long flags;
-	int ret;
-
-	if (WARN_ON(queue >= hw->queues))
-		return true;
-
-	spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
-	ret = test_bit(IEEE80211_QUEUE_STOP_REASON_DRIVER,
-		       &local->queue_stop_reasons[queue]);
-	spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
-	return ret;
-}
-EXPORT_SYMBOL(ieee80211_queue_stopped);
-
-void ieee80211_wake_queues_by_reason(struct ieee80211_hw *hw,
-				     unsigned long queues,
-				     enum queue_stop_reason reason,
-				     bool refcounted)
-{
-	struct ieee80211_local *local = hw_to_local(hw);
-	unsigned long flags;
-	int i;
-
-	spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
-
-	for_each_set_bit(i, &queues, hw->queues)
-		__ieee80211_wake_queue(hw, i, reason, refcounted, &flags);
-
-	spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
-}
-
-void ieee80211_wake_queues(struct ieee80211_hw *hw)
-{
-	ieee80211_wake_queues_by_reason(hw, IEEE80211_MAX_QUEUE_MAP,
-					IEEE80211_QUEUE_STOP_REASON_DRIVER,
-					false);
-}
-EXPORT_SYMBOL(ieee80211_wake_queues);
-
-static unsigned int
-ieee80211_get_vif_queues(struct ieee80211_local *local,
-			 struct ieee80211_sub_if_data *sdata)
-{
-	unsigned int queues;
-
-	if (sdata && ieee80211_hw_check(&local->hw, QUEUE_CONTROL)) {
-		int ac;
-
-		queues = 0;
-
-		for (ac = 0; ac < IEEE80211_NUM_ACS; ac++)
-			queues |= BIT(sdata->vif.hw_queue[ac]);
-		if (sdata->vif.cab_queue != IEEE80211_INVAL_HW_QUEUE)
-			queues |= BIT(sdata->vif.cab_queue);
-	} else {
-		/* all queues */
-		queues = BIT(local->hw.queues) - 1;
-	}
-
-	return queues;
-}
-
-void __ieee80211_flush_queues(struct ieee80211_local *local,
-			      struct ieee80211_sub_if_data *sdata,
-			      unsigned int queues, bool drop)
-{
-	if (!local->ops->flush)
-		return;
-
-	/*
-	 * If no queue was set, or if the HW doesn't support
-	 * IEEE80211_HW_QUEUE_CONTROL - flush all queues
-	 */
-	if (!queues || !ieee80211_hw_check(&local->hw, QUEUE_CONTROL))
-		queues = ieee80211_get_vif_queues(local, sdata);
-
-	ieee80211_stop_queues_by_reason(&local->hw, queues,
-					IEEE80211_QUEUE_STOP_REASON_FLUSH,
-					false);
-
-	drv_flush(local, sdata, queues, drop);
-
-	ieee80211_wake_queues_by_reason(&local->hw, queues,
-					IEEE80211_QUEUE_STOP_REASON_FLUSH,
-					false);
-}
-
-void ieee80211_flush_queues(struct ieee80211_local *local,
-			    struct ieee80211_sub_if_data *sdata, bool drop)
-{
-	__ieee80211_flush_queues(local, sdata, 0, drop);
-}
-
-void ieee80211_stop_vif_queues(struct ieee80211_local *local,
-			       struct ieee80211_sub_if_data *sdata,
-			       enum queue_stop_reason reason)
-{
-	ieee80211_stop_queues_by_reason(&local->hw,
-					ieee80211_get_vif_queues(local, sdata),
-					reason, true);
-}
-
-void ieee80211_wake_vif_queues(struct ieee80211_local *local,
-			       struct ieee80211_sub_if_data *sdata,
-			       enum queue_stop_reason reason)
-{
-	ieee80211_wake_queues_by_reason(&local->hw,
-					ieee80211_get_vif_queues(local, sdata),
-					reason, true);
-}
-
-static void __iterate_interfaces(struct ieee80211_local *local,
-				 u32 iter_flags,
-				 void (*iterator)(void *data, u8 *mac,
-						  struct ieee80211_vif *vif),
-				 void *data)
-{
-	struct ieee80211_sub_if_data *sdata;
-	bool active_only = iter_flags & IEEE80211_IFACE_ITER_ACTIVE;
-
-	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
-		switch (sdata->vif.type) {
-		case NL80211_IFTYPE_MONITOR:
-			if (!(sdata->u.mntr.flags & MONITOR_FLAG_ACTIVE))
-				continue;
-			break;
-		case NL80211_IFTYPE_AP_VLAN:
-			continue;
-		default:
-			break;
-		}
-		if (!(iter_flags & IEEE80211_IFACE_ITER_RESUME_ALL) &&
-		    active_only && !(sdata->flags & IEEE80211_SDATA_IN_DRIVER))
-			continue;
-		if ((iter_flags & IEEE80211_IFACE_SKIP_SDATA_NOT_IN_DRIVER) &&
-		    !(sdata->flags & IEEE80211_SDATA_IN_DRIVER))
-			continue;
-		if (ieee80211_sdata_running(sdata) || !active_only)
-			iterator(data, sdata->vif.addr,
-				 &sdata->vif);
-	}
-
-	sdata = rcu_dereference_check(local->monitor_sdata,
-				      lockdep_is_held(&local->iflist_mtx) ||
-				      lockdep_is_held(&local->hw.wiphy->mtx));
-	if (sdata &&
-	    (iter_flags & IEEE80211_IFACE_ITER_RESUME_ALL || !active_only ||
-	     sdata->flags & IEEE80211_SDATA_IN_DRIVER))
-		iterator(data, sdata->vif.addr, &sdata->vif);
-}
-
-void ieee80211_iterate_interfaces(
-	struct ieee80211_hw *hw, u32 iter_flags,
-	void (*iterator)(void *data, u8 *mac,
-			 struct ieee80211_vif *vif),
-	void *data)
-{
-	struct ieee80211_local *local = hw_to_local(hw);
-
-	mutex_lock(&local->iflist_mtx);
-	__iterate_interfaces(local, iter_flags, iterator, data);
-	mutex_unlock(&local->iflist_mtx);
-}
-EXPORT_SYMBOL_GPL(ieee80211_iterate_interfaces);
-
-void ieee80211_iterate_active_interfaces_atomic(
-	struct ieee80211_hw *hw, u32 iter_flags,
-	void (*iterator)(void *data, u8 *mac,
-			 struct ieee80211_vif *vif),
-	void *data)
-{
-	struct ieee80211_local *local = hw_to_local(hw);
-
-	rcu_read_lock();
-	__iterate_interfaces(local, iter_flags | IEEE80211_IFACE_ITER_ACTIVE,
-			     iterator, data);
-	rcu_read_unlock();
-}
-EXPORT_SYMBOL_GPL(ieee80211_iterate_active_interfaces_atomic);
-
-void ieee80211_iterate_active_interfaces_mtx(
-	struct ieee80211_hw *hw, u32 iter_flags,
-	void (*iterator)(void *data, u8 *mac,
-			 struct ieee80211_vif *vif),
-	void *data)
-{
-	struct ieee80211_local *local = hw_to_local(hw);
-
-	lockdep_assert_wiphy(hw->wiphy);
-
-	__iterate_interfaces(local, iter_flags | IEEE80211_IFACE_ITER_ACTIVE,
-			     iterator, data);
-}
-EXPORT_SYMBOL_GPL(ieee80211_iterate_active_interfaces_mtx);
-
-static void __iterate_stations(struct ieee80211_local *local,
-			       void (*iterator)(void *data,
-						struct ieee80211_sta *sta),
-			       void *data)
-{
-	struct sta_info *sta;
-
-	list_for_each_entry_rcu(sta, &local->sta_list, list,
-				lockdep_is_held(&local->hw.wiphy->mtx)) {
-		if (!sta->uploaded)
-			continue;
-
-		iterator(data, &sta->sta);
-	}
-}
-
-void ieee80211_iterate_stations_atomic(struct ieee80211_hw *hw,
-			void (*iterator)(void *data,
-					 struct ieee80211_sta *sta),
-			void *data)
-{
-	struct ieee80211_local *local = hw_to_local(hw);
-
-	rcu_read_lock();
-	__iterate_stations(local, iterator, data);
-	rcu_read_unlock();
-}
-EXPORT_SYMBOL_GPL(ieee80211_iterate_stations_atomic);
-
-void ieee80211_iterate_stations_mtx(struct ieee80211_hw *hw,
-				    void (*iterator)(void *data,
-						     struct ieee80211_sta *sta),
-				    void *data)
-{
-	struct ieee80211_local *local = hw_to_local(hw);
-
-	lockdep_assert_wiphy(local->hw.wiphy);
-
-	__iterate_stations(local, iterator, data);
-}
-EXPORT_SYMBOL_GPL(ieee80211_iterate_stations_mtx);
-
-struct ieee80211_vif *wdev_to_ieee80211_vif(struct wireless_dev *wdev)
-{
-	struct ieee80211_sub_if_data *sdata = IEEE80211_WDEV_TO_SUB_IF(wdev);
-
-	if (!ieee80211_sdata_running(sdata) ||
-	    !(sdata->flags & IEEE80211_SDATA_IN_DRIVER))
-		return NULL;
-	return &sdata->vif;
-}
-EXPORT_SYMBOL_GPL(wdev_to_ieee80211_vif);
-
-struct wireless_dev *ieee80211_vif_to_wdev(struct ieee80211_vif *vif)
-{
-	if (!vif)
-		return NULL;
-
-	return &vif_to_sdata(vif)->wdev;
-}
-EXPORT_SYMBOL_GPL(ieee80211_vif_to_wdev);
-
-/*
- * Nothing should have been stuffed into the workqueue during
- * the suspend->resume cycle. Since we can't check each caller
- * of this function if we are already quiescing / suspended,
- * check here and don't WARN since this can actually happen when
- * the rx path (for example) is racing against __ieee80211_suspend
- * and suspending / quiescing was set after the rx path checked
- * them.
- */
-static bool ieee80211_can_queue_work(struct ieee80211_local *local)
-{
-	if (local->quiescing || (local->suspended && !local->resuming)) {
-		pr_warn("queueing ieee80211 work while going to suspend\n");
-		return false;
-	}
-
-	return true;
-}
-
-void ieee80211_queue_work(struct ieee80211_hw *hw, struct work_struct *work)
-{
-	struct ieee80211_local *local = hw_to_local(hw);
-
-	if (!ieee80211_can_queue_work(local))
-		return;
-
-	queue_work(local->workqueue, work);
-}
-EXPORT_SYMBOL(ieee80211_queue_work);
-
-void ieee80211_queue_delayed_work(struct ieee80211_hw *hw,
-				  struct delayed_work *dwork,
-				  unsigned long delay)
-{
-	struct ieee80211_local *local = hw_to_local(hw);
-
-	if (!ieee80211_can_queue_work(local))
-		return;
-
-	queue_delayed_work(local->workqueue, dwork, delay);
-}
-EXPORT_SYMBOL(ieee80211_queue_delayed_work);
-
-static void
-ieee80211_parse_extension_element(u32 *crc,
-				  const struct element *elem,
-				  struct ieee802_11_elems *elems,
-				  struct ieee80211_elems_parse_params *params)
-{
-	const void *data = elem->data + 1;
-	bool calc_crc = false;
-	u8 len;
-
-	if (!elem->datalen)
-		return;
-
-	len = elem->datalen - 1;
-
-	switch (elem->data[0]) {
-	case WLAN_EID_EXT_HE_MU_EDCA:
-		calc_crc = true;
-		if (len >= sizeof(*elems->mu_edca_param_set))
-			elems->mu_edca_param_set = data;
-		break;
-	case WLAN_EID_EXT_HE_CAPABILITY:
-		if (ieee80211_he_capa_size_ok(data, len)) {
-			elems->he_cap = data;
-			elems->he_cap_len = len;
-		}
-		break;
-	case WLAN_EID_EXT_HE_OPERATION:
-		calc_crc = true;
-		if (len >= sizeof(*elems->he_operation) &&
-		    len >= ieee80211_he_oper_size(data) - 1)
-			elems->he_operation = data;
-		break;
-	case WLAN_EID_EXT_UORA:
-		if (len >= 1)
-			elems->uora_element = data;
-		break;
-	case WLAN_EID_EXT_MAX_CHANNEL_SWITCH_TIME:
-		if (len == 3)
-			elems->max_channel_switch_time = data;
-		break;
-	case WLAN_EID_EXT_MULTIPLE_BSSID_CONFIGURATION:
-		if (len >= sizeof(*elems->mbssid_config_ie))
-			elems->mbssid_config_ie = data;
-		break;
-	case WLAN_EID_EXT_HE_SPR:
-		if (len >= sizeof(*elems->he_spr) &&
-		    len >= ieee80211_he_spr_size(data))
-			elems->he_spr = data;
-		break;
-	case WLAN_EID_EXT_HE_6GHZ_CAPA:
-		if (len >= sizeof(*elems->he_6ghz_capa))
-			elems->he_6ghz_capa = data;
-		break;
-	case WLAN_EID_EXT_EHT_CAPABILITY:
-		if (ieee80211_eht_capa_size_ok(elems->he_cap,
-					       data, len,
-					       params->from_ap)) {
-			elems->eht_cap = data;
-			elems->eht_cap_len = len;
-		}
-		break;
-	case WLAN_EID_EXT_EHT_OPERATION:
-		if (ieee80211_eht_oper_size_ok(data, len))
-			elems->eht_operation = data;
-		calc_crc = true;
-		break;
-	case WLAN_EID_EXT_EHT_MULTI_LINK:
-		calc_crc = true;
-
-		if (ieee80211_mle_size_ok(data, len)) {
-			const struct ieee80211_multi_link_elem *mle =
-				(void *)data;
-
-			switch (le16_get_bits(mle->control,
-					      IEEE80211_ML_CONTROL_TYPE)) {
-			case IEEE80211_ML_CONTROL_TYPE_BASIC:
-				elems->ml_basic_elem = (void *)elem;
-				elems->ml_basic = data;
-				elems->ml_basic_len = len;
-				break;
-			case IEEE80211_ML_CONTROL_TYPE_RECONF:
-				elems->ml_reconf_elem = (void *)elem;
-				elems->ml_reconf = data;
-				elems->ml_reconf_len = len;
-				break;
-			default:
-				break;
-			}
-		}
-		break;
-	}
-
-	if (crc && calc_crc)
-		*crc = crc32_be(*crc, (void *)elem, elem->datalen + 2);
-}
-
-static u32
-_ieee802_11_parse_elems_full(struct ieee80211_elems_parse_params *params,
-			     struct ieee802_11_elems *elems,
-			     const struct element *check_inherit)
-{
-	const struct element *elem;
-	bool calc_crc = params->filter != 0;
-	DECLARE_BITMAP(seen_elems, 256);
-	u32 crc = params->crc;
-	const u8 *ie;
-
-	bitmap_zero(seen_elems, 256);
-
-	for_each_element(elem, params->start, params->len) {
-		bool elem_parse_failed;
-		u8 id = elem->id;
-		u8 elen = elem->datalen;
-		const u8 *pos = elem->data;
-
-		if (check_inherit &&
-		    !cfg80211_is_element_inherited(elem,
-						   check_inherit))
-			continue;
-
-		switch (id) {
-		case WLAN_EID_SSID:
-		case WLAN_EID_SUPP_RATES:
-		case WLAN_EID_FH_PARAMS:
-		case WLAN_EID_DS_PARAMS:
-		case WLAN_EID_CF_PARAMS:
-		case WLAN_EID_TIM:
-		case WLAN_EID_IBSS_PARAMS:
-		case WLAN_EID_CHALLENGE:
-		case WLAN_EID_RSN:
-		case WLAN_EID_ERP_INFO:
-		case WLAN_EID_EXT_SUPP_RATES:
-		case WLAN_EID_HT_CAPABILITY:
-		case WLAN_EID_HT_OPERATION:
-		case WLAN_EID_VHT_CAPABILITY:
-		case WLAN_EID_VHT_OPERATION:
-		case WLAN_EID_MESH_ID:
-		case WLAN_EID_MESH_CONFIG:
-		case WLAN_EID_PEER_MGMT:
-		case WLAN_EID_PREQ:
-		case WLAN_EID_PREP:
-		case WLAN_EID_PERR:
-		case WLAN_EID_RANN:
-		case WLAN_EID_CHANNEL_SWITCH:
-		case WLAN_EID_EXT_CHANSWITCH_ANN:
-		case WLAN_EID_COUNTRY:
-		case WLAN_EID_PWR_CONSTRAINT:
-		case WLAN_EID_TIMEOUT_INTERVAL:
-		case WLAN_EID_SECONDARY_CHANNEL_OFFSET:
-		case WLAN_EID_WIDE_BW_CHANNEL_SWITCH:
-		case WLAN_EID_CHAN_SWITCH_PARAM:
-		case WLAN_EID_EXT_CAPABILITY:
-		case WLAN_EID_CHAN_SWITCH_TIMING:
-		case WLAN_EID_LINK_ID:
-		case WLAN_EID_BSS_MAX_IDLE_PERIOD:
-		case WLAN_EID_RSNX:
-		case WLAN_EID_S1G_BCN_COMPAT:
-		case WLAN_EID_S1G_CAPABILITIES:
-		case WLAN_EID_S1G_OPERATION:
-		case WLAN_EID_AID_RESPONSE:
-		case WLAN_EID_S1G_SHORT_BCN_INTERVAL:
-		/*
-		 * not listing WLAN_EID_CHANNEL_SWITCH_WRAPPER -- it seems possible
-		 * that if the content gets bigger it might be needed more than once
-		 */
-			if (test_bit(id, seen_elems)) {
-				elems->parse_error = true;
-				continue;
-			}
-			break;
-		}
-
-		if (calc_crc && id < 64 && (params->filter & (1ULL << id)))
-			crc = crc32_be(crc, pos - 2, elen + 2);
-
-		elem_parse_failed = false;
-
-		switch (id) {
-		case WLAN_EID_LINK_ID:
-			if (elen + 2 < sizeof(struct ieee80211_tdls_lnkie)) {
-				elem_parse_failed = true;
-				break;
-			}
-			elems->lnk_id = (void *)(pos - 2);
-			break;
-		case WLAN_EID_CHAN_SWITCH_TIMING:
-			if (elen < sizeof(struct ieee80211_ch_switch_timing)) {
-				elem_parse_failed = true;
-				break;
-			}
-			elems->ch_sw_timing = (void *)pos;
-			break;
-		case WLAN_EID_EXT_CAPABILITY:
-			elems->ext_capab = pos;
-			elems->ext_capab_len = elen;
-			break;
-		case WLAN_EID_SSID:
-			elems->ssid = pos;
-			elems->ssid_len = elen;
-			break;
-		case WLAN_EID_SUPP_RATES:
-			elems->supp_rates = pos;
-			elems->supp_rates_len = elen;
-			break;
-		case WLAN_EID_DS_PARAMS:
-			if (elen >= 1)
-				elems->ds_params = pos;
-			else
-				elem_parse_failed = true;
-			break;
-		case WLAN_EID_TIM:
-			if (elen >= sizeof(struct ieee80211_tim_ie)) {
-				elems->tim = (void *)pos;
-				elems->tim_len = elen;
-			} else
-				elem_parse_failed = true;
-			break;
-		case WLAN_EID_VENDOR_SPECIFIC:
-			if (elen >= 4 && pos[0] == 0x00 && pos[1] == 0x50 &&
-			    pos[2] == 0xf2) {
-				/* Microsoft OUI (00:50:F2) */
-
-				if (calc_crc)
-					crc = crc32_be(crc, pos - 2, elen + 2);
-
-				if (elen >= 5 && pos[3] == 2) {
-					/* OUI Type 2 - WMM IE */
-					if (pos[4] == 0) {
-						elems->wmm_info = pos;
-						elems->wmm_info_len = elen;
-					} else if (pos[4] == 1) {
-						elems->wmm_param = pos;
-						elems->wmm_param_len = elen;
-					}
-				}
-			}
-			break;
-		case WLAN_EID_RSN:
-			elems->rsn = pos;
-			elems->rsn_len = elen;
-			break;
-		case WLAN_EID_ERP_INFO:
-			if (elen >= 1)
-				elems->erp_info = pos;
-			else
-				elem_parse_failed = true;
-			break;
-		case WLAN_EID_EXT_SUPP_RATES:
-			elems->ext_supp_rates = pos;
-			elems->ext_supp_rates_len = elen;
-			break;
-		case WLAN_EID_HT_CAPABILITY:
-			if (elen >= sizeof(struct ieee80211_ht_cap))
-				elems->ht_cap_elem = (void *)pos;
-			else
-				elem_parse_failed = true;
-			break;
-		case WLAN_EID_HT_OPERATION:
-			if (elen >= sizeof(struct ieee80211_ht_operation))
-				elems->ht_operation = (void *)pos;
-			else
-				elem_parse_failed = true;
-			break;
-		case WLAN_EID_VHT_CAPABILITY:
-			if (elen >= sizeof(struct ieee80211_vht_cap))
-				elems->vht_cap_elem = (void *)pos;
-			else
-				elem_parse_failed = true;
-			break;
-		case WLAN_EID_VHT_OPERATION:
-			if (elen >= sizeof(struct ieee80211_vht_operation)) {
-				elems->vht_operation = (void *)pos;
-				if (calc_crc)
-					crc = crc32_be(crc, pos - 2, elen + 2);
-				break;
-			}
-			elem_parse_failed = true;
-			break;
-		case WLAN_EID_OPMODE_NOTIF:
-			if (elen > 0) {
-				elems->opmode_notif = pos;
-				if (calc_crc)
-					crc = crc32_be(crc, pos - 2, elen + 2);
-				break;
-			}
-			elem_parse_failed = true;
-			break;
-		case WLAN_EID_MESH_ID:
-			elems->mesh_id = pos;
-			elems->mesh_id_len = elen;
-			break;
-		case WLAN_EID_MESH_CONFIG:
-			if (elen >= sizeof(struct ieee80211_meshconf_ie))
-				elems->mesh_config = (void *)pos;
-			else
-				elem_parse_failed = true;
-			break;
-		case WLAN_EID_PEER_MGMT:
-			elems->peering = pos;
-			elems->peering_len = elen;
-			break;
-		case WLAN_EID_MESH_AWAKE_WINDOW:
-			if (elen >= 2)
-				elems->awake_window = (void *)pos;
-			break;
-		case WLAN_EID_PREQ:
-			elems->preq = pos;
-			elems->preq_len = elen;
-			break;
-		case WLAN_EID_PREP:
-			elems->prep = pos;
-			elems->prep_len = elen;
-			break;
-		case WLAN_EID_PERR:
-			elems->perr = pos;
-			elems->perr_len = elen;
-			break;
-		case WLAN_EID_RANN:
-			if (elen >= sizeof(struct ieee80211_rann_ie))
-				elems->rann = (void *)pos;
-			else
-				elem_parse_failed = true;
-			break;
-		case WLAN_EID_CHANNEL_SWITCH:
-			if (elen != sizeof(struct ieee80211_channel_sw_ie)) {
-				elem_parse_failed = true;
-				break;
-			}
-			elems->ch_switch_ie = (void *)pos;
-			break;
-		case WLAN_EID_EXT_CHANSWITCH_ANN:
-			if (elen != sizeof(struct ieee80211_ext_chansw_ie)) {
-				elem_parse_failed = true;
-				break;
-			}
-			elems->ext_chansw_ie = (void *)pos;
-			break;
-		case WLAN_EID_SECONDARY_CHANNEL_OFFSET:
-			if (elen != sizeof(struct ieee80211_sec_chan_offs_ie)) {
-				elem_parse_failed = true;
-				break;
-			}
-			elems->sec_chan_offs = (void *)pos;
-			break;
-		case WLAN_EID_CHAN_SWITCH_PARAM:
-			if (elen <
-			    sizeof(*elems->mesh_chansw_params_ie)) {
-				elem_parse_failed = true;
-				break;
-			}
-			elems->mesh_chansw_params_ie = (void *)pos;
-			break;
-		case WLAN_EID_WIDE_BW_CHANNEL_SWITCH:
-			if (!params->action ||
-			    elen < sizeof(*elems->wide_bw_chansw_ie)) {
-				elem_parse_failed = true;
-				break;
-			}
-			elems->wide_bw_chansw_ie = (void *)pos;
-			break;
-		case WLAN_EID_CHANNEL_SWITCH_WRAPPER:
-			if (params->action) {
-				elem_parse_failed = true;
-				break;
-			}
-			/*
-			 * This is a bit tricky, but as we only care about
-			 * the wide bandwidth channel switch element, so
-			 * just parse it out manually.
-			 */
-			ie = cfg80211_find_ie(WLAN_EID_WIDE_BW_CHANNEL_SWITCH,
-					      pos, elen);
-			if (ie) {
-				if (ie[1] >= sizeof(*elems->wide_bw_chansw_ie))
-					elems->wide_bw_chansw_ie =
-						(void *)(ie + 2);
-				else
-					elem_parse_failed = true;
-			}
-			break;
-		case WLAN_EID_COUNTRY:
-			elems->country_elem = pos;
-			elems->country_elem_len = elen;
-			break;
-		case WLAN_EID_PWR_CONSTRAINT:
-			if (elen != 1) {
-				elem_parse_failed = true;
-				break;
-			}
-			elems->pwr_constr_elem = pos;
-			break;
-		case WLAN_EID_CISCO_VENDOR_SPECIFIC:
-			/* Lots of different options exist, but we only care
-			 * about the Dynamic Transmit Power Control element.
-			 * First check for the Cisco OUI, then for the DTPC
-			 * tag (0x00).
-			 */
-			if (elen < 4) {
-				elem_parse_failed = true;
-				break;
-			}
-
-			if (pos[0] != 0x00 || pos[1] != 0x40 ||
-			    pos[2] != 0x96 || pos[3] != 0x00)
-				break;
-
-			if (elen != 6) {
-				elem_parse_failed = true;
-				break;
-			}
-
-			if (calc_crc)
-				crc = crc32_be(crc, pos - 2, elen + 2);
-
-			elems->cisco_dtpc_elem = pos;
-			break;
-		case WLAN_EID_ADDBA_EXT:
-			if (elen < sizeof(struct ieee80211_addba_ext_ie)) {
-				elem_parse_failed = true;
-				break;
-			}
-			elems->addba_ext_ie = (void *)pos;
-			break;
-		case WLAN_EID_TIMEOUT_INTERVAL:
-			if (elen >= sizeof(struct ieee80211_timeout_interval_ie))
-				elems->timeout_int = (void *)pos;
-			else
-				elem_parse_failed = true;
-			break;
-		case WLAN_EID_BSS_MAX_IDLE_PERIOD:
-			if (elen >= sizeof(*elems->max_idle_period_ie))
-				elems->max_idle_period_ie = (void *)pos;
-			break;
-		case WLAN_EID_RSNX:
-			elems->rsnx = pos;
-			elems->rsnx_len = elen;
-			break;
-		case WLAN_EID_TX_POWER_ENVELOPE:
-			if (elen < 1 ||
-			    elen > sizeof(struct ieee80211_tx_pwr_env))
-				break;
-
-			if (elems->tx_pwr_env_num >= ARRAY_SIZE(elems->tx_pwr_env))
-				break;
-
-			elems->tx_pwr_env[elems->tx_pwr_env_num] = (void *)pos;
-			elems->tx_pwr_env_len[elems->tx_pwr_env_num] = elen;
-			elems->tx_pwr_env_num++;
-			break;
-		case WLAN_EID_EXTENSION:
-			ieee80211_parse_extension_element(calc_crc ?
-								&crc : NULL,
-							  elem, elems, params);
-			break;
-		case WLAN_EID_S1G_CAPABILITIES:
-			if (elen >= sizeof(*elems->s1g_capab))
-				elems->s1g_capab = (void *)pos;
-			else
-				elem_parse_failed = true;
-			break;
-		case WLAN_EID_S1G_OPERATION:
-			if (elen == sizeof(*elems->s1g_oper))
-				elems->s1g_oper = (void *)pos;
-			else
-				elem_parse_failed = true;
-			break;
-		case WLAN_EID_S1G_BCN_COMPAT:
-			if (elen == sizeof(*elems->s1g_bcn_compat))
-				elems->s1g_bcn_compat = (void *)pos;
-			else
-				elem_parse_failed = true;
-			break;
-		case WLAN_EID_AID_RESPONSE:
-			if (elen == sizeof(struct ieee80211_aid_response_ie))
-				elems->aid_resp = (void *)pos;
-			else
-				elem_parse_failed = true;
-			break;
-		default:
-			break;
-		}
-
-		if (elem_parse_failed)
-			elems->parse_error = true;
-		else
-			__set_bit(id, seen_elems);
-	}
-
-	if (!for_each_element_completed(elem, params->start, params->len))
-		elems->parse_error = true;
-
-	return crc;
-}
-
-static size_t ieee802_11_find_bssid_profile(const u8 *start, size_t len,
-					    struct ieee802_11_elems *elems,
-					    struct cfg80211_bss *bss,
-					    u8 *nontransmitted_profile)
-{
-	const struct element *elem, *sub;
-	size_t profile_len = 0;
-	bool found = false;
-
-	if (!bss || !bss->transmitted_bss)
-		return profile_len;
-
-	for_each_element_id(elem, WLAN_EID_MULTIPLE_BSSID, start, len) {
-		if (elem->datalen < 2)
-			continue;
-		if (elem->data[0] < 1 || elem->data[0] > 8)
-			continue;
-
-		for_each_element(sub, elem->data + 1, elem->datalen - 1) {
-			u8 new_bssid[ETH_ALEN];
-			const u8 *index;
-
-			if (sub->id != 0 || sub->datalen < 4) {
-				/* not a valid BSS profile */
-				continue;
-			}
-
-			if (sub->data[0] != WLAN_EID_NON_TX_BSSID_CAP ||
-			    sub->data[1] != 2) {
-				/* The first element of the
-				 * Nontransmitted BSSID Profile is not
-				 * the Nontransmitted BSSID Capability
-				 * element.
-				 */
-				continue;
-			}
-
-			memset(nontransmitted_profile, 0, len);
-			profile_len = cfg80211_merge_profile(start, len,
-							     elem,
-							     sub,
-							     nontransmitted_profile,
-							     len);
-
-			/* found a Nontransmitted BSSID Profile */
-			index = cfg80211_find_ie(WLAN_EID_MULTI_BSSID_IDX,
-						 nontransmitted_profile,
-						 profile_len);
-			if (!index || index[1] < 1 || index[2] == 0) {
-				/* Invalid MBSSID Index element */
-				continue;
-			}
-
-			cfg80211_gen_new_bssid(bss->transmitted_bss->bssid,
-					       elem->data[0],
-					       index[2],
-					       new_bssid);
-			if (ether_addr_equal(new_bssid, bss->bssid)) {
-				found = true;
-				elems->bssid_index_len = index[1];
-				elems->bssid_index = (void *)&index[2];
-				break;
-			}
-		}
-	}
-
-	return found ? profile_len : 0;
-}
-
-static void ieee80211_mle_get_sta_prof(struct ieee802_11_elems *elems,
-				       u8 link_id)
-{
-	const struct ieee80211_multi_link_elem *ml = elems->ml_basic;
-	ssize_t ml_len = elems->ml_basic_len;
-	const struct element *sub;
-
-	if (!ml || !ml_len)
-		return;
-
-	if (le16_get_bits(ml->control, IEEE80211_ML_CONTROL_TYPE) !=
-	    IEEE80211_ML_CONTROL_TYPE_BASIC)
-		return;
-
-	for_each_mle_subelement(sub, (u8 *)ml, ml_len) {
-		struct ieee80211_mle_per_sta_profile *prof = (void *)sub->data;
-		ssize_t sta_prof_len;
-		u16 control;
-
-		if (sub->id != IEEE80211_MLE_SUBELEM_PER_STA_PROFILE)
-			continue;
-
-		if (!ieee80211_mle_basic_sta_prof_size_ok(sub->data,
-							  sub->datalen))
-			return;
-
-		control = le16_to_cpu(prof->control);
-
-		if (link_id != u16_get_bits(control,
-					    IEEE80211_MLE_STA_CONTROL_LINK_ID))
-			continue;
-
-		if (!(control & IEEE80211_MLE_STA_CONTROL_COMPLETE_PROFILE))
-			return;
-
-		/* the sub element can be fragmented */
-		sta_prof_len =
-			cfg80211_defragment_element(sub,
-						    (u8 *)ml, ml_len,
-						    elems->scratch_pos,
-						    elems->scratch +
-							elems->scratch_len -
-							elems->scratch_pos,
-						    IEEE80211_MLE_SUBELEM_FRAGMENT);
-
-		if (sta_prof_len < 0)
-			return;
-
-		elems->prof = (void *)elems->scratch_pos;
-		elems->sta_prof_len = sta_prof_len;
-		elems->scratch_pos += sta_prof_len;
-
-		return;
-	}
-}
-
-static void ieee80211_mle_parse_link(struct ieee802_11_elems *elems,
-				     struct ieee80211_elems_parse_params *params)
-{
-	struct ieee80211_mle_per_sta_profile *prof;
-	struct ieee80211_elems_parse_params sub = {
-		.action = params->action,
-		.from_ap = params->from_ap,
-		.link_id = -1,
-	};
-	ssize_t ml_len = elems->ml_basic_len;
-	const struct element *non_inherit = NULL;
-	const u8 *end;
-
-	if (params->link_id == -1)
-		return;
-
-	ml_len = cfg80211_defragment_element(elems->ml_basic_elem,
-					     elems->ie_start,
-					     elems->total_len,
-					     elems->scratch_pos,
-					     elems->scratch +
-						elems->scratch_len -
-						elems->scratch_pos,
-					     WLAN_EID_FRAGMENT);
-
-	if (ml_len < 0)
-		return;
-
-	elems->ml_basic = (const void *)elems->scratch_pos;
-	elems->ml_basic_len = ml_len;
-
-	ieee80211_mle_get_sta_prof(elems, params->link_id);
-	prof = elems->prof;
-
-	if (!prof)
-		return;
-
-	/* check if we have the 4 bytes for the fixed part in assoc response */
-	if (elems->sta_prof_len < sizeof(*prof) + prof->sta_info_len - 1 + 4) {
-		elems->prof = NULL;
-		elems->sta_prof_len = 0;
-		return;
-	}
-
-	/*
-	 * Skip the capability information and the status code that are expected
-	 * as part of the station profile in association response frames. Note
-	 * the -1 is because the 'sta_info_len' is accounted to as part of the
-	 * per-STA profile, but not part of the 'u8 variable[]' portion.
-	 */
-	sub.start = prof->variable + prof->sta_info_len - 1 + 4;
-	end = (const u8 *)prof + elems->sta_prof_len;
-	sub.len = end - sub.start;
-
-	non_inherit = cfg80211_find_ext_elem(WLAN_EID_EXT_NON_INHERITANCE,
-					     sub.start, sub.len);
-	_ieee802_11_parse_elems_full(&sub, elems, non_inherit);
-}
-
-struct ieee802_11_elems *
-ieee802_11_parse_elems_full(struct ieee80211_elems_parse_params *params)
-{
-	struct ieee802_11_elems *elems;
-	const struct element *non_inherit = NULL;
-	u8 *nontransmitted_profile;
-	int nontransmitted_profile_len = 0;
-	size_t scratch_len = 3 * params->len;
-
-	elems = kzalloc(sizeof(*elems) + scratch_len, GFP_ATOMIC);
-	if (!elems)
-		return NULL;
-	elems->ie_start = params->start;
-	elems->total_len = params->len;
-	elems->scratch_len = scratch_len;
-	elems->scratch_pos = elems->scratch;
-
-	nontransmitted_profile = elems->scratch_pos;
-	nontransmitted_profile_len =
-		ieee802_11_find_bssid_profile(params->start, params->len,
-					      elems, params->bss,
-					      nontransmitted_profile);
-	elems->scratch_pos += nontransmitted_profile_len;
-	elems->scratch_len -= nontransmitted_profile_len;
-	non_inherit = cfg80211_find_ext_elem(WLAN_EID_EXT_NON_INHERITANCE,
-					     nontransmitted_profile,
-					     nontransmitted_profile_len);
-
-	elems->crc = _ieee802_11_parse_elems_full(params, elems, non_inherit);
-
-	/* Override with nontransmitted profile, if found */
-	if (nontransmitted_profile_len) {
-		struct ieee80211_elems_parse_params sub = {
-			.start = nontransmitted_profile,
-			.len = nontransmitted_profile_len,
-			.action = params->action,
-			.link_id = params->link_id,
-		};
-
-		_ieee802_11_parse_elems_full(&sub, elems, NULL);
-	}
-
-	ieee80211_mle_parse_link(elems, params);
-
-	if (elems->tim && !elems->parse_error) {
-		const struct ieee80211_tim_ie *tim_ie = elems->tim;
-
-		elems->dtim_period = tim_ie->dtim_period;
-		elems->dtim_count = tim_ie->dtim_count;
-	}
-
-	/* Override DTIM period and count if needed */
-	if (elems->bssid_index &&
-	    elems->bssid_index_len >=
-	    offsetofend(struct ieee80211_bssid_index, dtim_period))
-		elems->dtim_period = elems->bssid_index->dtim_period;
-
-	if (elems->bssid_index &&
-	    elems->bssid_index_len >=
-	    offsetofend(struct ieee80211_bssid_index, dtim_count))
-		elems->dtim_count = elems->bssid_index->dtim_count;
-
-	return elems;
-}
-
-void ieee80211_regulatory_limit_wmm_params(struct ieee80211_sub_if_data *sdata,
-					   struct ieee80211_tx_queue_params
-					   *qparam, int ac)
-{
-	struct ieee80211_chanctx_conf *chanctx_conf;
-	const struct ieee80211_reg_rule *rrule;
-	const struct ieee80211_wmm_ac *wmm_ac;
-	u16 center_freq = 0;
-
-	if (sdata->vif.type != NL80211_IFTYPE_AP &&
-	    sdata->vif.type != NL80211_IFTYPE_STATION)
-		return;
-
-	rcu_read_lock();
-	chanctx_conf = rcu_dereference(sdata->vif.bss_conf.chanctx_conf);
-	if (chanctx_conf)
-		center_freq = chanctx_conf->def.chan->center_freq;
-
-	if (!center_freq) {
-		rcu_read_unlock();
-		return;
-	}
-
-	rrule = freq_reg_info(sdata->wdev.wiphy, MHZ_TO_KHZ(center_freq));
-
-	if (IS_ERR_OR_NULL(rrule) || !rrule->has_wmm) {
-		rcu_read_unlock();
-		return;
-	}
-
-	if (sdata->vif.type == NL80211_IFTYPE_AP)
-		wmm_ac = &rrule->wmm_rule.ap[ac];
-	else
-		wmm_ac = &rrule->wmm_rule.client[ac];
-	qparam->cw_min = max_t(u16, qparam->cw_min, wmm_ac->cw_min);
-	qparam->cw_max = max_t(u16, qparam->cw_max, wmm_ac->cw_max);
-	qparam->aifs = max_t(u8, qparam->aifs, wmm_ac->aifsn);
-	qparam->txop = min_t(u16, qparam->txop, wmm_ac->cot / 32);
-	rcu_read_unlock();
-}
-
-void ieee80211_set_wmm_default(struct ieee80211_link_data *link,
-			       bool bss_notify, bool enable_qos)
-{
-	struct ieee80211_sub_if_data *sdata = link->sdata;
-	struct ieee80211_local *local = sdata->local;
-	struct ieee80211_tx_queue_params qparam;
-	struct ieee80211_chanctx_conf *chanctx_conf;
-	int ac;
-	bool use_11b;
-	bool is_ocb; /* Use another EDCA parameters if dot11OCBActivated=true */
-	int aCWmin, aCWmax;
-
-	if (!local->ops->conf_tx)
-		return;
-
-	if (local->hw.queues < IEEE80211_NUM_ACS)
-		return;
-
-	memset(&qparam, 0, sizeof(qparam));
-
-	rcu_read_lock();
-	chanctx_conf = rcu_dereference(link->conf->chanctx_conf);
-	use_11b = (chanctx_conf &&
-		   chanctx_conf->def.chan->band == NL80211_BAND_2GHZ) &&
-		 !link->operating_11g_mode;
-	rcu_read_unlock();
-
-	is_ocb = (sdata->vif.type == NL80211_IFTYPE_OCB);
-
-	/* Set defaults according to 802.11-2007 Table 7-37 */
-	aCWmax = 1023;
-	if (use_11b)
-		aCWmin = 31;
-	else
-		aCWmin = 15;
-
-	/* Confiure old 802.11b/g medium access rules. */
-	qparam.cw_max = aCWmax;
-	qparam.cw_min = aCWmin;
-	qparam.txop = 0;
-	qparam.aifs = 2;
-
-	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
-		/* Update if QoS is enabled. */
-		if (enable_qos) {
-			switch (ac) {
-			case IEEE80211_AC_BK:
-				qparam.cw_max = aCWmax;
-				qparam.cw_min = aCWmin;
-				qparam.txop = 0;
-				if (is_ocb)
-					qparam.aifs = 9;
-				else
-					qparam.aifs = 7;
-				break;
-			/* never happens but let's not leave undefined */
-			default:
-			case IEEE80211_AC_BE:
-				qparam.cw_max = aCWmax;
-				qparam.cw_min = aCWmin;
-				qparam.txop = 0;
-				if (is_ocb)
-					qparam.aifs = 6;
-				else
-					qparam.aifs = 3;
-				break;
-			case IEEE80211_AC_VI:
-				qparam.cw_max = aCWmin;
-				qparam.cw_min = (aCWmin + 1) / 2 - 1;
-				if (is_ocb)
-					qparam.txop = 0;
-				else if (use_11b)
-					qparam.txop = 6016/32;
-				else
-					qparam.txop = 3008/32;
-
-				if (is_ocb)
-					qparam.aifs = 3;
-				else
-					qparam.aifs = 2;
-				break;
-			case IEEE80211_AC_VO:
-				qparam.cw_max = (aCWmin + 1) / 2 - 1;
-				qparam.cw_min = (aCWmin + 1) / 4 - 1;
-				if (is_ocb)
-					qparam.txop = 0;
-				else if (use_11b)
-					qparam.txop = 3264/32;
-				else
-					qparam.txop = 1504/32;
-				qparam.aifs = 2;
-				break;
-			}
-		}
-		ieee80211_regulatory_limit_wmm_params(sdata, &qparam, ac);
-
-		qparam.uapsd = false;
-
-		link->tx_conf[ac] = qparam;
-		drv_conf_tx(local, link, ac, &qparam);
-	}
-
-	if (sdata->vif.type != NL80211_IFTYPE_MONITOR &&
-	    sdata->vif.type != NL80211_IFTYPE_P2P_DEVICE &&
-	    sdata->vif.type != NL80211_IFTYPE_NAN) {
-		link->conf->qos = enable_qos;
-		if (bss_notify)
-			ieee80211_link_info_change_notify(sdata, link,
-							  BSS_CHANGED_QOS);
-	}
-}
-
-void ieee80211_send_auth(struct ieee80211_sub_if_data *sdata,
-			 u16 transaction, u16 auth_alg, u16 status,
-			 const u8 *extra, size_t extra_len, const u8 *da,
-			 const u8 *bssid, const u8 *key, u8 key_len, u8 key_idx,
-			 u32 tx_flags)
-{
-	struct ieee80211_local *local = sdata->local;
-	struct sk_buff *skb;
-	struct ieee80211_mgmt *mgmt;
-	bool multi_link = ieee80211_vif_is_mld(&sdata->vif);
-	struct {
-		u8 id;
-		u8 len;
-		u8 ext_id;
-		struct ieee80211_multi_link_elem ml;
-		struct ieee80211_mle_basic_common_info basic;
-	} __packed mle = {
-		.id = WLAN_EID_EXTENSION,
-		.len = sizeof(mle) - 2,
-		.ext_id = WLAN_EID_EXT_EHT_MULTI_LINK,
-		.ml.control = cpu_to_le16(IEEE80211_ML_CONTROL_TYPE_BASIC),
-		.basic.len = sizeof(mle.basic),
-	};
-	int err;
-
-	memcpy(mle.basic.mld_mac_addr, sdata->vif.addr, ETH_ALEN);
-
-	/* 24 + 6 = header + auth_algo + auth_transaction + status_code */
-	skb = dev_alloc_skb(local->hw.extra_tx_headroom + IEEE80211_WEP_IV_LEN +
-			    24 + 6 + extra_len + IEEE80211_WEP_ICV_LEN +
-			    multi_link * sizeof(mle));
-	if (!skb)
-		return;
-
-	skb_reserve(skb, local->hw.extra_tx_headroom + IEEE80211_WEP_IV_LEN);
-
-	mgmt = skb_put_zero(skb, 24 + 6);
-	mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
-					  IEEE80211_STYPE_AUTH);
-	memcpy(mgmt->da, da, ETH_ALEN);
-	memcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);
-	memcpy(mgmt->bssid, bssid, ETH_ALEN);
-	mgmt->u.auth.auth_alg = cpu_to_le16(auth_alg);
-	mgmt->u.auth.auth_transaction = cpu_to_le16(transaction);
-	mgmt->u.auth.status_code = cpu_to_le16(status);
-	if (extra)
-		skb_put_data(skb, extra, extra_len);
-	if (multi_link)
-		skb_put_data(skb, &mle, sizeof(mle));
-
-	if (auth_alg == WLAN_AUTH_SHARED_KEY && transaction == 3) {
-		mgmt->frame_control |= cpu_to_le16(IEEE80211_FCTL_PROTECTED);
-		err = ieee80211_wep_encrypt(local, skb, key, key_len, key_idx);
-		if (WARN_ON(err)) {
-			kfree_skb(skb);
-			return;
-		}
-	}
-
-	IEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT |
-					tx_flags;
-	ieee80211_tx_skb(sdata, skb);
-}
-
-void ieee80211_send_deauth_disassoc(struct ieee80211_sub_if_data *sdata,
-				    const u8 *da, const u8 *bssid,
-				    u16 stype, u16 reason,
-				    bool send_frame, u8 *frame_buf)
-{
-	struct ieee80211_local *local = sdata->local;
-	struct sk_buff *skb;
-	struct ieee80211_mgmt *mgmt = (void *)frame_buf;
-
-	/* build frame */
-	mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT | stype);
-	mgmt->duration = 0; /* initialize only */
-	mgmt->seq_ctrl = 0; /* initialize only */
-	memcpy(mgmt->da, da, ETH_ALEN);
-	memcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);
-	memcpy(mgmt->bssid, bssid, ETH_ALEN);
-	/* u.deauth.reason_code == u.disassoc.reason_code */
-	mgmt->u.deauth.reason_code = cpu_to_le16(reason);
-
-	if (send_frame) {
-		skb = dev_alloc_skb(local->hw.extra_tx_headroom +
-				    IEEE80211_DEAUTH_FRAME_LEN);
-		if (!skb)
-			return;
-
-		skb_reserve(skb, local->hw.extra_tx_headroom);
-
-		/* copy in frame */
-		skb_put_data(skb, mgmt, IEEE80211_DEAUTH_FRAME_LEN);
-
-		if (sdata->vif.type != NL80211_IFTYPE_STATION ||
-		    !(sdata->u.mgd.flags & IEEE80211_STA_MFP_ENABLED))
-			IEEE80211_SKB_CB(skb)->flags |=
-				IEEE80211_TX_INTFL_DONT_ENCRYPT;
-
-		ieee80211_tx_skb(sdata, skb);
-	}
-}
-
-u8 *ieee80211_write_he_6ghz_cap(u8 *pos, __le16 cap, u8 *end)
-{
-	if ((end - pos) < 5)
-		return pos;
-
-	*pos++ = WLAN_EID_EXTENSION;
-	*pos++ = 1 + sizeof(cap);
-	*pos++ = WLAN_EID_EXT_HE_6GHZ_CAPA;
-	memcpy(pos, &cap, sizeof(cap));
-
-	return pos + 2;
-}
-
-static int ieee80211_build_preq_ies_band(struct ieee80211_sub_if_data *sdata,
-					 u8 *buffer, size_t buffer_len,
-					 const u8 *ie, size_t ie_len,
-					 enum nl80211_band band,
-					 u32 rate_mask,
-					 struct cfg80211_chan_def *chandef,
-					 size_t *offset, u32 flags)
-{
-	struct ieee80211_local *local = sdata->local;
-	struct ieee80211_supported_band *sband;
-	const struct ieee80211_sta_he_cap *he_cap;
-	const struct ieee80211_sta_eht_cap *eht_cap;
-	u8 *pos = buffer, *end = buffer + buffer_len;
-	size_t noffset;
-	int supp_rates_len, i;
-	u8 rates[32];
-	int num_rates;
-	int ext_rates_len;
-	int shift;
-	u32 rate_flags;
-	bool have_80mhz = false;
-
-	*offset = 0;
-
-	sband = local->hw.wiphy->bands[band];
-	if (WARN_ON_ONCE(!sband))
-		return 0;
-
-	rate_flags = ieee80211_chandef_rate_flags(chandef);
-	shift = ieee80211_chandef_get_shift(chandef);
-
-	/* For direct scan add S1G IE and consider its override bits */
-	if (band == NL80211_BAND_S1GHZ) {
-		if (end - pos < 2 + sizeof(struct ieee80211_s1g_cap))
-			goto out_err;
-		pos = ieee80211_ie_build_s1g_cap(pos, &sband->s1g_cap);
-		goto done;
-	}
-
-	num_rates = 0;
-	for (i = 0; i < sband->n_bitrates; i++) {
-		if ((BIT(i) & rate_mask) == 0)
-			continue; /* skip rate */
-		if ((rate_flags & sband->bitrates[i].flags) != rate_flags)
-			continue;
-
-		rates[num_rates++] =
-			(u8) DIV_ROUND_UP(sband->bitrates[i].bitrate,
-					  (1 << shift) * 5);
-	}
-
-	supp_rates_len = min_t(int, num_rates, 8);
-
-	if (end - pos < 2 + supp_rates_len)
-		goto out_err;
-	*pos++ = WLAN_EID_SUPP_RATES;
-	*pos++ = supp_rates_len;
-	memcpy(pos, rates, supp_rates_len);
-	pos += supp_rates_len;
-
-	/* insert "request information" if in custom IEs */
-	if (ie && ie_len) {
-		static const u8 before_extrates[] = {
-			WLAN_EID_SSID,
-			WLAN_EID_SUPP_RATES,
-			WLAN_EID_REQUEST,
-		};
-		noffset = ieee80211_ie_split(ie, ie_len,
-					     before_extrates,
-					     ARRAY_SIZE(before_extrates),
-					     *offset);
-		if (end - pos < noffset - *offset)
-			goto out_err;
-		memcpy(pos, ie + *offset, noffset - *offset);
-		pos += noffset - *offset;
-		*offset = noffset;
-	}
-
-	ext_rates_len = num_rates - supp_rates_len;
-	if (ext_rates_len > 0) {
-		if (end - pos < 2 + ext_rates_len)
-			goto out_err;
-		*pos++ = WLAN_EID_EXT_SUPP_RATES;
-		*pos++ = ext_rates_len;
-		memcpy(pos, rates + supp_rates_len, ext_rates_len);
-		pos += ext_rates_len;
-	}
-
-	if (chandef->chan && sband->band == NL80211_BAND_2GHZ) {
-		if (end - pos < 3)
-			goto out_err;
-		*pos++ = WLAN_EID_DS_PARAMS;
-		*pos++ = 1;
-		*pos++ = ieee80211_frequency_to_channel(
-				chandef->chan->center_freq);
-	}
-
-	if (flags & IEEE80211_PROBE_FLAG_MIN_CONTENT)
-		goto done;
-
-	/* insert custom IEs that go before HT */
-	if (ie && ie_len) {
-		static const u8 before_ht[] = {
-			/*
-			 * no need to list the ones split off already
-			 * (or generated here)
-			 */
-			WLAN_EID_DS_PARAMS,
-			WLAN_EID_SUPPORTED_REGULATORY_CLASSES,
-		};
-		noffset = ieee80211_ie_split(ie, ie_len,
-					     before_ht, ARRAY_SIZE(before_ht),
-					     *offset);
-		if (end - pos < noffset - *offset)
-			goto out_err;
-		memcpy(pos, ie + *offset, noffset - *offset);
-		pos += noffset - *offset;
-		*offset = noffset;
-	}
-
-	if (sband->ht_cap.ht_supported) {
-		if (end - pos < 2 + sizeof(struct ieee80211_ht_cap))
-			goto out_err;
-		pos = ieee80211_ie_build_ht_cap(pos, &sband->ht_cap,
-						sband->ht_cap.cap);
-	}
-
-	/* insert custom IEs that go before VHT */
-	if (ie && ie_len) {
-		static const u8 before_vht[] = {
-			/*
-			 * no need to list the ones split off already
-			 * (or generated here)
-			 */
-			WLAN_EID_BSS_COEX_2040,
-			WLAN_EID_EXT_CAPABILITY,
-			WLAN_EID_SSID_LIST,
-			WLAN_EID_CHANNEL_USAGE,
-			WLAN_EID_INTERWORKING,
-			WLAN_EID_MESH_ID,
-			/* 60 GHz (Multi-band, DMG, MMS) can't happen */
-		};
-		noffset = ieee80211_ie_split(ie, ie_len,
-					     before_vht, ARRAY_SIZE(before_vht),
-					     *offset);
-		if (end - pos < noffset - *offset)
-			goto out_err;
-		memcpy(pos, ie + *offset, noffset - *offset);
-		pos += noffset - *offset;
-		*offset = noffset;
-	}
-
-	/* Check if any channel in this sband supports at least 80 MHz */
-	for (i = 0; i < sband->n_channels; i++) {
-		if (sband->channels[i].flags & (IEEE80211_CHAN_DISABLED |
-						IEEE80211_CHAN_NO_80MHZ))
-			continue;
-
-		have_80mhz = true;
-		break;
-	}
-
-	if (sband->vht_cap.vht_supported && have_80mhz) {
-		if (end - pos < 2 + sizeof(struct ieee80211_vht_cap))
-			goto out_err;
-		pos = ieee80211_ie_build_vht_cap(pos, &sband->vht_cap,
-						 sband->vht_cap.cap);
-	}
-
-	/* insert custom IEs that go before HE */
-	if (ie && ie_len) {
-		static const u8 before_he[] = {
-			/*
-			 * no need to list the ones split off before VHT
-			 * or generated here
-			 */
-			WLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_REQ_PARAMS,
-			WLAN_EID_AP_CSN,
-			/* TODO: add 11ah/11aj/11ak elements */
-		};
-		noffset = ieee80211_ie_split(ie, ie_len,
-					     before_he, ARRAY_SIZE(before_he),
-					     *offset);
-		if (end - pos < noffset - *offset)
-			goto out_err;
-		memcpy(pos, ie + *offset, noffset - *offset);
-		pos += noffset - *offset;
-		*offset = noffset;
-	}
-
-	he_cap = ieee80211_get_he_iftype_cap_vif(sband, &sdata->vif);
-	if (he_cap &&
-	    cfg80211_any_usable_channels(local->hw.wiphy, BIT(sband->band),
-					 IEEE80211_CHAN_NO_HE)) {
-		pos = ieee80211_ie_build_he_cap(0, pos, he_cap, end);
-		if (!pos)
-			goto out_err;
-	}
-
-	eht_cap = ieee80211_get_eht_iftype_cap_vif(sband, &sdata->vif);
-
-	if (eht_cap &&
-	    cfg80211_any_usable_channels(local->hw.wiphy, BIT(sband->band),
-					 IEEE80211_CHAN_NO_HE |
-					 IEEE80211_CHAN_NO_EHT)) {
-		pos = ieee80211_ie_build_eht_cap(pos, he_cap, eht_cap, end,
-						 sdata->vif.type == NL80211_IFTYPE_AP);
-		if (!pos)
-			goto out_err;
-	}
-
-	if (cfg80211_any_usable_channels(local->hw.wiphy,
-					 BIT(NL80211_BAND_6GHZ),
-					 IEEE80211_CHAN_NO_HE)) {
-		struct ieee80211_supported_band *sband6;
-
-		sband6 = local->hw.wiphy->bands[NL80211_BAND_6GHZ];
-		he_cap = ieee80211_get_he_iftype_cap_vif(sband6, &sdata->vif);
-
-		if (he_cap) {
-			enum nl80211_iftype iftype =
-				ieee80211_vif_type_p2p(&sdata->vif);
-			__le16 cap = ieee80211_get_he_6ghz_capa(sband6, iftype);
-
-			pos = ieee80211_write_he_6ghz_cap(pos, cap, end);
-		}
-	}
-
-	/*
-	 * If adding more here, adjust code in main.c
-	 * that calculates local->scan_ies_len.
-	 */
-
-	return pos - buffer;
- out_err:
-	WARN_ONCE(1, "not enough space for preq IEs\n");
- done:
-	return pos - buffer;
-}
-
-int ieee80211_build_preq_ies(struct ieee80211_sub_if_data *sdata, u8 *buffer,
-			     size_t buffer_len,
-			     struct ieee80211_scan_ies *ie_desc,
-			     const u8 *ie, size_t ie_len,
-			     u8 bands_used, u32 *rate_masks,
-			     struct cfg80211_chan_def *chandef,
-			     u32 flags)
-{
-	size_t pos = 0, old_pos = 0, custom_ie_offset = 0;
-	int i;
-
-	memset(ie_desc, 0, sizeof(*ie_desc));
-
-	for (i = 0; i < NUM_NL80211_BANDS; i++) {
-		if (bands_used & BIT(i)) {
-			pos += ieee80211_build_preq_ies_band(sdata,
-							     buffer + pos,
-							     buffer_len - pos,
-							     ie, ie_len, i,
-							     rate_masks[i],
-							     chandef,
-							     &custom_ie_offset,
-							     flags);
-			ie_desc->ies[i] = buffer + old_pos;
-			ie_desc->len[i] = pos - old_pos;
-			old_pos = pos;
-		}
-	}
-
-	/* add any remaining custom IEs */
-	if (ie && ie_len) {
-		if (WARN_ONCE(buffer_len - pos < ie_len - custom_ie_offset,
-			      "not enough space for preq custom IEs\n"))
-			return pos;
-		memcpy(buffer + pos, ie + custom_ie_offset,
-		       ie_len - custom_ie_offset);
-		ie_desc->common_ies = buffer + pos;
-		ie_desc->common_ie_len = ie_len - custom_ie_offset;
-		pos += ie_len - custom_ie_offset;
-	}
-
-	return pos;
-};
-
-struct sk_buff *ieee80211_build_probe_req(struct ieee80211_sub_if_data *sdata,
-					  const u8 *src, const u8 *dst,
-					  u32 ratemask,
-					  struct ieee80211_channel *chan,
-					  const u8 *ssid, size_t ssid_len,
-					  const u8 *ie, size_t ie_len,
-					  u32 flags)
-{
-	struct ieee80211_local *local = sdata->local;
-	struct cfg80211_chan_def chandef;
-	struct sk_buff *skb;
-	struct ieee80211_mgmt *mgmt;
-	int ies_len;
-	u32 rate_masks[NUM_NL80211_BANDS] = {};
-	struct ieee80211_scan_ies dummy_ie_desc;
-
-	/*
-	 * Do not send DS Channel parameter for directed probe requests
-	 * in order to maximize the chance that we get a response.  Some
-	 * badly-behaved APs don't respond when this parameter is included.
-	 */
-	chandef.width = sdata->vif.bss_conf.chandef.width;
-	if (flags & IEEE80211_PROBE_FLAG_DIRECTED)
-		chandef.chan = NULL;
-	else
-		chandef.chan = chan;
-
-	skb = ieee80211_probereq_get(&local->hw, src, ssid, ssid_len,
-				     local->scan_ies_len + ie_len);
-	if (!skb)
-		return NULL;
-
-	rate_masks[chan->band] = ratemask;
-	ies_len = ieee80211_build_preq_ies(sdata, skb_tail_pointer(skb),
-					   skb_tailroom(skb), &dummy_ie_desc,
-					   ie, ie_len, BIT(chan->band),
-					   rate_masks, &chandef, flags);
-	skb_put(skb, ies_len);
-
-	if (dst) {
-		mgmt = (struct ieee80211_mgmt *) skb->data;
-		memcpy(mgmt->da, dst, ETH_ALEN);
-		memcpy(mgmt->bssid, dst, ETH_ALEN);
-	}
-
-	IEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;
-
-	return skb;
-}
-
-u32 ieee80211_sta_get_rates(struct ieee80211_sub_if_data *sdata,
-			    struct ieee802_11_elems *elems,
-			    enum nl80211_band band, u32 *basic_rates)
-{
-	struct ieee80211_supported_band *sband;
-	size_t num_rates;
-	u32 supp_rates, rate_flags;
-	int i, j, shift;
-
-	sband = sdata->local->hw.wiphy->bands[band];
-	if (WARN_ON(!sband))
-		return 1;
-
-	rate_flags = ieee80211_chandef_rate_flags(&sdata->vif.bss_conf.chandef);
-	shift = ieee80211_vif_get_shift(&sdata->vif);
-
-	num_rates = sband->n_bitrates;
-	supp_rates = 0;
-	for (i = 0; i < elems->supp_rates_len +
-		     elems->ext_supp_rates_len; i++) {
-		u8 rate = 0;
-		int own_rate;
-		bool is_basic;
-		if (i < elems->supp_rates_len)
-			rate = elems->supp_rates[i];
-		else if (elems->ext_supp_rates)
-			rate = elems->ext_supp_rates
-				[i - elems->supp_rates_len];
-		own_rate = 5 * (rate & 0x7f);
-		is_basic = !!(rate & 0x80);
-
-		if (is_basic && (rate & 0x7f) == BSS_MEMBERSHIP_SELECTOR_HT_PHY)
-			continue;
-
-		for (j = 0; j < num_rates; j++) {
-			int brate;
-			if ((rate_flags & sband->bitrates[j].flags)
-			    != rate_flags)
-				continue;
-
-			brate = DIV_ROUND_UP(sband->bitrates[j].bitrate,
-					     1 << shift);
-
-			if (brate == own_rate) {
-				supp_rates |= BIT(j);
-				if (basic_rates && is_basic)
-					*basic_rates |= BIT(j);
-			}
-		}
-	}
-	return supp_rates;
-}
-
-void ieee80211_stop_device(struct ieee80211_local *local)
-{
-	local_bh_disable();
-	ieee80211_handle_queued_frames(local);
-	local_bh_enable();
-
-	ieee80211_led_radio(local, false);
-	ieee80211_mod_tpt_led_trig(local, 0, IEEE80211_TPT_LEDTRIG_FL_RADIO);
-
-	cancel_work_sync(&local->reconfig_filter);
-
-	flush_workqueue(local->workqueue);
-	drv_stop(local);
-}
-
-static void ieee80211_flush_completed_scan(struct ieee80211_local *local,
-					   bool aborted)
-{
-	/* It's possible that we don't handle the scan completion in
-	 * time during suspend, so if it's still marked as completed
-	 * here, queue the work and flush it to clean things up.
-	 * Instead of calling the worker function directly here, we
-	 * really queue it to avoid potential races with other flows
-	 * scheduling the same work.
-	 */
-	if (test_bit(SCAN_COMPLETED, &local->scanning)) {
-		/* If coming from reconfiguration failure, abort the scan so
-		 * we don't attempt to continue a partial HW scan - which is
-		 * possible otherwise if (e.g.) the 2.4 GHz portion was the
-		 * completed scan, and a 5 GHz portion is still pending.
-		 */
-		if (aborted)
-			set_bit(SCAN_ABORTED, &local->scanning);
-		wiphy_delayed_work_queue(local->hw.wiphy, &local->scan_work, 0);
-		wiphy_delayed_work_flush(local->hw.wiphy, &local->scan_work);
-	}
-}
-
-static void ieee80211_handle_reconfig_failure(struct ieee80211_local *local)
-{
-	struct ieee80211_sub_if_data *sdata;
-	struct ieee80211_chanctx *ctx;
-
-	/*
-	 * We get here if during resume the device can't be restarted properly.
-	 * We might also get here if this happens during HW reset, which is a
-	 * slightly different situation and we need to drop all connections in
-	 * the latter case.
-	 *
-	 * Ask cfg80211 to turn off all interfaces, this will result in more
-	 * warnings but at least we'll then get into a clean stopped state.
-	 */
-
-	local->resuming = false;
-	local->suspended = false;
-	local->in_reconfig = false;
-	local->reconfig_failure = true;
-
-	ieee80211_flush_completed_scan(local, true);
-
-	/* scheduled scan clearly can't be running any more, but tell
-	 * cfg80211 and clear local state
-	 */
-	ieee80211_sched_scan_end(local);
-
-	list_for_each_entry(sdata, &local->interfaces, list)
-		sdata->flags &= ~IEEE80211_SDATA_IN_DRIVER;
-
-	/* Mark channel contexts as not being in the driver any more to avoid
-	 * removing them from the driver during the shutdown process...
-	 */
-	mutex_lock(&local->chanctx_mtx);
-	list_for_each_entry(ctx, &local->chanctx_list, list)
-		ctx->driver_present = false;
-	mutex_unlock(&local->chanctx_mtx);
-}
-
-static void ieee80211_assign_chanctx(struct ieee80211_local *local,
-				     struct ieee80211_sub_if_data *sdata,
-				     struct ieee80211_link_data *link)
-{
-	struct ieee80211_chanctx_conf *conf;
-	struct ieee80211_chanctx *ctx;
-
-	if (!local->use_chanctx)
-		return;
-
-	mutex_lock(&local->chanctx_mtx);
-	conf = rcu_dereference_protected(link->conf->chanctx_conf,
-					 lockdep_is_held(&local->chanctx_mtx));
-	if (conf) {
-		ctx = container_of(conf, struct ieee80211_chanctx, conf);
-		drv_assign_vif_chanctx(local, sdata, link->conf, ctx);
-	}
-	mutex_unlock(&local->chanctx_mtx);
-}
-
-static void ieee80211_reconfig_stations(struct ieee80211_sub_if_data *sdata)
-{
-	struct ieee80211_local *local = sdata->local;
-	struct sta_info *sta;
-
-	/* add STAs back */
-	mutex_lock(&local->sta_mtx);
-	list_for_each_entry(sta, &local->sta_list, list) {
-		enum ieee80211_sta_state state;
-
-		if (!sta->uploaded || sta->sdata != sdata)
-			continue;
-
-		for (state = IEEE80211_STA_NOTEXIST;
-		     state < sta->sta_state; state++)
-			WARN_ON(drv_sta_state(local, sta->sdata, sta, state,
-					      state + 1));
-	}
-	mutex_unlock(&local->sta_mtx);
-}
-
-static int ieee80211_reconfig_nan(struct ieee80211_sub_if_data *sdata)
-{
-	struct cfg80211_nan_func *func, **funcs;
-	int res, id, i = 0;
-
-	res = drv_start_nan(sdata->local, sdata,
-			    &sdata->u.nan.conf);
-	if (WARN_ON(res))
-		return res;
-
-	funcs = kcalloc(sdata->local->hw.max_nan_de_entries + 1,
-			sizeof(*funcs),
-			GFP_KERNEL);
-	if (!funcs)
-		return -ENOMEM;
-
-	/* Add all the functions:
-	 * This is a little bit ugly. We need to call a potentially sleeping
-	 * callback for each NAN function, so we can't hold the spinlock.
-	 */
-	spin_lock_bh(&sdata->u.nan.func_lock);
-
-	idr_for_each_entry(&sdata->u.nan.function_inst_ids, func, id)
-		funcs[i++] = func;
-
-	spin_unlock_bh(&sdata->u.nan.func_lock);
-
-	for (i = 0; funcs[i]; i++) {
-		res = drv_add_nan_func(sdata->local, sdata, funcs[i]);
-		if (WARN_ON(res))
-			ieee80211_nan_func_terminated(&sdata->vif,
-						      funcs[i]->instance_id,
-						      NL80211_NAN_FUNC_TERM_REASON_ERROR,
-						      GFP_KERNEL);
-	}
-
-	kfree(funcs);
-
-	return 0;
-}
-
-static void ieee80211_reconfig_ap_links(struct ieee80211_local *local,
-					struct ieee80211_sub_if_data *sdata,
-					u64 changed)
-{
-	int link_id;
-
-	for (link_id = 0; link_id < ARRAY_SIZE(sdata->link); link_id++) {
-		struct ieee80211_link_data *link;
-
-		if (!(sdata->vif.active_links & BIT(link_id)))
-			continue;
-
-		link = sdata_dereference(sdata->link[link_id], sdata);
-		if (!link)
-			continue;
-
-		if (rcu_access_pointer(link->u.ap.beacon))
-			drv_start_ap(local, sdata, link->conf);
-
-		if (!link->conf->enable_beacon)
-			continue;
-
-		changed |= BSS_CHANGED_BEACON |
-			   BSS_CHANGED_BEACON_ENABLED;
-
-		ieee80211_link_info_change_notify(sdata, link, changed);
-	}
-}
-
-int ieee80211_reconfig(struct ieee80211_local *local)
-{
-	struct ieee80211_hw *hw = &local->hw;
-	struct ieee80211_sub_if_data *sdata;
-	struct ieee80211_chanctx *ctx;
-	struct sta_info *sta;
-	int res, i;
-	bool reconfig_due_to_wowlan = false;
-	struct ieee80211_sub_if_data *sched_scan_sdata;
-	struct cfg80211_sched_scan_request *sched_scan_req;
-	bool sched_scan_stopped = false;
-	bool suspended = local->suspended;
-	bool in_reconfig = false;
-
-	/* nothing to do if HW shouldn't run */
-	if (!local->open_count)
-		goto wake_up;
-
-#ifdef CONFIG_PM
-	if (suspended)
-		local->resuming = true;
-
-	if (local->wowlan) {
-		/*
-		 * In the wowlan case, both mac80211 and the device
-		 * are functional when the resume op is called, so
-		 * clear local->suspended so the device could operate
-		 * normally (e.g. pass rx frames).
-		 */
-		local->suspended = false;
-		res = drv_resume(local);
-		local->wowlan = false;
-		if (res < 0) {
-			local->resuming = false;
-			return res;
-		}
-		if (res == 0)
-			goto wake_up;
-		WARN_ON(res > 1);
-		/*
-		 * res is 1, which means the driver requested
-		 * to go through a regular reset on wakeup.
-		 * restore local->suspended in this case.
-		 */
-		reconfig_due_to_wowlan = true;
-		local->suspended = true;
-	}
-#endif
-
-	/*
-	 * In case of hw_restart during suspend (without wowlan),
-	 * cancel restart work, as we are reconfiguring the device
-	 * anyway.
-	 * Note that restart_work is scheduled on a frozen workqueue,
-	 * so we can't deadlock in this case.
-	 */
-	if (suspended && local->in_reconfig && !reconfig_due_to_wowlan)
-		cancel_work_sync(&local->restart_work);
-
-	local->started = false;
-
-	/*
-	 * Upon resume hardware can sometimes be goofy due to
-	 * various platform / driver / bus issues, so restarting
-	 * the device may at times not work immediately. Propagate
-	 * the error.
-	 */
-	res = drv_start(local);
-	if (res) {
-		if (suspended)
-			WARN(1, "Hardware became unavailable upon resume. This could be a software issue prior to suspend or a hardware issue.\n");
-		else
-			WARN(1, "Hardware became unavailable during restart.\n");
-		ieee80211_wake_queues_by_reason(hw, IEEE80211_MAX_QUEUE_MAP,
-						IEEE80211_QUEUE_STOP_REASON_SUSPEND,
-						false);
-		ieee80211_handle_reconfig_failure(local);
-		return res;
-	}
-
-	/* setup fragmentation threshold */
-	drv_set_frag_threshold(local, hw->wiphy->frag_threshold);
-
-	/* setup RTS threshold */
-	drv_set_rts_threshold(local, hw->wiphy->rts_threshold);
-
-	/* reset coverage class */
-	drv_set_coverage_class(local, hw->wiphy->coverage_class);
-
-	ieee80211_led_radio(local, true);
-	ieee80211_mod_tpt_led_trig(local,
-				   IEEE80211_TPT_LEDTRIG_FL_RADIO, 0);
-
-	/* add interfaces */
-	sdata = wiphy_dereference(local->hw.wiphy, local->monitor_sdata);
-	if (sdata) {
-		/* in HW restart it exists already */
-		WARN_ON(local->resuming);
-		res = drv_add_interface(local, sdata);
-		if (WARN_ON(res)) {
-			RCU_INIT_POINTER(local->monitor_sdata, NULL);
-			synchronize_net();
-			kfree(sdata);
-		}
-	}
-
-	list_for_each_entry(sdata, &local->interfaces, list) {
-		if (sdata->vif.type != NL80211_IFTYPE_AP_VLAN &&
-		    sdata->vif.type != NL80211_IFTYPE_MONITOR &&
-		    ieee80211_sdata_running(sdata)) {
-			res = drv_add_interface(local, sdata);
-			if (WARN_ON(res))
-				break;
-		}
-	}
-
-	/* If adding any of the interfaces failed above, roll back and
-	 * report failure.
-	 */
-	if (res) {
-		list_for_each_entry_continue_reverse(sdata, &local->interfaces,
-						     list)
-			if (sdata->vif.type != NL80211_IFTYPE_AP_VLAN &&
-			    sdata->vif.type != NL80211_IFTYPE_MONITOR &&
-			    ieee80211_sdata_running(sdata))
-				drv_remove_interface(local, sdata);
-		ieee80211_handle_reconfig_failure(local);
-		return res;
-	}
-
-	/* add channel contexts */
-	if (local->use_chanctx) {
-		mutex_lock(&local->chanctx_mtx);
-		list_for_each_entry(ctx, &local->chanctx_list, list)
-			if (ctx->replace_state !=
-			    IEEE80211_CHANCTX_REPLACES_OTHER)
-				WARN_ON(drv_add_chanctx(local, ctx));
-		mutex_unlock(&local->chanctx_mtx);
-
-		sdata = wiphy_dereference(local->hw.wiphy,
-					  local->monitor_sdata);
-		if (sdata && ieee80211_sdata_running(sdata))
-			ieee80211_assign_chanctx(local, sdata, &sdata->deflink);
-	}
-
-	/* reconfigure hardware */
-	ieee80211_hw_config(local, ~0);
-
-	ieee80211_configure_filter(local);
-
-	/* Finally also reconfigure all the BSS information */
-	list_for_each_entry(sdata, &local->interfaces, list) {
-		/* common change flags for all interface types - link only */
-		u64 changed = BSS_CHANGED_ERP_CTS_PROT |
-			      BSS_CHANGED_ERP_PREAMBLE |
-			      BSS_CHANGED_ERP_SLOT |
-			      BSS_CHANGED_HT |
-			      BSS_CHANGED_BASIC_RATES |
-			      BSS_CHANGED_BEACON_INT |
-			      BSS_CHANGED_BSSID |
-			      BSS_CHANGED_CQM |
-			      BSS_CHANGED_QOS |
-			      BSS_CHANGED_TXPOWER |
-			      BSS_CHANGED_MCAST_RATE;
-		struct ieee80211_link_data *link = NULL;
-		unsigned int link_id;
-		u32 active_links = 0;
-
-		if (!ieee80211_sdata_running(sdata))
-			continue;
-
-		sdata_lock(sdata);
-		if (ieee80211_vif_is_mld(&sdata->vif)) {
-			struct ieee80211_bss_conf *old[IEEE80211_MLD_MAX_NUM_LINKS] = {
-				[0] = &sdata->vif.bss_conf,
-			};
-
-			if (sdata->vif.type == NL80211_IFTYPE_STATION) {
-				/* start with a single active link */
-				active_links = sdata->vif.active_links;
-				link_id = ffs(active_links) - 1;
-				sdata->vif.active_links = BIT(link_id);
-			}
-
-			drv_change_vif_links(local, sdata, 0,
-					     sdata->vif.active_links,
-					     old);
-		}
-
-		for (link_id = 0;
-		     link_id < ARRAY_SIZE(sdata->vif.link_conf);
-		     link_id++) {
-			if (ieee80211_vif_is_mld(&sdata->vif) &&
-			    !(sdata->vif.active_links & BIT(link_id)))
-				continue;
-
-			link = sdata_dereference(sdata->link[link_id], sdata);
-			if (!link)
-				continue;
-
-			ieee80211_assign_chanctx(local, sdata, link);
-		}
-
-		switch (sdata->vif.type) {
-		case NL80211_IFTYPE_AP_VLAN:
-		case NL80211_IFTYPE_MONITOR:
-			break;
-		case NL80211_IFTYPE_ADHOC:
-			if (sdata->vif.cfg.ibss_joined)
-				WARN_ON(drv_join_ibss(local, sdata));
-			fallthrough;
-		default:
-			ieee80211_reconfig_stations(sdata);
-			fallthrough;
-		case NL80211_IFTYPE_AP: /* AP stations are handled later */
-			for (i = 0; i < IEEE80211_NUM_ACS; i++)
-				drv_conf_tx(local, &sdata->deflink, i,
-					    &sdata->deflink.tx_conf[i]);
-			break;
-		}
-
-		if (sdata->vif.bss_conf.mu_mimo_owner)
-			changed |= BSS_CHANGED_MU_GROUPS;
-
-		if (!ieee80211_vif_is_mld(&sdata->vif))
-			changed |= BSS_CHANGED_IDLE;
-
-		switch (sdata->vif.type) {
-		case NL80211_IFTYPE_STATION:
-			if (!ieee80211_vif_is_mld(&sdata->vif)) {
-				changed |= BSS_CHANGED_ASSOC |
-					   BSS_CHANGED_ARP_FILTER |
-					   BSS_CHANGED_PS;
-
-				/* Re-send beacon info report to the driver */
-				if (sdata->deflink.u.mgd.have_beacon)
-					changed |= BSS_CHANGED_BEACON_INFO;
-
-				if (sdata->vif.bss_conf.max_idle_period ||
-				    sdata->vif.bss_conf.protected_keep_alive)
-					changed |= BSS_CHANGED_KEEP_ALIVE;
-
-				if (sdata->vif.bss_conf.eht_puncturing)
-					changed |= BSS_CHANGED_EHT_PUNCTURING;
-
-				ieee80211_bss_info_change_notify(sdata,
-								 changed);
-			} else if (!WARN_ON(!link)) {
-				ieee80211_link_info_change_notify(sdata, link,
-								  changed);
-				changed = BSS_CHANGED_ASSOC |
-					  BSS_CHANGED_IDLE |
-					  BSS_CHANGED_PS |
-					  BSS_CHANGED_ARP_FILTER;
-				ieee80211_vif_cfg_change_notify(sdata, changed);
-			}
-			break;
-		case NL80211_IFTYPE_OCB:
-			changed |= BSS_CHANGED_OCB;
-			ieee80211_bss_info_change_notify(sdata, changed);
-			break;
-		case NL80211_IFTYPE_ADHOC:
-			changed |= BSS_CHANGED_IBSS;
-			fallthrough;
-		case NL80211_IFTYPE_AP:
-			changed |= BSS_CHANGED_P2P_PS;
-
-			if (ieee80211_vif_is_mld(&sdata->vif))
-				ieee80211_vif_cfg_change_notify(sdata,
-								BSS_CHANGED_SSID);
-			else
-				changed |= BSS_CHANGED_SSID;
-
-			if (sdata->vif.bss_conf.ftm_responder == 1 &&
-			    wiphy_ext_feature_isset(sdata->local->hw.wiphy,
-					NL80211_EXT_FEATURE_ENABLE_FTM_RESPONDER))
-				changed |= BSS_CHANGED_FTM_RESPONDER;
-
-			if (sdata->vif.type == NL80211_IFTYPE_AP) {
-				changed |= BSS_CHANGED_AP_PROBE_RESP;
-
-				if (ieee80211_vif_is_mld(&sdata->vif)) {
-					ieee80211_reconfig_ap_links(local,
-								    sdata,
-								    changed);
-					break;
-				}
-
-				if (rcu_access_pointer(sdata->deflink.u.ap.beacon))
-					drv_start_ap(local, sdata,
-						     sdata->deflink.conf);
-			}
-			fallthrough;
-		case NL80211_IFTYPE_MESH_POINT:
-			if (sdata->vif.bss_conf.enable_beacon) {
-				changed |= BSS_CHANGED_BEACON |
-					   BSS_CHANGED_BEACON_ENABLED;
-				ieee80211_bss_info_change_notify(sdata, changed);
-			}
-			break;
-		case NL80211_IFTYPE_NAN:
-			res = ieee80211_reconfig_nan(sdata);
-			if (res < 0) {
-				sdata_unlock(sdata);
-				ieee80211_handle_reconfig_failure(local);
-				return res;
-			}
-			break;
-		case NL80211_IFTYPE_AP_VLAN:
-		case NL80211_IFTYPE_MONITOR:
-		case NL80211_IFTYPE_P2P_DEVICE:
-			/* nothing to do */
-			break;
-		case NL80211_IFTYPE_UNSPECIFIED:
-		case NUM_NL80211_IFTYPES:
-		case NL80211_IFTYPE_P2P_CLIENT:
-		case NL80211_IFTYPE_P2P_GO:
-		case NL80211_IFTYPE_WDS:
-			WARN_ON(1);
-			break;
-		}
-		sdata_unlock(sdata);
-
-		if (active_links)
-			ieee80211_set_active_links(&sdata->vif, active_links);
-	}
-
-	ieee80211_recalc_ps(local);
-
-	/*
-	 * The sta might be in psm against the ap (e.g. because
-	 * this was the state before a hw restart), so we
-	 * explicitly send a null packet in order to make sure
-	 * it'll sync against the ap (and get out of psm).
-	 */
-	if (!(local->hw.conf.flags & IEEE80211_CONF_PS)) {
-		list_for_each_entry(sdata, &local->interfaces, list) {
-			if (sdata->vif.type != NL80211_IFTYPE_STATION)
-				continue;
-			if (!sdata->u.mgd.associated)
-				continue;
-
-			ieee80211_send_nullfunc(local, sdata, false);
-		}
-	}
-
-	/* APs are now beaconing, add back stations */
-	list_for_each_entry(sdata, &local->interfaces, list) {
-		if (!ieee80211_sdata_running(sdata))
-			continue;
-
-		sdata_lock(sdata);
-		switch (sdata->vif.type) {
-		case NL80211_IFTYPE_AP_VLAN:
-		case NL80211_IFTYPE_AP:
-			ieee80211_reconfig_stations(sdata);
-			break;
-		default:
-			break;
-		}
-		sdata_unlock(sdata);
-	}
-
-	/* add back keys */
-	list_for_each_entry(sdata, &local->interfaces, list)
-		ieee80211_reenable_keys(sdata);
-
-	/* Reconfigure sched scan if it was interrupted by FW restart */
-	mutex_lock(&local->mtx);
-	sched_scan_sdata = rcu_dereference_protected(local->sched_scan_sdata,
-						lockdep_is_held(&local->mtx));
-	sched_scan_req = rcu_dereference_protected(local->sched_scan_req,
-						lockdep_is_held(&local->mtx));
-	if (sched_scan_sdata && sched_scan_req)
-		/*
-		 * Sched scan stopped, but we don't want to report it. Instead,
-		 * we're trying to reschedule. However, if more than one scan
-		 * plan was set, we cannot reschedule since we don't know which
-		 * scan plan was currently running (and some scan plans may have
-		 * already finished).
-		 */
-		if (sched_scan_req->n_scan_plans > 1 ||
-		    __ieee80211_request_sched_scan_start(sched_scan_sdata,
-							 sched_scan_req)) {
-			RCU_INIT_POINTER(local->sched_scan_sdata, NULL);
-			RCU_INIT_POINTER(local->sched_scan_req, NULL);
-			sched_scan_stopped = true;
-		}
-	mutex_unlock(&local->mtx);
-
-	if (sched_scan_stopped)
-		cfg80211_sched_scan_stopped_locked(local->hw.wiphy, 0);
-
- wake_up:
-
-	if (local->monitors == local->open_count && local->monitors > 0)
-		ieee80211_add_virtual_monitor(local);
-
-	/*
-	 * Clear the WLAN_STA_BLOCK_BA flag so new aggregation
-	 * sessions can be established after a resume.
-	 *
-	 * Also tear down aggregation sessions since reconfiguring
-	 * them in a hardware restart scenario is not easily done
-	 * right now, and the hardware will have lost information
-	 * about the sessions, but we and the AP still think they
-	 * are active. This is really a workaround though.
-	 */
-	if (ieee80211_hw_check(hw, AMPDU_AGGREGATION)) {
-		mutex_lock(&local->sta_mtx);
-
-		list_for_each_entry(sta, &local->sta_list, list) {
-			if (!local->resuming)
-				ieee80211_sta_tear_down_BA_sessions(
-						sta, AGG_STOP_LOCAL_REQUEST);
-			clear_sta_flag(sta, WLAN_STA_BLOCK_BA);
-		}
-
-		mutex_unlock(&local->sta_mtx);
-	}
-
-	/*
-	 * If this is for hw restart things are still running.
-	 * We may want to change that later, however.
-	 */
-	if (local->open_count && (!suspended || reconfig_due_to_wowlan))
-		drv_reconfig_complete(local, IEEE80211_RECONFIG_TYPE_RESTART);
-
-	if (local->in_reconfig) {
-		in_reconfig = local->in_reconfig;
-		local->in_reconfig = false;
-		barrier();
-
-		/* Restart deferred ROCs */
-		mutex_lock(&local->mtx);
-		ieee80211_start_next_roc(local);
-		mutex_unlock(&local->mtx);
-
-		/* Requeue all works */
-		list_for_each_entry(sdata, &local->interfaces, list)
-			wiphy_work_queue(local->hw.wiphy, &sdata->work);
-	}
-
-	ieee80211_wake_queues_by_reason(hw, IEEE80211_MAX_QUEUE_MAP,
-					IEEE80211_QUEUE_STOP_REASON_SUSPEND,
-					false);
-
-	if (in_reconfig) {
-		list_for_each_entry(sdata, &local->interfaces, list) {
-			if (!ieee80211_sdata_running(sdata))
-				continue;
-			if (sdata->vif.type == NL80211_IFTYPE_STATION)
-				ieee80211_sta_restart(sdata);
-		}
-	}
-
-	if (!suspended)
-		return 0;
-
-#ifdef CONFIG_PM
-	/* first set suspended false, then resuming */
-	local->suspended = false;
-	mb();
-	local->resuming = false;
-
-	ieee80211_flush_completed_scan(local, false);
-
-	if (local->open_count && !reconfig_due_to_wowlan)
-		drv_reconfig_complete(local, IEEE80211_RECONFIG_TYPE_SUSPEND);
-
-	list_for_each_entry(sdata, &local->interfaces, list) {
-		if (!ieee80211_sdata_running(sdata))
-			continue;
-		if (sdata->vif.type == NL80211_IFTYPE_STATION)
-			ieee80211_sta_restart(sdata);
-	}
-
-	mod_timer(&local->sta_cleanup, jiffies + 1);
-#else
-	WARN_ON(1);
-#endif
-
-	return 0;
-}
-
-static void ieee80211_reconfig_disconnect(struct ieee80211_vif *vif, u8 flag)
-{
-	struct ieee80211_sub_if_data *sdata;
-	struct ieee80211_local *local;
-	struct ieee80211_key *key;
-
-	if (WARN_ON(!vif))
-		return;
-
-	sdata = vif_to_sdata(vif);
-	local = sdata->local;
-
-	if (WARN_ON(flag & IEEE80211_SDATA_DISCONNECT_RESUME &&
-		    !local->resuming))
-		return;
-
-	if (WARN_ON(flag & IEEE80211_SDATA_DISCONNECT_HW_RESTART &&
-		    !local->in_reconfig))
-		return;
-
-	if (WARN_ON(vif->type != NL80211_IFTYPE_STATION))
-		return;
-
-	sdata->flags |= flag;
-
-	mutex_lock(&local->key_mtx);
-	list_for_each_entry(key, &sdata->key_list, list)
-		key->flags |= KEY_FLAG_TAINTED;
-	mutex_unlock(&local->key_mtx);
-}
-
-void ieee80211_hw_restart_disconnect(struct ieee80211_vif *vif)
-{
-	ieee80211_reconfig_disconnect(vif, IEEE80211_SDATA_DISCONNECT_HW_RESTART);
-}
-EXPORT_SYMBOL_GPL(ieee80211_hw_restart_disconnect);
-
-void ieee80211_resume_disconnect(struct ieee80211_vif *vif)
-{
-	ieee80211_reconfig_disconnect(vif, IEEE80211_SDATA_DISCONNECT_RESUME);
-}
-EXPORT_SYMBOL_GPL(ieee80211_resume_disconnect);
-
-void ieee80211_recalc_smps(struct ieee80211_sub_if_data *sdata,
-			   struct ieee80211_link_data *link)
-{
-	struct ieee80211_local *local = sdata->local;
-	struct ieee80211_chanctx_conf *chanctx_conf;
-	struct ieee80211_chanctx *chanctx;
-
-	mutex_lock(&local->chanctx_mtx);
-
-	chanctx_conf = rcu_dereference_protected(link->conf->chanctx_conf,
-						 lockdep_is_held(&local->chanctx_mtx));
-
-	/*
-	 * This function can be called from a work, thus it may be possible
-	 * that the chanctx_conf is removed (due to a disconnection, for
-	 * example).
-	 * So nothing should be done in such case.
-	 */
-	if (!chanctx_conf)
-		goto unlock;
-
-	chanctx = container_of(chanctx_conf, struct ieee80211_chanctx, conf);
-	ieee80211_recalc_smps_chanctx(local, chanctx);
- unlock:
-	mutex_unlock(&local->chanctx_mtx);
-}
-
-void ieee80211_recalc_min_chandef(struct ieee80211_sub_if_data *sdata,
-				  int link_id)
-{
-	struct ieee80211_local *local = sdata->local;
-	struct ieee80211_chanctx_conf *chanctx_conf;
-	struct ieee80211_chanctx *chanctx;
-	int i;
-
-	mutex_lock(&local->chanctx_mtx);
-
-	for (i = 0; i < ARRAY_SIZE(sdata->vif.link_conf); i++) {
-		struct ieee80211_bss_conf *bss_conf;
-
-		if (link_id >= 0 && link_id != i)
-			continue;
-
-		rcu_read_lock();
-		bss_conf = rcu_dereference(sdata->vif.link_conf[i]);
-		if (!bss_conf) {
-			rcu_read_unlock();
-			continue;
-		}
-
-		chanctx_conf = rcu_dereference_protected(bss_conf->chanctx_conf,
-							 lockdep_is_held(&local->chanctx_mtx));
-		/*
-		 * Since we hold the chanctx_mtx (checked above)
-		 * we can take the chanctx_conf pointer out of the
-		 * RCU critical section, it cannot go away without
-		 * the mutex. Just the way we reached it could - in
-		 * theory - go away, but we don't really care and
-		 * it really shouldn't happen anyway.
-		 */
-		rcu_read_unlock();
-
-		if (!chanctx_conf)
-			goto unlock;
-
-		chanctx = container_of(chanctx_conf, struct ieee80211_chanctx,
-				       conf);
-		ieee80211_recalc_chanctx_min_def(local, chanctx, NULL);
-	}
- unlock:
-	mutex_unlock(&local->chanctx_mtx);
-}
-
-size_t ieee80211_ie_split_vendor(const u8 *ies, size_t ielen, size_t offset)
-{
-	size_t pos = offset;
-
-	while (pos < ielen && ies[pos] != WLAN_EID_VENDOR_SPECIFIC)
-		pos += 2 + ies[pos + 1];
-
-	return pos;
-}
-
-u8 *ieee80211_ie_build_s1g_cap(u8 *pos, struct ieee80211_sta_s1g_cap *s1g_cap)
-{
-	*pos++ = WLAN_EID_S1G_CAPABILITIES;
-	*pos++ = sizeof(struct ieee80211_s1g_cap);
-	memset(pos, 0, sizeof(struct ieee80211_s1g_cap));
-
-	memcpy(pos, &s1g_cap->cap, sizeof(s1g_cap->cap));
-	pos += sizeof(s1g_cap->cap);
-
-	memcpy(pos, &s1g_cap->nss_mcs, sizeof(s1g_cap->nss_mcs));
-	pos += sizeof(s1g_cap->nss_mcs);
-
-	return pos;
-}
-
-u8 *ieee80211_ie_build_ht_cap(u8 *pos, struct ieee80211_sta_ht_cap *ht_cap,
-			      u16 cap)
-{
-	__le16 tmp;
-
-	*pos++ = WLAN_EID_HT_CAPABILITY;
-	*pos++ = sizeof(struct ieee80211_ht_cap);
-	memset(pos, 0, sizeof(struct ieee80211_ht_cap));
-
-	/* capability flags */
-	tmp = cpu_to_le16(cap);
-	memcpy(pos, &tmp, sizeof(u16));
-	pos += sizeof(u16);
-
-	/* AMPDU parameters */
-	*pos++ = ht_cap->ampdu_factor |
-		 (ht_cap->ampdu_density <<
-			IEEE80211_HT_AMPDU_PARM_DENSITY_SHIFT);
-
-	/* MCS set */
-	memcpy(pos, &ht_cap->mcs, sizeof(ht_cap->mcs));
-	pos += sizeof(ht_cap->mcs);
-
-	/* extended capabilities */
-	pos += sizeof(__le16);
-
-	/* BF capabilities */
-	pos += sizeof(__le32);
-
-	/* antenna selection */
-	pos += sizeof(u8);
-
-	return pos;
-}
-
-u8 *ieee80211_ie_build_vht_cap(u8 *pos, struct ieee80211_sta_vht_cap *vht_cap,
-			       u32 cap)
-{
-	__le32 tmp;
-
-	*pos++ = WLAN_EID_VHT_CAPABILITY;
-	*pos++ = sizeof(struct ieee80211_vht_cap);
-	memset(pos, 0, sizeof(struct ieee80211_vht_cap));
-
-	/* capability flags */
-	tmp = cpu_to_le32(cap);
-	memcpy(pos, &tmp, sizeof(u32));
-	pos += sizeof(u32);
-
-	/* VHT MCS set */
-	memcpy(pos, &vht_cap->vht_mcs, sizeof(vht_cap->vht_mcs));
-	pos += sizeof(vht_cap->vht_mcs);
-
-	return pos;
-}
-
-u8 ieee80211_ie_len_he_cap(struct ieee80211_sub_if_data *sdata, u8 iftype)
-{
-	const struct ieee80211_sta_he_cap *he_cap;
-	struct ieee80211_supported_band *sband;
-	u8 n;
-
-	sband = ieee80211_get_sband(sdata);
-	if (!sband)
-		return 0;
-
-	he_cap = ieee80211_get_he_iftype_cap(sband, iftype);
-	if (!he_cap)
-		return 0;
-
-	n = ieee80211_he_mcs_nss_size(&he_cap->he_cap_elem);
-	return 2 + 1 +
-	       sizeof(he_cap->he_cap_elem) + n +
-	       ieee80211_he_ppe_size(he_cap->ppe_thres[0],
-				     he_cap->he_cap_elem.phy_cap_info);
-}
-
-u8 *ieee80211_ie_build_he_cap(ieee80211_conn_flags_t disable_flags, u8 *pos,
-			      const struct ieee80211_sta_he_cap *he_cap,
-			      u8 *end)
-{
-	struct ieee80211_he_cap_elem elem;
-	u8 n;
-	u8 ie_len;
-	u8 *orig_pos = pos;
-
-	/* Make sure we have place for the IE */
-	/*
-	 * TODO: the 1 added is because this temporarily is under the EXTENSION
-	 * IE. Get rid of it when it moves.
-	 */
-	if (!he_cap)
-		return orig_pos;
-
-	/* modify on stack first to calculate 'n' and 'ie_len' correctly */
-	elem = he_cap->he_cap_elem;
-
-	if (disable_flags & IEEE80211_CONN_DISABLE_40MHZ)
-		elem.phy_cap_info[0] &=
-			~(IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_80MHZ_IN_5G |
-			  IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_IN_2G);
-
-	if (disable_flags & IEEE80211_CONN_DISABLE_160MHZ)
-		elem.phy_cap_info[0] &=
-			~IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G;
-
-	if (disable_flags & IEEE80211_CONN_DISABLE_80P80MHZ)
-		elem.phy_cap_info[0] &=
-			~IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G;
-
-	n = ieee80211_he_mcs_nss_size(&elem);
-	ie_len = 2 + 1 +
-		 sizeof(he_cap->he_cap_elem) + n +
-		 ieee80211_he_ppe_size(he_cap->ppe_thres[0],
-				       he_cap->he_cap_elem.phy_cap_info);
-
-	if ((end - pos) < ie_len)
-		return orig_pos;
-
-	*pos++ = WLAN_EID_EXTENSION;
-	pos++; /* We'll set the size later below */
-	*pos++ = WLAN_EID_EXT_HE_CAPABILITY;
-
-	/* Fixed data */
-	memcpy(pos, &elem, sizeof(elem));
-	pos += sizeof(elem);
-
-	memcpy(pos, &he_cap->he_mcs_nss_supp, n);
-	pos += n;
-
-	/* Check if PPE Threshold should be present */
-	if ((he_cap->he_cap_elem.phy_cap_info[6] &
-	     IEEE80211_HE_PHY_CAP6_PPE_THRESHOLD_PRESENT) == 0)
-		goto end;
-
-	/*
-	 * Calculate how many PPET16/PPET8 pairs are to come. Algorithm:
-	 * (NSS_M1 + 1) x (num of 1 bits in RU_INDEX_BITMASK)
-	 */
-	n = hweight8(he_cap->ppe_thres[0] &
-		     IEEE80211_PPE_THRES_RU_INDEX_BITMASK_MASK);
-	n *= (1 + ((he_cap->ppe_thres[0] & IEEE80211_PPE_THRES_NSS_MASK) >>
-		   IEEE80211_PPE_THRES_NSS_POS));
-
-	/*
-	 * Each pair is 6 bits, and we need to add the 7 "header" bits to the
-	 * total size.
-	 */
-	n = (n * IEEE80211_PPE_THRES_INFO_PPET_SIZE * 2) + 7;
-	n = DIV_ROUND_UP(n, 8);
-
-	/* Copy PPE Thresholds */
-	memcpy(pos, &he_cap->ppe_thres, n);
-	pos += n;
-
-end:
-	orig_pos[1] = (pos - orig_pos) - 2;
-	return pos;
-}
-
-void ieee80211_ie_build_he_6ghz_cap(struct ieee80211_sub_if_data *sdata,
-				    enum ieee80211_smps_mode smps_mode,
-				    struct sk_buff *skb)
-{
-	struct ieee80211_supported_band *sband;
-	const struct ieee80211_sband_iftype_data *iftd;
-	enum nl80211_iftype iftype = ieee80211_vif_type_p2p(&sdata->vif);
-	u8 *pos;
-	u16 cap;
-
-	if (!cfg80211_any_usable_channels(sdata->local->hw.wiphy,
-					  BIT(NL80211_BAND_6GHZ),
-					  IEEE80211_CHAN_NO_HE))
-		return;
-
-	sband = sdata->local->hw.wiphy->bands[NL80211_BAND_6GHZ];
-
-	iftd = ieee80211_get_sband_iftype_data(sband, iftype);
-	if (!iftd)
-		return;
-
-	/* Check for device HE 6 GHz capability before adding element */
-	if (!iftd->he_6ghz_capa.capa)
-		return;
-
-	cap = le16_to_cpu(iftd->he_6ghz_capa.capa);
-	cap &= ~IEEE80211_HE_6GHZ_CAP_SM_PS;
-
-	switch (smps_mode) {
-	case IEEE80211_SMPS_AUTOMATIC:
-	case IEEE80211_SMPS_NUM_MODES:
-		WARN_ON(1);
-		fallthrough;
-	case IEEE80211_SMPS_OFF:
-		cap |= u16_encode_bits(WLAN_HT_CAP_SM_PS_DISABLED,
-				       IEEE80211_HE_6GHZ_CAP_SM_PS);
-		break;
-	case IEEE80211_SMPS_STATIC:
-		cap |= u16_encode_bits(WLAN_HT_CAP_SM_PS_STATIC,
-				       IEEE80211_HE_6GHZ_CAP_SM_PS);
-		break;
-	case IEEE80211_SMPS_DYNAMIC:
-		cap |= u16_encode_bits(WLAN_HT_CAP_SM_PS_DYNAMIC,
-				       IEEE80211_HE_6GHZ_CAP_SM_PS);
-		break;
-	}
-
-	pos = skb_put(skb, 2 + 1 + sizeof(cap));
-	ieee80211_write_he_6ghz_cap(pos, cpu_to_le16(cap),
-				    pos + 2 + 1 + sizeof(cap));
-}
-
-u8 *ieee80211_ie_build_ht_oper(u8 *pos, struct ieee80211_sta_ht_cap *ht_cap,
-			       const struct cfg80211_chan_def *chandef,
-			       u16 prot_mode, bool rifs_mode)
-{
-	struct ieee80211_ht_operation *ht_oper;
-	/* Build HT Information */
-	*pos++ = WLAN_EID_HT_OPERATION;
-	*pos++ = sizeof(struct ieee80211_ht_operation);
-	ht_oper = (struct ieee80211_ht_operation *)pos;
-	ht_oper->primary_chan = ieee80211_frequency_to_channel(
-					chandef->chan->center_freq);
-	switch (chandef->width) {
-	case NL80211_CHAN_WIDTH_160:
-	case NL80211_CHAN_WIDTH_80P80:
-	case NL80211_CHAN_WIDTH_80:
-	case NL80211_CHAN_WIDTH_40:
-		if (chandef->center_freq1 > chandef->chan->center_freq)
-			ht_oper->ht_param = IEEE80211_HT_PARAM_CHA_SEC_ABOVE;
-		else
-			ht_oper->ht_param = IEEE80211_HT_PARAM_CHA_SEC_BELOW;
-		break;
-	case NL80211_CHAN_WIDTH_320:
-		/* HT information element should not be included on 6GHz */
-		WARN_ON(1);
-		return pos;
-	default:
-		ht_oper->ht_param = IEEE80211_HT_PARAM_CHA_SEC_NONE;
-		break;
-	}
-	if (ht_cap->cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40 &&
-	    chandef->width != NL80211_CHAN_WIDTH_20_NOHT &&
-	    chandef->width != NL80211_CHAN_WIDTH_20)
-		ht_oper->ht_param |= IEEE80211_HT_PARAM_CHAN_WIDTH_ANY;
-
-	if (rifs_mode)
-		ht_oper->ht_param |= IEEE80211_HT_PARAM_RIFS_MODE;
-
-	ht_oper->operation_mode = cpu_to_le16(prot_mode);
-	ht_oper->stbc_param = 0x0000;
-
-	/* It seems that Basic MCS set and Supported MCS set
-	   are identical for the first 10 bytes */
-	memset(&ht_oper->basic_set, 0, 16);
-	memcpy(&ht_oper->basic_set, &ht_cap->mcs, 10);
-
-	return pos + sizeof(struct ieee80211_ht_operation);
-}
-
-void ieee80211_ie_build_wide_bw_cs(u8 *pos,
-				   const struct cfg80211_chan_def *chandef)
-{
-	*pos++ = WLAN_EID_WIDE_BW_CHANNEL_SWITCH;	/* EID */
-	*pos++ = 3;					/* IE length */
-	/* New channel width */
-	switch (chandef->width) {
-	case NL80211_CHAN_WIDTH_80:
-		*pos++ = IEEE80211_VHT_CHANWIDTH_80MHZ;
-		break;
-	case NL80211_CHAN_WIDTH_160:
-		*pos++ = IEEE80211_VHT_CHANWIDTH_160MHZ;
-		break;
-	case NL80211_CHAN_WIDTH_80P80:
-		*pos++ = IEEE80211_VHT_CHANWIDTH_80P80MHZ;
-		break;
-	case NL80211_CHAN_WIDTH_320:
-		/* The behavior is not defined for 320 MHz channels */
-		WARN_ON(1);
-		fallthrough;
-	default:
-		*pos++ = IEEE80211_VHT_CHANWIDTH_USE_HT;
-	}
-
-	/* new center frequency segment 0 */
-	*pos++ = ieee80211_frequency_to_channel(chandef->center_freq1);
-	/* new center frequency segment 1 */
-	if (chandef->center_freq2)
-		*pos++ = ieee80211_frequency_to_channel(chandef->center_freq2);
-	else
-		*pos++ = 0;
-}
-
-u8 *ieee80211_ie_build_vht_oper(u8 *pos, struct ieee80211_sta_vht_cap *vht_cap,
-				const struct cfg80211_chan_def *chandef)
-{
-	struct ieee80211_vht_operation *vht_oper;
-
-	*pos++ = WLAN_EID_VHT_OPERATION;
-	*pos++ = sizeof(struct ieee80211_vht_operation);
-	vht_oper = (struct ieee80211_vht_operation *)pos;
-	vht_oper->center_freq_seg0_idx = ieee80211_frequency_to_channel(
-							chandef->center_freq1);
-	if (chandef->center_freq2)
-		vht_oper->center_freq_seg1_idx =
-			ieee80211_frequency_to_channel(chandef->center_freq2);
-	else
-		vht_oper->center_freq_seg1_idx = 0x00;
-
-	switch (chandef->width) {
-	case NL80211_CHAN_WIDTH_160:
-		/*
-		 * Convert 160 MHz channel width to new style as interop
-		 * workaround.
-		 */
-		vht_oper->chan_width = IEEE80211_VHT_CHANWIDTH_80MHZ;
-		vht_oper->center_freq_seg1_idx = vht_oper->center_freq_seg0_idx;
-		if (chandef->chan->center_freq < chandef->center_freq1)
-			vht_oper->center_freq_seg0_idx -= 8;
-		else
-			vht_oper->center_freq_seg0_idx += 8;
-		break;
-	case NL80211_CHAN_WIDTH_80P80:
-		/*
-		 * Convert 80+80 MHz channel width to new style as interop
-		 * workaround.
-		 */
-		vht_oper->chan_width = IEEE80211_VHT_CHANWIDTH_80MHZ;
-		break;
-	case NL80211_CHAN_WIDTH_80:
-		vht_oper->chan_width = IEEE80211_VHT_CHANWIDTH_80MHZ;
-		break;
-	case NL80211_CHAN_WIDTH_320:
-		/* VHT information element should not be included on 6GHz */
-		WARN_ON(1);
-		return pos;
-	default:
-		vht_oper->chan_width = IEEE80211_VHT_CHANWIDTH_USE_HT;
-		break;
-	}
-
-	/* don't require special VHT peer rates */
-	vht_oper->basic_mcs_set = cpu_to_le16(0xffff);
-
-	return pos + sizeof(struct ieee80211_vht_operation);
-}
-
-u8 *ieee80211_ie_build_he_oper(u8 *pos, struct cfg80211_chan_def *chandef)
-{
-	struct ieee80211_he_operation *he_oper;
-	struct ieee80211_he_6ghz_oper *he_6ghz_op;
-	u32 he_oper_params;
-	u8 ie_len = 1 + sizeof(struct ieee80211_he_operation);
-
-	if (chandef->chan->band == NL80211_BAND_6GHZ)
-		ie_len += sizeof(struct ieee80211_he_6ghz_oper);
-
-	*pos++ = WLAN_EID_EXTENSION;
-	*pos++ = ie_len;
-	*pos++ = WLAN_EID_EXT_HE_OPERATION;
-
-	he_oper_params = 0;
-	he_oper_params |= u32_encode_bits(1023, /* disabled */
-				IEEE80211_HE_OPERATION_RTS_THRESHOLD_MASK);
-	he_oper_params |= u32_encode_bits(1,
-				IEEE80211_HE_OPERATION_ER_SU_DISABLE);
-	he_oper_params |= u32_encode_bits(1,
-				IEEE80211_HE_OPERATION_BSS_COLOR_DISABLED);
-	if (chandef->chan->band == NL80211_BAND_6GHZ)
-		he_oper_params |= u32_encode_bits(1,
-				IEEE80211_HE_OPERATION_6GHZ_OP_INFO);
-
-	he_oper = (struct ieee80211_he_operation *)pos;
-	he_oper->he_oper_params = cpu_to_le32(he_oper_params);
-
-	/* don't require special HE peer rates */
-	he_oper->he_mcs_nss_set = cpu_to_le16(0xffff);
-	pos += sizeof(struct ieee80211_he_operation);
-
-	if (chandef->chan->band != NL80211_BAND_6GHZ)
-		goto out;
-
-	/* TODO add VHT operational */
-	he_6ghz_op = (struct ieee80211_he_6ghz_oper *)pos;
-	he_6ghz_op->minrate = 6; /* 6 Mbps */
-	he_6ghz_op->primary =
-		ieee80211_frequency_to_channel(chandef->chan->center_freq);
-	he_6ghz_op->ccfs0 =
-		ieee80211_frequency_to_channel(chandef->center_freq1);
-	if (chandef->center_freq2)
-		he_6ghz_op->ccfs1 =
-			ieee80211_frequency_to_channel(chandef->center_freq2);
-	else
-		he_6ghz_op->ccfs1 = 0;
-
-	switch (chandef->width) {
-	case NL80211_CHAN_WIDTH_320:
-		/*
-		 * TODO: mesh operation is not defined over 6GHz 320 MHz
-		 * channels.
-		 */
-		WARN_ON(1);
-		break;
-	case NL80211_CHAN_WIDTH_160:
-		/* Convert 160 MHz channel width to new style as interop
-		 * workaround.
-		 */
-		he_6ghz_op->control =
-			IEEE80211_HE_6GHZ_OPER_CTRL_CHANWIDTH_160MHZ;
-		he_6ghz_op->ccfs1 = he_6ghz_op->ccfs0;
-		if (chandef->chan->center_freq < chandef->center_freq1)
-			he_6ghz_op->ccfs0 -= 8;
-		else
-			he_6ghz_op->ccfs0 += 8;
-		fallthrough;
-	case NL80211_CHAN_WIDTH_80P80:
-		he_6ghz_op->control =
-			IEEE80211_HE_6GHZ_OPER_CTRL_CHANWIDTH_160MHZ;
-		break;
-	case NL80211_CHAN_WIDTH_80:
-		he_6ghz_op->control =
-			IEEE80211_HE_6GHZ_OPER_CTRL_CHANWIDTH_80MHZ;
-		break;
-	case NL80211_CHAN_WIDTH_40:
-		he_6ghz_op->control =
-			IEEE80211_HE_6GHZ_OPER_CTRL_CHANWIDTH_40MHZ;
-		break;
-	default:
-		he_6ghz_op->control =
-			IEEE80211_HE_6GHZ_OPER_CTRL_CHANWIDTH_20MHZ;
-		break;
-	}
-
-	pos += sizeof(struct ieee80211_he_6ghz_oper);
-
-out:
-	return pos;
-}
-
-u8 *ieee80211_ie_build_eht_oper(u8 *pos, struct cfg80211_chan_def *chandef,
-				const struct ieee80211_sta_eht_cap *eht_cap)
-
-{
-	const struct ieee80211_eht_mcs_nss_supp_20mhz_only *eht_mcs_nss =
-					&eht_cap->eht_mcs_nss_supp.only_20mhz;
-	struct ieee80211_eht_operation *eht_oper;
-	struct ieee80211_eht_operation_info *eht_oper_info;
-	u8 eht_oper_len = offsetof(struct ieee80211_eht_operation, optional);
-	u8 eht_oper_info_len =
-		offsetof(struct ieee80211_eht_operation_info, optional);
-	u8 chan_width = 0;
-
-	*pos++ = WLAN_EID_EXTENSION;
-	*pos++ = 1 + eht_oper_len + eht_oper_info_len;
-	*pos++ = WLAN_EID_EXT_EHT_OPERATION;
-
-	eht_oper = (struct ieee80211_eht_operation *)pos;
-
-	memcpy(&eht_oper->basic_mcs_nss, eht_mcs_nss, sizeof(*eht_mcs_nss));
-	eht_oper->params |= IEEE80211_EHT_OPER_INFO_PRESENT;
-	pos += eht_oper_len;
-
-	eht_oper_info =
-		(struct ieee80211_eht_operation_info *)eht_oper->optional;
-
-	eht_oper_info->ccfs0 =
-		ieee80211_frequency_to_channel(chandef->center_freq1);
-	if (chandef->center_freq2)
-		eht_oper_info->ccfs1 =
-			ieee80211_frequency_to_channel(chandef->center_freq2);
-	else
-		eht_oper_info->ccfs1 = 0;
-
-	switch (chandef->width) {
-	case NL80211_CHAN_WIDTH_320:
-		chan_width = IEEE80211_EHT_OPER_CHAN_WIDTH_320MHZ;
-		eht_oper_info->ccfs1 = eht_oper_info->ccfs0;
-		if (chandef->chan->center_freq < chandef->center_freq1)
-			eht_oper_info->ccfs0 -= 16;
-		else
-			eht_oper_info->ccfs0 += 16;
-		break;
-	case NL80211_CHAN_WIDTH_160:
-		eht_oper_info->ccfs1 = eht_oper_info->ccfs0;
-		if (chandef->chan->center_freq < chandef->center_freq1)
-			eht_oper_info->ccfs0 -= 8;
-		else
-			eht_oper_info->ccfs0 += 8;
-		fallthrough;
-	case NL80211_CHAN_WIDTH_80P80:
-		chan_width = IEEE80211_EHT_OPER_CHAN_WIDTH_160MHZ;
-		break;
-	case NL80211_CHAN_WIDTH_80:
-		chan_width = IEEE80211_EHT_OPER_CHAN_WIDTH_80MHZ;
-		break;
-	case NL80211_CHAN_WIDTH_40:
-		chan_width = IEEE80211_EHT_OPER_CHAN_WIDTH_40MHZ;
-		break;
-	default:
-		chan_width = IEEE80211_EHT_OPER_CHAN_WIDTH_20MHZ;
-		break;
-	}
-	eht_oper_info->control = chan_width;
-	pos += eht_oper_info_len;
-
-	/* TODO: eht_oper_info->optional */
-
-	return pos;
-}
-
-bool ieee80211_chandef_ht_oper(const struct ieee80211_ht_operation *ht_oper,
-			       struct cfg80211_chan_def *chandef)
-{
-	enum nl80211_channel_type channel_type;
-
-	if (!ht_oper)
-		return false;
-
-	switch (ht_oper->ht_param & IEEE80211_HT_PARAM_CHA_SEC_OFFSET) {
-	case IEEE80211_HT_PARAM_CHA_SEC_NONE:
-		channel_type = NL80211_CHAN_HT20;
-		break;
-	case IEEE80211_HT_PARAM_CHA_SEC_ABOVE:
-		channel_type = NL80211_CHAN_HT40PLUS;
-		break;
-	case IEEE80211_HT_PARAM_CHA_SEC_BELOW:
-		channel_type = NL80211_CHAN_HT40MINUS;
-		break;
-	default:
-		return false;
-	}
-
-	cfg80211_chandef_create(chandef, chandef->chan, channel_type);
-	return true;
-}
-
-bool ieee80211_chandef_vht_oper(struct ieee80211_hw *hw, u32 vht_cap_info,
-				const struct ieee80211_vht_operation *oper,
-				const struct ieee80211_ht_operation *htop,
-				struct cfg80211_chan_def *chandef)
-{
-	struct cfg80211_chan_def new = *chandef;
-	int cf0, cf1;
-	int ccfs0, ccfs1, ccfs2;
-	int ccf0, ccf1;
-	u32 vht_cap;
-	bool support_80_80 = false;
-	bool support_160 = false;
-	u8 ext_nss_bw_supp = u32_get_bits(vht_cap_info,
-					  IEEE80211_VHT_CAP_EXT_NSS_BW_MASK);
-	u8 supp_chwidth = u32_get_bits(vht_cap_info,
-				       IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK);
-
-	if (!oper || !htop)
-		return false;
-
-	vht_cap = hw->wiphy->bands[chandef->chan->band]->vht_cap.cap;
-	support_160 = (vht_cap & (IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK |
-				  IEEE80211_VHT_CAP_EXT_NSS_BW_MASK));
-	support_80_80 = ((vht_cap &
-			 IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ) ||
-			(vht_cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ &&
-			 vht_cap & IEEE80211_VHT_CAP_EXT_NSS_BW_MASK) ||
-			((vht_cap & IEEE80211_VHT_CAP_EXT_NSS_BW_MASK) >>
-				    IEEE80211_VHT_CAP_EXT_NSS_BW_SHIFT > 1));
-	ccfs0 = oper->center_freq_seg0_idx;
-	ccfs1 = oper->center_freq_seg1_idx;
-	ccfs2 = (le16_to_cpu(htop->operation_mode) &
-				IEEE80211_HT_OP_MODE_CCFS2_MASK)
-			>> IEEE80211_HT_OP_MODE_CCFS2_SHIFT;
-
-	ccf0 = ccfs0;
-
-	/* if not supported, parse as though we didn't understand it */
-	if (!ieee80211_hw_check(hw, SUPPORTS_VHT_EXT_NSS_BW))
-		ext_nss_bw_supp = 0;
-
-	/*
-	 * Cf. IEEE 802.11 Table 9-250
-	 *
-	 * We really just consider that because it's inefficient to connect
-	 * at a higher bandwidth than we'll actually be able to use.
-	 */
-	switch ((supp_chwidth << 4) | ext_nss_bw_supp) {
-	default:
-	case 0x00:
-		ccf1 = 0;
-		support_160 = false;
-		support_80_80 = false;
-		break;
-	case 0x01:
-		support_80_80 = false;
-		fallthrough;
-	case 0x02:
-	case 0x03:
-		ccf1 = ccfs2;
-		break;
-	case 0x10:
-		ccf1 = ccfs1;
-		break;
-	case 0x11:
-	case 0x12:
-		if (!ccfs1)
-			ccf1 = ccfs2;
-		else
-			ccf1 = ccfs1;
-		break;
-	case 0x13:
-	case 0x20:
-	case 0x23:
-		ccf1 = ccfs1;
-		break;
-	}
-
-	cf0 = ieee80211_channel_to_frequency(ccf0, chandef->chan->band);
-	cf1 = ieee80211_channel_to_frequency(ccf1, chandef->chan->band);
-
-	switch (oper->chan_width) {
-	case IEEE80211_VHT_CHANWIDTH_USE_HT:
-		/* just use HT information directly */
-		break;
-	case IEEE80211_VHT_CHANWIDTH_80MHZ:
-		new.width = NL80211_CHAN_WIDTH_80;
-		new.center_freq1 = cf0;
-		/* If needed, adjust based on the newer interop workaround. */
-		if (ccf1) {
-			unsigned int diff;
-
-			diff = abs(ccf1 - ccf0);
-			if ((diff == 8) && support_160) {
-				new.width = NL80211_CHAN_WIDTH_160;
-				new.center_freq1 = cf1;
-			} else if ((diff > 8) && support_80_80) {
-				new.width = NL80211_CHAN_WIDTH_80P80;
-				new.center_freq2 = cf1;
-			}
-		}
-		break;
-	case IEEE80211_VHT_CHANWIDTH_160MHZ:
-		/* deprecated encoding */
-		new.width = NL80211_CHAN_WIDTH_160;
-		new.center_freq1 = cf0;
-		break;
-	case IEEE80211_VHT_CHANWIDTH_80P80MHZ:
-		/* deprecated encoding */
-		new.width = NL80211_CHAN_WIDTH_80P80;
-		new.center_freq1 = cf0;
-		new.center_freq2 = cf1;
-		break;
-	default:
-		return false;
-	}
-
-	if (!cfg80211_chandef_valid(&new))
-		return false;
-
-	*chandef = new;
-	return true;
-}
-
-void ieee80211_chandef_eht_oper(const struct ieee80211_eht_operation *eht_oper,
-				bool support_160, bool support_320,
-				struct cfg80211_chan_def *chandef)
-{
-	struct ieee80211_eht_operation_info *info = (void *)eht_oper->optional;
-
-	chandef->center_freq1 =
-		ieee80211_channel_to_frequency(info->ccfs0,
-					       chandef->chan->band);
-
-	switch (u8_get_bits(info->control,
-			    IEEE80211_EHT_OPER_CHAN_WIDTH)) {
-	case IEEE80211_EHT_OPER_CHAN_WIDTH_20MHZ:
-		chandef->width = NL80211_CHAN_WIDTH_20;
-		break;
-	case IEEE80211_EHT_OPER_CHAN_WIDTH_40MHZ:
-		chandef->width = NL80211_CHAN_WIDTH_40;
-		break;
-	case IEEE80211_EHT_OPER_CHAN_WIDTH_80MHZ:
-		chandef->width = NL80211_CHAN_WIDTH_80;
-		break;
-	case IEEE80211_EHT_OPER_CHAN_WIDTH_160MHZ:
-		if (support_160) {
-			chandef->width = NL80211_CHAN_WIDTH_160;
-			chandef->center_freq1 =
-				ieee80211_channel_to_frequency(info->ccfs1,
-							       chandef->chan->band);
-		} else {
-			chandef->width = NL80211_CHAN_WIDTH_80;
-		}
-		break;
-	case IEEE80211_EHT_OPER_CHAN_WIDTH_320MHZ:
-		if (support_320) {
-			chandef->width = NL80211_CHAN_WIDTH_320;
-			chandef->center_freq1 =
-				ieee80211_channel_to_frequency(info->ccfs1,
-							       chandef->chan->band);
-		} else if (support_160) {
-			chandef->width = NL80211_CHAN_WIDTH_160;
-		} else {
-			chandef->width = NL80211_CHAN_WIDTH_80;
-
-			if (chandef->center_freq1 > chandef->chan->center_freq)
-				chandef->center_freq1 -= 40;
-			else
-				chandef->center_freq1 += 40;
-		}
-		break;
-	}
-}
-
-bool ieee80211_chandef_he_6ghz_oper(struct ieee80211_sub_if_data *sdata,
-				    const struct ieee80211_he_operation *he_oper,
-				    const struct ieee80211_eht_operation *eht_oper,
-				    struct cfg80211_chan_def *chandef)
-{
-	struct ieee80211_local *local = sdata->local;
-	struct ieee80211_supported_band *sband;
-	enum nl80211_iftype iftype = ieee80211_vif_type_p2p(&sdata->vif);
-	const struct ieee80211_sta_he_cap *he_cap;
-	const struct ieee80211_sta_eht_cap *eht_cap;
-	struct cfg80211_chan_def he_chandef = *chandef;
-	const struct ieee80211_he_6ghz_oper *he_6ghz_oper;
-	struct ieee80211_bss_conf *bss_conf = &sdata->vif.bss_conf;
-	bool support_80_80, support_160, support_320;
-	u8 he_phy_cap, eht_phy_cap;
-	u32 freq;
-
-	if (chandef->chan->band != NL80211_BAND_6GHZ)
-		return true;
-
-	sband = local->hw.wiphy->bands[NL80211_BAND_6GHZ];
-
-	he_cap = ieee80211_get_he_iftype_cap(sband, iftype);
-	if (!he_cap) {
-		sdata_info(sdata, "Missing iftype sband data/HE cap");
-		return false;
-	}
-
-	he_phy_cap = he_cap->he_cap_elem.phy_cap_info[0];
-	support_160 =
-		he_phy_cap &
-		IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G;
-	support_80_80 =
-		he_phy_cap &
-		IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G;
-
-	if (!he_oper) {
-		sdata_info(sdata,
-			   "HE is not advertised on (on %d MHz), expect issues\n",
-			   chandef->chan->center_freq);
-		return false;
-	}
-
-	eht_cap = ieee80211_get_eht_iftype_cap(sband, iftype);
-	if (!eht_cap)
-		eht_oper = NULL;
-
-	he_6ghz_oper = ieee80211_he_6ghz_oper(he_oper);
-
-	if (!he_6ghz_oper) {
-		sdata_info(sdata,
-			   "HE 6GHz operation missing (on %d MHz), expect issues\n",
-			   chandef->chan->center_freq);
-		return false;
-	}
-
-	/*
-	 * The EHT operation IE does not contain the primary channel so the
-	 * primary channel frequency should be taken from the 6 GHz operation
-	 * information.
-	 */
-	freq = ieee80211_channel_to_frequency(he_6ghz_oper->primary,
-					      NL80211_BAND_6GHZ);
-	he_chandef.chan = ieee80211_get_channel(sdata->local->hw.wiphy, freq);
-
-	switch (u8_get_bits(he_6ghz_oper->control,
-			    IEEE80211_HE_6GHZ_OPER_CTRL_REG_INFO)) {
-	case IEEE80211_6GHZ_CTRL_REG_LPI_AP:
-		bss_conf->power_type = IEEE80211_REG_LPI_AP;
-		break;
-	case IEEE80211_6GHZ_CTRL_REG_SP_AP:
-		bss_conf->power_type = IEEE80211_REG_SP_AP;
-		break;
-	default:
-		bss_conf->power_type = IEEE80211_REG_UNSET_AP;
-		break;
-	}
-
-	if (!eht_oper ||
-	    !(eht_oper->params & IEEE80211_EHT_OPER_INFO_PRESENT)) {
-		switch (u8_get_bits(he_6ghz_oper->control,
-				    IEEE80211_HE_6GHZ_OPER_CTRL_CHANWIDTH)) {
-		case IEEE80211_HE_6GHZ_OPER_CTRL_CHANWIDTH_20MHZ:
-			he_chandef.width = NL80211_CHAN_WIDTH_20;
-			break;
-		case IEEE80211_HE_6GHZ_OPER_CTRL_CHANWIDTH_40MHZ:
-			he_chandef.width = NL80211_CHAN_WIDTH_40;
-			break;
-		case IEEE80211_HE_6GHZ_OPER_CTRL_CHANWIDTH_80MHZ:
-			he_chandef.width = NL80211_CHAN_WIDTH_80;
-			break;
-		case IEEE80211_HE_6GHZ_OPER_CTRL_CHANWIDTH_160MHZ:
-			he_chandef.width = NL80211_CHAN_WIDTH_80;
-			if (!he_6ghz_oper->ccfs1)
-				break;
-			if (abs(he_6ghz_oper->ccfs1 - he_6ghz_oper->ccfs0) == 8) {
-				if (support_160)
-					he_chandef.width = NL80211_CHAN_WIDTH_160;
-			} else {
-				if (support_80_80)
-					he_chandef.width = NL80211_CHAN_WIDTH_80P80;
-			}
-			break;
-		}
-
-		if (he_chandef.width == NL80211_CHAN_WIDTH_160) {
-			he_chandef.center_freq1 =
-				ieee80211_channel_to_frequency(he_6ghz_oper->ccfs1,
-							       NL80211_BAND_6GHZ);
-		} else {
-			he_chandef.center_freq1 =
-				ieee80211_channel_to_frequency(he_6ghz_oper->ccfs0,
-							       NL80211_BAND_6GHZ);
-			if (support_80_80 || support_160)
-				he_chandef.center_freq2 =
-					ieee80211_channel_to_frequency(he_6ghz_oper->ccfs1,
-								       NL80211_BAND_6GHZ);
-		}
-	} else {
-		eht_phy_cap = eht_cap->eht_cap_elem.phy_cap_info[0];
-		support_320 =
-			eht_phy_cap & IEEE80211_EHT_PHY_CAP0_320MHZ_IN_6GHZ;
-
-		ieee80211_chandef_eht_oper(eht_oper, support_160,
-					   support_320, &he_chandef);
-	}
-
-	if (!cfg80211_chandef_valid(&he_chandef)) {
-		sdata_info(sdata,
-			   "HE 6GHz operation resulted in invalid chandef: %d MHz/%d/%d MHz/%d MHz\n",
-			   he_chandef.chan ? he_chandef.chan->center_freq : 0,
-			   he_chandef.width,
-			   he_chandef.center_freq1,
-			   he_chandef.center_freq2);
-		return false;
-	}
-
-	*chandef = he_chandef;
-
-	return true;
-}
-
-bool ieee80211_chandef_s1g_oper(const struct ieee80211_s1g_oper_ie *oper,
-				struct cfg80211_chan_def *chandef)
-{
-	u32 oper_freq;
-
-	if (!oper)
-		return false;
-
-	switch (FIELD_GET(S1G_OPER_CH_WIDTH_OPER, oper->ch_width)) {
-	case IEEE80211_S1G_CHANWIDTH_1MHZ:
-		chandef->width = NL80211_CHAN_WIDTH_1;
-		break;
-	case IEEE80211_S1G_CHANWIDTH_2MHZ:
-		chandef->width = NL80211_CHAN_WIDTH_2;
-		break;
-	case IEEE80211_S1G_CHANWIDTH_4MHZ:
-		chandef->width = NL80211_CHAN_WIDTH_4;
-		break;
-	case IEEE80211_S1G_CHANWIDTH_8MHZ:
-		chandef->width = NL80211_CHAN_WIDTH_8;
-		break;
-	case IEEE80211_S1G_CHANWIDTH_16MHZ:
-		chandef->width = NL80211_CHAN_WIDTH_16;
-		break;
-	default:
-		return false;
-	}
-
-	oper_freq = ieee80211_channel_to_freq_khz(oper->oper_ch,
-						  NL80211_BAND_S1GHZ);
-	chandef->center_freq1 = KHZ_TO_MHZ(oper_freq);
-	chandef->freq1_offset = oper_freq % 1000;
-
-	return true;
-}
-
-int ieee80211_parse_bitrates(enum nl80211_chan_width width,
-			     const struct ieee80211_supported_band *sband,
-			     const u8 *srates, int srates_len, u32 *rates)
-{
-	u32 rate_flags = ieee80211_chanwidth_rate_flags(width);
-	int shift = ieee80211_chanwidth_get_shift(width);
-	struct ieee80211_rate *br;
-	int brate, rate, i, j, count = 0;
-
-	*rates = 0;
-
-	for (i = 0; i < srates_len; i++) {
-		rate = srates[i] & 0x7f;
-
-		for (j = 0; j < sband->n_bitrates; j++) {
-			br = &sband->bitrates[j];
-			if ((rate_flags & br->flags) != rate_flags)
-				continue;
-
-			brate = DIV_ROUND_UP(br->bitrate, (1 << shift) * 5);
-			if (brate == rate) {
-				*rates |= BIT(j);
-				count++;
-				break;
-			}
-		}
-	}
-	return count;
-}
-
-int ieee80211_add_srates_ie(struct ieee80211_sub_if_data *sdata,
-			    struct sk_buff *skb, bool need_basic,
-			    enum nl80211_band band)
-{
-	struct ieee80211_local *local = sdata->local;
-	struct ieee80211_supported_band *sband;
-	int rate, shift;
-	u8 i, rates, *pos;
-	u32 basic_rates = sdata->vif.bss_conf.basic_rates;
-	u32 rate_flags;
-
-	shift = ieee80211_vif_get_shift(&sdata->vif);
-	rate_flags = ieee80211_chandef_rate_flags(&sdata->vif.bss_conf.chandef);
-	sband = local->hw.wiphy->bands[band];
-	rates = 0;
-	for (i = 0; i < sband->n_bitrates; i++) {
-		if ((rate_flags & sband->bitrates[i].flags) != rate_flags)
-			continue;
-		rates++;
-	}
-	if (rates > 8)
-		rates = 8;
-
-	if (skb_tailroom(skb) < rates + 2)
-		return -ENOMEM;
-
-	pos = skb_put(skb, rates + 2);
-	*pos++ = WLAN_EID_SUPP_RATES;
-	*pos++ = rates;
-	for (i = 0; i < rates; i++) {
-		u8 basic = 0;
-		if ((rate_flags & sband->bitrates[i].flags) != rate_flags)
-			continue;
-
-		if (need_basic && basic_rates & BIT(i))
-			basic = 0x80;
-		rate = DIV_ROUND_UP(sband->bitrates[i].bitrate,
-				    5 * (1 << shift));
-		*pos++ = basic | (u8) rate;
-	}
-
-	return 0;
-}
-
-int ieee80211_add_ext_srates_ie(struct ieee80211_sub_if_data *sdata,
-				struct sk_buff *skb, bool need_basic,
-				enum nl80211_band band)
-{
-	struct ieee80211_local *local = sdata->local;
-	struct ieee80211_supported_band *sband;
-	int rate, shift;
-	u8 i, exrates, *pos;
-	u32 basic_rates = sdata->vif.bss_conf.basic_rates;
-	u32 rate_flags;
-
-	rate_flags = ieee80211_chandef_rate_flags(&sdata->vif.bss_conf.chandef);
-	shift = ieee80211_vif_get_shift(&sdata->vif);
-
-	sband = local->hw.wiphy->bands[band];
-	exrates = 0;
-	for (i = 0; i < sband->n_bitrates; i++) {
-		if ((rate_flags & sband->bitrates[i].flags) != rate_flags)
-			continue;
-		exrates++;
-	}
-
-	if (exrates > 8)
-		exrates -= 8;
-	else
-		exrates = 0;
-
-	if (skb_tailroom(skb) < exrates + 2)
-		return -ENOMEM;
-
-	if (exrates) {
-		pos = skb_put(skb, exrates + 2);
-		*pos++ = WLAN_EID_EXT_SUPP_RATES;
-		*pos++ = exrates;
-		for (i = 8; i < sband->n_bitrates; i++) {
-			u8 basic = 0;
-			if ((rate_flags & sband->bitrates[i].flags)
-			    != rate_flags)
-				continue;
-			if (need_basic && basic_rates & BIT(i))
-				basic = 0x80;
-			rate = DIV_ROUND_UP(sband->bitrates[i].bitrate,
-					    5 * (1 << shift));
-			*pos++ = basic | (u8) rate;
-		}
-	}
-	return 0;
-}
-
-int ieee80211_ave_rssi(struct ieee80211_vif *vif)
-{
-	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
-
-	if (WARN_ON_ONCE(sdata->vif.type != NL80211_IFTYPE_STATION))
-		return 0;
-
-	return -ewma_beacon_signal_read(&sdata->deflink.u.mgd.ave_beacon_signal);
-}
-EXPORT_SYMBOL_GPL(ieee80211_ave_rssi);
-
-u8 ieee80211_mcs_to_chains(const struct ieee80211_mcs_info *mcs)
-{
-	if (!mcs)
-		return 1;
-
-	/* TODO: consider rx_highest */
-
-	if (mcs->rx_mask[3])
-		return 4;
-	if (mcs->rx_mask[2])
-		return 3;
-	if (mcs->rx_mask[1])
-		return 2;
-	return 1;
-}
-
-/**
- * ieee80211_calculate_rx_timestamp - calculate timestamp in frame
- * @local: mac80211 hw info struct
- * @status: RX status
- * @mpdu_len: total MPDU length (including FCS)
- * @mpdu_offset: offset into MPDU to calculate timestamp at
- *
- * This function calculates the RX timestamp at the given MPDU offset, taking
- * into account what the RX timestamp was. An offset of 0 will just normalize
- * the timestamp to TSF at beginning of MPDU reception.
- */
-u64 ieee80211_calculate_rx_timestamp(struct ieee80211_local *local,
-				     struct ieee80211_rx_status *status,
-				     unsigned int mpdu_len,
-				     unsigned int mpdu_offset)
-{
-	u64 ts = status->mactime;
-	struct rate_info ri;
-	u16 rate;
-	u8 n_ltf;
-
-	if (WARN_ON(!ieee80211_have_rx_timestamp(status)))
-		return 0;
-
-	memset(&ri, 0, sizeof(ri));
-
-	ri.bw = status->bw;
-
-	/* Fill cfg80211 rate info */
-	switch (status->encoding) {
-	case RX_ENC_EHT:
-		ri.flags |= RATE_INFO_FLAGS_EHT_MCS;
-		ri.mcs = status->rate_idx;
-		ri.nss = status->nss;
-		ri.eht_ru_alloc = status->eht.ru;
-		if (status->enc_flags & RX_ENC_FLAG_SHORT_GI)
-			ri.flags |= RATE_INFO_FLAGS_SHORT_GI;
-		/* TODO/FIXME: is this right? handle other PPDUs */
-		if (status->flag & RX_FLAG_MACTIME_PLCP_START) {
-			mpdu_offset += 2;
-			ts += 36;
-		}
-		break;
-	case RX_ENC_HE:
-		ri.flags |= RATE_INFO_FLAGS_HE_MCS;
-		ri.mcs = status->rate_idx;
-		ri.nss = status->nss;
-		ri.he_ru_alloc = status->he_ru;
-		if (status->enc_flags & RX_ENC_FLAG_SHORT_GI)
-			ri.flags |= RATE_INFO_FLAGS_SHORT_GI;
-
-		/*
-		 * See P802.11ax_D6.0, section 27.3.4 for
-		 * VHT PPDU format.
-		 */
-		if (status->flag & RX_FLAG_MACTIME_PLCP_START) {
-			mpdu_offset += 2;
-			ts += 36;
-
-			/*
-			 * TODO:
-			 * For HE MU PPDU, add the HE-SIG-B.
-			 * For HE ER PPDU, add 8us for the HE-SIG-A.
-			 * For HE TB PPDU, add 4us for the HE-STF.
-			 * Add the HE-LTF durations - variable.
-			 */
-		}
-
-		break;
-	case RX_ENC_HT:
-		ri.mcs = status->rate_idx;
-		ri.flags |= RATE_INFO_FLAGS_MCS;
-		if (status->enc_flags & RX_ENC_FLAG_SHORT_GI)
-			ri.flags |= RATE_INFO_FLAGS_SHORT_GI;
-
-		/*
-		 * See P802.11REVmd_D3.0, section 19.3.2 for
-		 * HT PPDU format.
-		 */
-		if (status->flag & RX_FLAG_MACTIME_PLCP_START) {
-			mpdu_offset += 2;
-			if (status->enc_flags & RX_ENC_FLAG_HT_GF)
-				ts += 24;
-			else
-				ts += 32;
-
-			/*
-			 * Add Data HT-LTFs per streams
-			 * TODO: add Extension HT-LTFs, 4us per LTF
-			 */
-			n_ltf = ((ri.mcs >> 3) & 3) + 1;
-			n_ltf = n_ltf == 3 ? 4 : n_ltf;
-			ts += n_ltf * 4;
-		}
-
-		break;
-	case RX_ENC_VHT:
-		ri.flags |= RATE_INFO_FLAGS_VHT_MCS;
-		ri.mcs = status->rate_idx;
-		ri.nss = status->nss;
-		if (status->enc_flags & RX_ENC_FLAG_SHORT_GI)
-			ri.flags |= RATE_INFO_FLAGS_SHORT_GI;
-
-		/*
-		 * See P802.11REVmd_D3.0, section 21.3.2 for
-		 * VHT PPDU format.
-		 */
-		if (status->flag & RX_FLAG_MACTIME_PLCP_START) {
-			mpdu_offset += 2;
-			ts += 36;
-
-			/*
-			 * Add VHT-LTFs per streams
-			 */
-			n_ltf = (ri.nss != 1) && (ri.nss % 2) ?
-				ri.nss + 1 : ri.nss;
-			ts += 4 * n_ltf;
-		}
-
-		break;
-	default:
-		WARN_ON(1);
-		fallthrough;
-	case RX_ENC_LEGACY: {
-		struct ieee80211_supported_band *sband;
-		int shift = 0;
-		int bitrate;
-
-		switch (status->bw) {
-		case RATE_INFO_BW_10:
-			shift = 1;
-			break;
-		case RATE_INFO_BW_5:
-			shift = 2;
-			break;
-		}
-
-		sband = local->hw.wiphy->bands[status->band];
-		bitrate = sband->bitrates[status->rate_idx].bitrate;
-		ri.legacy = DIV_ROUND_UP(bitrate, (1 << shift));
-
-		if (status->flag & RX_FLAG_MACTIME_PLCP_START) {
-			if (status->band == NL80211_BAND_5GHZ) {
-				ts += 20 << shift;
-				mpdu_offset += 2;
-			} else if (status->enc_flags & RX_ENC_FLAG_SHORTPRE) {
-				ts += 96;
-			} else {
-				ts += 192;
-			}
-		}
-		break;
-		}
-	}
-
-	rate = cfg80211_calculate_bitrate(&ri);
-	if (WARN_ONCE(!rate,
-		      "Invalid bitrate: flags=0x%llx, idx=%d, vht_nss=%d\n",
-		      (unsigned long long)status->flag, status->rate_idx,
-		      status->nss))
-		return 0;
-
-	/* rewind from end of MPDU */
-	if (status->flag & RX_FLAG_MACTIME_END)
-		ts -= mpdu_len * 8 * 10 / rate;
-
-	ts += mpdu_offset * 8 * 10 / rate;
-
-	return ts;
-}
-
-void ieee80211_dfs_cac_cancel(struct ieee80211_local *local)
-{
-	struct ieee80211_sub_if_data *sdata;
-	struct cfg80211_chan_def chandef;
-
-	/* for interface list, to avoid linking iflist_mtx and chanctx_mtx */
-	lockdep_assert_wiphy(local->hw.wiphy);
-
-	mutex_lock(&local->mtx);
-	list_for_each_entry(sdata, &local->interfaces, list) {
-		/* it might be waiting for the local->mtx, but then
-		 * by the time it gets it, sdata->wdev.cac_started
-		 * will no longer be true
-		 */
-		cancel_delayed_work(&sdata->deflink.dfs_cac_timer_work);
-
-		if (sdata->wdev.cac_started) {
-			chandef = sdata->vif.bss_conf.chandef;
-			ieee80211_link_release_channel(&sdata->deflink);
-			cfg80211_cac_event(sdata->dev,
-					   &chandef,
-					   NL80211_RADAR_CAC_ABORTED,
-					   GFP_KERNEL);
-		}
-	}
-	mutex_unlock(&local->mtx);
-}
-
-void ieee80211_dfs_radar_detected_work(struct wiphy *wiphy,
-				       struct wiphy_work *work)
-{
-	struct ieee80211_local *local =
-		container_of(work, struct ieee80211_local, radar_detected_work);
-	struct cfg80211_chan_def chandef = local->hw.conf.chandef;
-	struct ieee80211_chanctx *ctx;
-	int num_chanctx = 0;
-
-	mutex_lock(&local->chanctx_mtx);
-	list_for_each_entry(ctx, &local->chanctx_list, list) {
-		if (ctx->replace_state == IEEE80211_CHANCTX_REPLACES_OTHER)
-			continue;
-
-		num_chanctx++;
-		chandef = ctx->conf.def;
-	}
-	mutex_unlock(&local->chanctx_mtx);
-
-	ieee80211_dfs_cac_cancel(local);
-
-	if (num_chanctx > 1)
-		/* XXX: multi-channel is not supported yet */
-		WARN_ON(1);
-	else
-		cfg80211_radar_event(local->hw.wiphy, &chandef, GFP_KERNEL);
-}
-
-void ieee80211_radar_detected(struct ieee80211_hw *hw)
-{
-	struct ieee80211_local *local = hw_to_local(hw);
-
-	trace_api_radar_detected(local);
-
-	wiphy_work_queue(hw->wiphy, &local->radar_detected_work);
-}
-EXPORT_SYMBOL(ieee80211_radar_detected);
-
-ieee80211_conn_flags_t ieee80211_chandef_downgrade(struct cfg80211_chan_def *c)
-{
-	ieee80211_conn_flags_t ret;
-	int tmp;
-
-	switch (c->width) {
-	case NL80211_CHAN_WIDTH_20:
-		c->width = NL80211_CHAN_WIDTH_20_NOHT;
-		ret = IEEE80211_CONN_DISABLE_HT | IEEE80211_CONN_DISABLE_VHT;
-		break;
-	case NL80211_CHAN_WIDTH_40:
-		c->width = NL80211_CHAN_WIDTH_20;
-		c->center_freq1 = c->chan->center_freq;
-		ret = IEEE80211_CONN_DISABLE_40MHZ |
-		      IEEE80211_CONN_DISABLE_VHT;
-		break;
-	case NL80211_CHAN_WIDTH_80:
-		tmp = (30 + c->chan->center_freq - c->center_freq1)/20;
-		/* n_P40 */
-		tmp /= 2;
-		/* freq_P40 */
-		c->center_freq1 = c->center_freq1 - 20 + 40 * tmp;
-		c->width = NL80211_CHAN_WIDTH_40;
-		ret = IEEE80211_CONN_DISABLE_VHT;
-		break;
-	case NL80211_CHAN_WIDTH_80P80:
-		c->center_freq2 = 0;
-		c->width = NL80211_CHAN_WIDTH_80;
-		ret = IEEE80211_CONN_DISABLE_80P80MHZ |
-		      IEEE80211_CONN_DISABLE_160MHZ;
-		break;
-	case NL80211_CHAN_WIDTH_160:
-		/* n_P20 */
-		tmp = (70 + c->chan->center_freq - c->center_freq1)/20;
-		/* n_P80 */
-		tmp /= 4;
-		c->center_freq1 = c->center_freq1 - 40 + 80 * tmp;
-		c->width = NL80211_CHAN_WIDTH_80;
-		ret = IEEE80211_CONN_DISABLE_80P80MHZ |
-		      IEEE80211_CONN_DISABLE_160MHZ;
-		break;
-	case NL80211_CHAN_WIDTH_320:
-		/* n_P20 */
-		tmp = (150 + c->chan->center_freq - c->center_freq1) / 20;
-		/* n_P160 */
-		tmp /= 8;
-		c->center_freq1 = c->center_freq1 - 80 + 160 * tmp;
-		c->width = NL80211_CHAN_WIDTH_160;
-		ret = IEEE80211_CONN_DISABLE_320MHZ;
-		break;
-	default:
-	case NL80211_CHAN_WIDTH_20_NOHT:
-		WARN_ON_ONCE(1);
-		c->width = NL80211_CHAN_WIDTH_20_NOHT;
-		ret = IEEE80211_CONN_DISABLE_HT | IEEE80211_CONN_DISABLE_VHT;
-		break;
-	case NL80211_CHAN_WIDTH_1:
-	case NL80211_CHAN_WIDTH_2:
-	case NL80211_CHAN_WIDTH_4:
-	case NL80211_CHAN_WIDTH_8:
-	case NL80211_CHAN_WIDTH_16:
-	case NL80211_CHAN_WIDTH_5:
-	case NL80211_CHAN_WIDTH_10:
-		WARN_ON_ONCE(1);
-		/* keep c->width */
-		ret = IEEE80211_CONN_DISABLE_HT | IEEE80211_CONN_DISABLE_VHT;
-		break;
-	}
-
-	WARN_ON_ONCE(!cfg80211_chandef_valid(c));
-
-	return ret;
-}
-
-/*
- * Returns true if smps_mode_new is strictly more restrictive than
- * smps_mode_old.
- */
-bool ieee80211_smps_is_restrictive(enum ieee80211_smps_mode smps_mode_old,
-				   enum ieee80211_smps_mode smps_mode_new)
-{
-	if (WARN_ON_ONCE(smps_mode_old == IEEE80211_SMPS_AUTOMATIC ||
-			 smps_mode_new == IEEE80211_SMPS_AUTOMATIC))
-		return false;
-
-	switch (smps_mode_old) {
-	case IEEE80211_SMPS_STATIC:
-		return false;
-	case IEEE80211_SMPS_DYNAMIC:
-		return smps_mode_new == IEEE80211_SMPS_STATIC;
-	case IEEE80211_SMPS_OFF:
-		return smps_mode_new != IEEE80211_SMPS_OFF;
-	default:
-		WARN_ON(1);
-	}
-
-	return false;
-}
-
-int ieee80211_send_action_csa(struct ieee80211_sub_if_data *sdata,
-			      struct cfg80211_csa_settings *csa_settings)
-{
-	struct sk_buff *skb;
-	struct ieee80211_mgmt *mgmt;
-	struct ieee80211_local *local = sdata->local;
-	int freq;
-	int hdr_len = offsetofend(struct ieee80211_mgmt,
-				  u.action.u.chan_switch);
-	u8 *pos;
-
-	if (sdata->vif.type != NL80211_IFTYPE_ADHOC &&
-	    sdata->vif.type != NL80211_IFTYPE_MESH_POINT)
-		return -EOPNOTSUPP;
-
-	skb = dev_alloc_skb(local->tx_headroom + hdr_len +
-			    5 + /* channel switch announcement element */
-			    3 + /* secondary channel offset element */
-			    5 + /* wide bandwidth channel switch announcement */
-			    8); /* mesh channel switch parameters element */
-	if (!skb)
-		return -ENOMEM;
-
-	skb_reserve(skb, local->tx_headroom);
-	mgmt = skb_put_zero(skb, hdr_len);
-	mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
-					  IEEE80211_STYPE_ACTION);
-
-	eth_broadcast_addr(mgmt->da);
-	memcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);
-	if (ieee80211_vif_is_mesh(&sdata->vif)) {
-		memcpy(mgmt->bssid, sdata->vif.addr, ETH_ALEN);
-	} else {
-		struct ieee80211_if_ibss *ifibss = &sdata->u.ibss;
-		memcpy(mgmt->bssid, ifibss->bssid, ETH_ALEN);
-	}
-	mgmt->u.action.category = WLAN_CATEGORY_SPECTRUM_MGMT;
-	mgmt->u.action.u.chan_switch.action_code = WLAN_ACTION_SPCT_CHL_SWITCH;
-	pos = skb_put(skb, 5);
-	*pos++ = WLAN_EID_CHANNEL_SWITCH;			/* EID */
-	*pos++ = 3;						/* IE length */
-	*pos++ = csa_settings->block_tx ? 1 : 0;		/* CSA mode */
-	freq = csa_settings->chandef.chan->center_freq;
-	*pos++ = ieee80211_frequency_to_channel(freq);		/* channel */
-	*pos++ = csa_settings->count;				/* count */
-
-	if (csa_settings->chandef.width == NL80211_CHAN_WIDTH_40) {
-		enum nl80211_channel_type ch_type;
-
-		skb_put(skb, 3);
-		*pos++ = WLAN_EID_SECONDARY_CHANNEL_OFFSET;	/* EID */
-		*pos++ = 1;					/* IE length */
-		ch_type = cfg80211_get_chandef_type(&csa_settings->chandef);
-		if (ch_type == NL80211_CHAN_HT40PLUS)
-			*pos++ = IEEE80211_HT_PARAM_CHA_SEC_ABOVE;
-		else
-			*pos++ = IEEE80211_HT_PARAM_CHA_SEC_BELOW;
-	}
-
-	if (ieee80211_vif_is_mesh(&sdata->vif)) {
-		struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
-
-		skb_put(skb, 8);
-		*pos++ = WLAN_EID_CHAN_SWITCH_PARAM;		/* EID */
-		*pos++ = 6;					/* IE length */
-		*pos++ = sdata->u.mesh.mshcfg.dot11MeshTTL;	/* Mesh TTL */
-		*pos = 0x00;	/* Mesh Flag: Tx Restrict, Initiator, Reason */
-		*pos |= WLAN_EID_CHAN_SWITCH_PARAM_INITIATOR;
-		*pos++ |= csa_settings->block_tx ?
-			  WLAN_EID_CHAN_SWITCH_PARAM_TX_RESTRICT : 0x00;
-		put_unaligned_le16(WLAN_REASON_MESH_CHAN, pos); /* Reason Cd */
-		pos += 2;
-		put_unaligned_le16(ifmsh->pre_value, pos);/* Precedence Value */
-		pos += 2;
-	}
-
-	if (csa_settings->chandef.width == NL80211_CHAN_WIDTH_80 ||
-	    csa_settings->chandef.width == NL80211_CHAN_WIDTH_80P80 ||
-	    csa_settings->chandef.width == NL80211_CHAN_WIDTH_160) {
-		skb_put(skb, 5);
-		ieee80211_ie_build_wide_bw_cs(pos, &csa_settings->chandef);
-	}
-
-	ieee80211_tx_skb(sdata, skb);
-	return 0;
-}
-
-static bool
-ieee80211_extend_noa_desc(struct ieee80211_noa_data *data, u32 tsf, int i)
-{
-	s32 end = data->desc[i].start + data->desc[i].duration - (tsf + 1);
-	int skip;
-
-	if (end > 0)
-		return false;
-
-	/* One shot NOA  */
-	if (data->count[i] == 1)
-		return false;
-
-	if (data->desc[i].interval == 0)
-		return false;
-
-	/* End time is in the past, check for repetitions */
-	skip = DIV_ROUND_UP(-end, data->desc[i].interval);
-	if (data->count[i] < 255) {
-		if (data->count[i] <= skip) {
-			data->count[i] = 0;
-			return false;
-		}
-
-		data->count[i] -= skip;
-	}
-
-	data->desc[i].start += skip * data->desc[i].interval;
-
-	return true;
-}
-
-static bool
-ieee80211_extend_absent_time(struct ieee80211_noa_data *data, u32 tsf,
-			     s32 *offset)
-{
-	bool ret = false;
-	int i;
-
-	for (i = 0; i < IEEE80211_P2P_NOA_DESC_MAX; i++) {
-		s32 cur;
-
-		if (!data->count[i])
-			continue;
-
-		if (ieee80211_extend_noa_desc(data, tsf + *offset, i))
-			ret = true;
-
-		cur = data->desc[i].start - tsf;
-		if (cur > *offset)
-			continue;
-
-		cur = data->desc[i].start + data->desc[i].duration - tsf;
-		if (cur > *offset)
-			*offset = cur;
-	}
-
-	return ret;
-}
-
-static u32
-ieee80211_get_noa_absent_time(struct ieee80211_noa_data *data, u32 tsf)
-{
-	s32 offset = 0;
-	int tries = 0;
-	/*
-	 * arbitrary limit, used to avoid infinite loops when combined NoA
-	 * descriptors cover the full time period.
-	 */
-	int max_tries = 5;
-
-	ieee80211_extend_absent_time(data, tsf, &offset);
-	do {
-		if (!ieee80211_extend_absent_time(data, tsf, &offset))
-			break;
-
-		tries++;
-	} while (tries < max_tries);
-
-	return offset;
-}
-
-void ieee80211_update_p2p_noa(struct ieee80211_noa_data *data, u32 tsf)
-{
-	u32 next_offset = BIT(31) - 1;
-	int i;
-
-	data->absent = 0;
-	data->has_next_tsf = false;
-	for (i = 0; i < IEEE80211_P2P_NOA_DESC_MAX; i++) {
-		s32 start;
-
-		if (!data->count[i])
-			continue;
-
-		ieee80211_extend_noa_desc(data, tsf, i);
-		start = data->desc[i].start - tsf;
-		if (start <= 0)
-			data->absent |= BIT(i);
-
-		if (next_offset > start)
-			next_offset = start;
-
-		data->has_next_tsf = true;
-	}
-
-	if (data->absent)
-		next_offset = ieee80211_get_noa_absent_time(data, tsf);
-
-	data->next_tsf = tsf + next_offset;
-}
-EXPORT_SYMBOL(ieee80211_update_p2p_noa);
-
-int ieee80211_parse_p2p_noa(const struct ieee80211_p2p_noa_attr *attr,
-			    struct ieee80211_noa_data *data, u32 tsf)
-{
-	int ret = 0;
-	int i;
-
-	memset(data, 0, sizeof(*data));
-
-	for (i = 0; i < IEEE80211_P2P_NOA_DESC_MAX; i++) {
-		const struct ieee80211_p2p_noa_desc *desc = &attr->desc[i];
-
-		if (!desc->count || !desc->duration)
-			continue;
-
-		data->count[i] = desc->count;
-		data->desc[i].start = le32_to_cpu(desc->start_time);
-		data->desc[i].duration = le32_to_cpu(desc->duration);
-		data->desc[i].interval = le32_to_cpu(desc->interval);
-
-		if (data->count[i] > 1 &&
-		    data->desc[i].interval < data->desc[i].duration)
-			continue;
-
-		ieee80211_extend_noa_desc(data, tsf, i);
-		ret++;
-	}
-
-	if (ret)
-		ieee80211_update_p2p_noa(data, tsf);
-
-	return ret;
-}
-EXPORT_SYMBOL(ieee80211_parse_p2p_noa);
-
-void ieee80211_recalc_dtim(struct ieee80211_local *local,
-			   struct ieee80211_sub_if_data *sdata)
-{
-	u64 tsf = drv_get_tsf(local, sdata);
-	u64 dtim_count = 0;
-	u16 beacon_int = sdata->vif.bss_conf.beacon_int * 1024;
-	u8 dtim_period = sdata->vif.bss_conf.dtim_period;
-	struct ps_data *ps;
-	u8 bcns_from_dtim;
-
-	if (tsf == -1ULL || !beacon_int || !dtim_period)
-		return;
-
-	if (sdata->vif.type == NL80211_IFTYPE_AP ||
-	    sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {
-		if (!sdata->bss)
-			return;
-
-		ps = &sdata->bss->ps;
-	} else if (ieee80211_vif_is_mesh(&sdata->vif)) {
-		ps = &sdata->u.mesh.ps;
-	} else {
-		return;
-	}
-
-	/*
-	 * actually finds last dtim_count, mac80211 will update in
-	 * __beacon_add_tim().
-	 * dtim_count = dtim_period - (tsf / bcn_int) % dtim_period
-	 */
-	do_div(tsf, beacon_int);
-	bcns_from_dtim = do_div(tsf, dtim_period);
-	/* just had a DTIM */
-	if (!bcns_from_dtim)
-		dtim_count = 0;
-	else
-		dtim_count = dtim_period - bcns_from_dtim;
-
-	ps->dtim_count = dtim_count;
-}
-
-static u8 ieee80211_chanctx_radar_detect(struct ieee80211_local *local,
-					 struct ieee80211_chanctx *ctx)
-{
-	struct ieee80211_link_data *link;
-	u8 radar_detect = 0;
-
-	lockdep_assert_held(&local->chanctx_mtx);
-
-	if (WARN_ON(ctx->replace_state == IEEE80211_CHANCTX_WILL_BE_REPLACED))
-		return 0;
-
-	list_for_each_entry(link, &ctx->reserved_links, reserved_chanctx_list)
-		if (link->reserved_radar_required)
-			radar_detect |= BIT(link->reserved_chandef.width);
-
-	/*
-	 * An in-place reservation context should not have any assigned vifs
-	 * until it replaces the other context.
-	 */
-	WARN_ON(ctx->replace_state == IEEE80211_CHANCTX_REPLACES_OTHER &&
-		!list_empty(&ctx->assigned_links));
-
-	list_for_each_entry(link, &ctx->assigned_links, assigned_chanctx_list) {
-		if (!link->radar_required)
-			continue;
-
-		radar_detect |=
-			BIT(link->conf->chandef.width);
-	}
-
-	return radar_detect;
-}
-
-int ieee80211_check_combinations(struct ieee80211_sub_if_data *sdata,
-				 const struct cfg80211_chan_def *chandef,
-				 enum ieee80211_chanctx_mode chanmode,
-				 u8 radar_detect)
-{
-	struct ieee80211_local *local = sdata->local;
-	struct ieee80211_sub_if_data *sdata_iter;
-	enum nl80211_iftype iftype = sdata->wdev.iftype;
-	struct ieee80211_chanctx *ctx;
-	int total = 1;
-	struct iface_combination_params params = {
-		.radar_detect = radar_detect,
-	};
-
-	lockdep_assert_held(&local->chanctx_mtx);
-
-	if (WARN_ON(hweight32(radar_detect) > 1))
-		return -EINVAL;
-
-	if (WARN_ON(chandef && chanmode == IEEE80211_CHANCTX_SHARED &&
-		    !chandef->chan))
-		return -EINVAL;
-
-	if (WARN_ON(iftype >= NUM_NL80211_IFTYPES))
-		return -EINVAL;
-
-	if (sdata->vif.type == NL80211_IFTYPE_AP ||
-	    sdata->vif.type == NL80211_IFTYPE_MESH_POINT) {
-		/*
-		 * always passing this is harmless, since it'll be the
-		 * same value that cfg80211 finds if it finds the same
-		 * interface ... and that's always allowed
-		 */
-		params.new_beacon_int = sdata->vif.bss_conf.beacon_int;
-	}
-
-	/* Always allow software iftypes */
-	if (cfg80211_iftype_allowed(local->hw.wiphy, iftype, 0, 1)) {
-		if (radar_detect)
-			return -EINVAL;
-		return 0;
-	}
-
-	if (chandef)
-		params.num_different_channels = 1;
-
-	if (iftype != NL80211_IFTYPE_UNSPECIFIED)
-		params.iftype_num[iftype] = 1;
-
-	list_for_each_entry(ctx, &local->chanctx_list, list) {
-		if (ctx->replace_state == IEEE80211_CHANCTX_WILL_BE_REPLACED)
-			continue;
-		params.radar_detect |=
-			ieee80211_chanctx_radar_detect(local, ctx);
-		if (ctx->mode == IEEE80211_CHANCTX_EXCLUSIVE) {
-			params.num_different_channels++;
-			continue;
-		}
-		if (chandef && chanmode == IEEE80211_CHANCTX_SHARED &&
-		    cfg80211_chandef_compatible(chandef,
-						&ctx->conf.def))
-			continue;
-		params.num_different_channels++;
-	}
-
-	list_for_each_entry_rcu(sdata_iter, &local->interfaces, list) {
-		struct wireless_dev *wdev_iter;
-
-		wdev_iter = &sdata_iter->wdev;
-
-		if (sdata_iter == sdata ||
-		    !ieee80211_sdata_running(sdata_iter) ||
-		    cfg80211_iftype_allowed(local->hw.wiphy,
-					    wdev_iter->iftype, 0, 1))
-			continue;
-
-		params.iftype_num[wdev_iter->iftype]++;
-		total++;
-	}
-
-	if (total == 1 && !params.radar_detect)
-		return 0;
-
-	return cfg80211_check_combinations(local->hw.wiphy, &params);
-}
-
-static void
-ieee80211_iter_max_chans(const struct ieee80211_iface_combination *c,
-			 void *data)
-{
-	u32 *max_num_different_channels = data;
-
-	*max_num_different_channels = max(*max_num_different_channels,
-					  c->num_different_channels);
-}
-
-int ieee80211_max_num_channels(struct ieee80211_local *local)
-{
-	struct ieee80211_sub_if_data *sdata;
-	struct ieee80211_chanctx *ctx;
-	u32 max_num_different_channels = 1;
-	int err;
-	struct iface_combination_params params = {0};
-
-	lockdep_assert_held(&local->chanctx_mtx);
-
-	list_for_each_entry(ctx, &local->chanctx_list, list) {
-		if (ctx->replace_state == IEEE80211_CHANCTX_WILL_BE_REPLACED)
-			continue;
-
-		params.num_different_channels++;
-
-		params.radar_detect |=
-			ieee80211_chanctx_radar_detect(local, ctx);
-	}
-
-	list_for_each_entry_rcu(sdata, &local->interfaces, list)
-		params.iftype_num[sdata->wdev.iftype]++;
-
-	err = cfg80211_iter_combinations(local->hw.wiphy, &params,
-					 ieee80211_iter_max_chans,
-					 &max_num_different_channels);
-	if (err < 0)
-		return err;
-
-	return max_num_different_channels;
-}
-
-void ieee80211_add_s1g_capab_ie(struct ieee80211_sub_if_data *sdata,
-				struct ieee80211_sta_s1g_cap *caps,
-				struct sk_buff *skb)
-{
-	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
-	struct ieee80211_s1g_cap s1g_capab;
-	u8 *pos;
-	int i;
-
-	if (WARN_ON(sdata->vif.type != NL80211_IFTYPE_STATION))
-		return;
-
-	if (!caps->s1g)
-		return;
-
-	memcpy(s1g_capab.capab_info, caps->cap, sizeof(caps->cap));
-	memcpy(s1g_capab.supp_mcs_nss, caps->nss_mcs, sizeof(caps->nss_mcs));
-
-	/* override the capability info */
-	for (i = 0; i < sizeof(ifmgd->s1g_capa.capab_info); i++) {
-		u8 mask = ifmgd->s1g_capa_mask.capab_info[i];
-
-		s1g_capab.capab_info[i] &= ~mask;
-		s1g_capab.capab_info[i] |= ifmgd->s1g_capa.capab_info[i] & mask;
-	}
-
-	/* then MCS and NSS set */
-	for (i = 0; i < sizeof(ifmgd->s1g_capa.supp_mcs_nss); i++) {
-		u8 mask = ifmgd->s1g_capa_mask.supp_mcs_nss[i];
-
-		s1g_capab.supp_mcs_nss[i] &= ~mask;
-		s1g_capab.supp_mcs_nss[i] |=
-			ifmgd->s1g_capa.supp_mcs_nss[i] & mask;
-	}
-
-	pos = skb_put(skb, 2 + sizeof(s1g_capab));
-	*pos++ = WLAN_EID_S1G_CAPABILITIES;
-	*pos++ = sizeof(s1g_capab);
-
-	memcpy(pos, &s1g_capab, sizeof(s1g_capab));
-}
-
-void ieee80211_add_aid_request_ie(struct ieee80211_sub_if_data *sdata,
-				  struct sk_buff *skb)
-{
-	u8 *pos = skb_put(skb, 3);
-
-	*pos++ = WLAN_EID_AID_REQUEST;
-	*pos++ = 1;
-	*pos++ = 0;
-}
-
-u8 *ieee80211_add_wmm_info_ie(u8 *buf, u8 qosinfo)
-{
-	*buf++ = WLAN_EID_VENDOR_SPECIFIC;
-	*buf++ = 7; /* len */
-	*buf++ = 0x00; /* Microsoft OUI 00:50:F2 */
-	*buf++ = 0x50;
-	*buf++ = 0xf2;
-	*buf++ = 2; /* WME */
-	*buf++ = 0; /* WME info */
-	*buf++ = 1; /* WME ver */
-	*buf++ = qosinfo; /* U-APSD no in use */
-
-	return buf;
-}
-
-void ieee80211_txq_get_depth(struct ieee80211_txq *txq,
-			     unsigned long *frame_cnt,
-			     unsigned long *byte_cnt)
-{
-	struct txq_info *txqi = to_txq_info(txq);
-	u32 frag_cnt = 0, frag_bytes = 0;
-	struct sk_buff *skb;
-
-	skb_queue_walk(&txqi->frags, skb) {
-		frag_cnt++;
-		frag_bytes += skb->len;
-	}
-
-	if (frame_cnt)
-		*frame_cnt = txqi->tin.backlog_packets + frag_cnt;
-
-	if (byte_cnt)
-		*byte_cnt = txqi->tin.backlog_bytes + frag_bytes;
-}
-EXPORT_SYMBOL(ieee80211_txq_get_depth);
-
-const u8 ieee80211_ac_to_qos_mask[IEEE80211_NUM_ACS] = {
-	IEEE80211_WMM_IE_STA_QOSINFO_AC_VO,
-	IEEE80211_WMM_IE_STA_QOSINFO_AC_VI,
-	IEEE80211_WMM_IE_STA_QOSINFO_AC_BE,
-	IEEE80211_WMM_IE_STA_QOSINFO_AC_BK
-};
-
-u16 ieee80211_encode_usf(int listen_interval)
-{
-	static const int listen_int_usf[] = { 1, 10, 1000, 10000 };
-	u16 ui, usf = 0;
-
-	/* find greatest USF */
-	while (usf < IEEE80211_MAX_USF) {
-		if (listen_interval % listen_int_usf[usf + 1])
-			break;
-		usf += 1;
-	}
-	ui = listen_interval / listen_int_usf[usf];
-
-	/* error if there is a remainder. Should've been checked by user */
-	WARN_ON_ONCE(ui > IEEE80211_MAX_UI);
-	listen_interval = FIELD_PREP(LISTEN_INT_USF, usf) |
-			  FIELD_PREP(LISTEN_INT_UI, ui);
-
-	return (u16) listen_interval;
-}
-
-u8 ieee80211_ie_len_eht_cap(struct ieee80211_sub_if_data *sdata, u8 iftype)
-{
-	const struct ieee80211_sta_he_cap *he_cap;
-	const struct ieee80211_sta_eht_cap *eht_cap;
-	struct ieee80211_supported_band *sband;
-	bool is_ap;
-	u8 n;
-
-	sband = ieee80211_get_sband(sdata);
-	if (!sband)
-		return 0;
-
-	he_cap = ieee80211_get_he_iftype_cap(sband, iftype);
-	eht_cap = ieee80211_get_eht_iftype_cap(sband, iftype);
-	if (!he_cap || !eht_cap)
-		return 0;
-
-	is_ap = iftype == NL80211_IFTYPE_AP ||
-		iftype == NL80211_IFTYPE_P2P_GO;
-
-	n = ieee80211_eht_mcs_nss_size(&he_cap->he_cap_elem,
-				       &eht_cap->eht_cap_elem,
-				       is_ap);
-	return 2 + 1 +
-	       sizeof(eht_cap->eht_cap_elem) + n +
-	       ieee80211_eht_ppe_size(eht_cap->eht_ppe_thres[0],
-				      eht_cap->eht_cap_elem.phy_cap_info);
-	return 0;
-}
-
-u8 *ieee80211_ie_build_eht_cap(u8 *pos,
-			       const struct ieee80211_sta_he_cap *he_cap,
-			       const struct ieee80211_sta_eht_cap *eht_cap,
-			       u8 *end,
-			       bool for_ap)
-{
-	u8 mcs_nss_len, ppet_len;
-	u8 ie_len;
-	u8 *orig_pos = pos;
-
-	/* Make sure we have place for the IE */
-	if (!he_cap || !eht_cap)
-		return orig_pos;
-
-	mcs_nss_len = ieee80211_eht_mcs_nss_size(&he_cap->he_cap_elem,
-						 &eht_cap->eht_cap_elem,
-						 for_ap);
-	ppet_len = ieee80211_eht_ppe_size(eht_cap->eht_ppe_thres[0],
-					  eht_cap->eht_cap_elem.phy_cap_info);
-
-	ie_len = 2 + 1 + sizeof(eht_cap->eht_cap_elem) + mcs_nss_len + ppet_len;
-	if ((end - pos) < ie_len)
-		return orig_pos;
-
-	*pos++ = WLAN_EID_EXTENSION;
-	*pos++ = ie_len - 2;
-	*pos++ = WLAN_EID_EXT_EHT_CAPABILITY;
-
-	/* Fixed data */
-	memcpy(pos, &eht_cap->eht_cap_elem, sizeof(eht_cap->eht_cap_elem));
-	pos += sizeof(eht_cap->eht_cap_elem);
-
-	memcpy(pos, &eht_cap->eht_mcs_nss_supp, mcs_nss_len);
-	pos += mcs_nss_len;
-
-	if (ppet_len) {
-		memcpy(pos, &eht_cap->eht_ppe_thres, ppet_len);
-		pos += ppet_len;
-	}
-
-	return pos;
-}
-
-void ieee80211_fragment_element(struct sk_buff *skb, u8 *len_pos, u8 frag_id)
-{
-	unsigned int elem_len;
-
-	if (!len_pos)
-		return;
-
-	elem_len = skb->data + skb->len - len_pos - 1;
-
-	while (elem_len > 255) {
-		/* this one is 255 */
-		*len_pos = 255;
-		/* remaining data gets smaller */
-		elem_len -= 255;
-		/* make space for the fragment ID/len in SKB */
-		skb_put(skb, 2);
-		/* shift back the remaining data to place fragment ID/len */
-		memmove(len_pos + 255 + 3, len_pos + 255 + 1, elem_len);
-		/* place the fragment ID */
-		len_pos += 255 + 1;
-		*len_pos = frag_id;
-		/* and point to fragment length to update later */
-		len_pos++;
-	}
-
-	*len_pos = elem_len;
-}
diff --git a/net/mac80211/wpa.c.orig b/net/mac80211/wpa.c.orig
deleted file mode 100644
index 2d8e38b3bcb5..000000000000
--- a/net/mac80211/wpa.c.orig
+++ /dev/null
@@ -1,1118 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * Copyright 2002-2004, Instant802 Networks, Inc.
- * Copyright 2008, Jouni Malinen <j@w1.fi>
- * Copyright (C) 2016-2017 Intel Deutschland GmbH
- * Copyright (C) 2020-2022 Intel Corporation
- */
-
-#include <linux/netdevice.h>
-#include <linux/types.h>
-#include <linux/skbuff.h>
-#include <linux/compiler.h>
-#include <linux/ieee80211.h>
-#include <linux/gfp.h>
-#include <asm/unaligned.h>
-#include <net/mac80211.h>
-#include <crypto/aes.h>
-#include <crypto/utils.h>
-
-#include "ieee80211_i.h"
-#include "michael.h"
-#include "tkip.h"
-#include "aes_ccm.h"
-#include "aes_cmac.h"
-#include "aes_gmac.h"
-#include "aes_gcm.h"
-#include "wpa.h"
-
-ieee80211_tx_result
-ieee80211_tx_h_michael_mic_add(struct ieee80211_tx_data *tx)
-{
-	u8 *data, *key, *mic;
-	size_t data_len;
-	unsigned int hdrlen;
-	struct ieee80211_hdr *hdr;
-	struct sk_buff *skb = tx->skb;
-	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
-	int tail;
-
-	hdr = (struct ieee80211_hdr *)skb->data;
-	if (!tx->key || tx->key->conf.cipher != WLAN_CIPHER_SUITE_TKIP ||
-	    skb->len < 24 || !ieee80211_is_data_present(hdr->frame_control))
-		return TX_CONTINUE;
-
-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
-	if (skb->len < hdrlen)
-		return TX_DROP;
-
-	data = skb->data + hdrlen;
-	data_len = skb->len - hdrlen;
-
-	if (unlikely(info->flags & IEEE80211_TX_INTFL_TKIP_MIC_FAILURE)) {
-		/* Need to use software crypto for the test */
-		info->control.hw_key = NULL;
-	}
-
-	if (info->control.hw_key &&
-	    (info->flags & IEEE80211_TX_CTL_DONTFRAG ||
-	     ieee80211_hw_check(&tx->local->hw, SUPPORTS_TX_FRAG)) &&
-	    !(tx->key->conf.flags & (IEEE80211_KEY_FLAG_GENERATE_MMIC |
-				     IEEE80211_KEY_FLAG_PUT_MIC_SPACE))) {
-		/* hwaccel - with no need for SW-generated MMIC or MIC space */
-		return TX_CONTINUE;
-	}
-
-	tail = MICHAEL_MIC_LEN;
-	if (!info->control.hw_key)
-		tail += IEEE80211_TKIP_ICV_LEN;
-
-	if (WARN(skb_tailroom(skb) < tail ||
-		 skb_headroom(skb) < IEEE80211_TKIP_IV_LEN,
-		 "mmic: not enough head/tail (%d/%d,%d/%d)\n",
-		 skb_headroom(skb), IEEE80211_TKIP_IV_LEN,
-		 skb_tailroom(skb), tail))
-		return TX_DROP;
-
-	mic = skb_put(skb, MICHAEL_MIC_LEN);
-
-	if (tx->key->conf.flags & IEEE80211_KEY_FLAG_PUT_MIC_SPACE) {
-		/* Zeroed MIC can help with debug */
-		memset(mic, 0, MICHAEL_MIC_LEN);
-		return TX_CONTINUE;
-	}
-
-	key = &tx->key->conf.key[NL80211_TKIP_DATA_OFFSET_TX_MIC_KEY];
-	michael_mic(key, hdr, data, data_len, mic);
-	if (unlikely(info->flags & IEEE80211_TX_INTFL_TKIP_MIC_FAILURE))
-		mic[0]++;
-
-	return TX_CONTINUE;
-}
-
-
-ieee80211_rx_result
-ieee80211_rx_h_michael_mic_verify(struct ieee80211_rx_data *rx)
-{
-	u8 *data, *key = NULL;
-	size_t data_len;
-	unsigned int hdrlen;
-	u8 mic[MICHAEL_MIC_LEN];
-	struct sk_buff *skb = rx->skb;
-	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
-	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
-
-	/*
-	 * it makes no sense to check for MIC errors on anything other
-	 * than data frames.
-	 */
-	if (!ieee80211_is_data_present(hdr->frame_control))
-		return RX_CONTINUE;
-
-	/*
-	 * No way to verify the MIC if the hardware stripped it or
-	 * the IV with the key index. In this case we have solely rely
-	 * on the driver to set RX_FLAG_MMIC_ERROR in the event of a
-	 * MIC failure report.
-	 */
-	if (status->flag & (RX_FLAG_MMIC_STRIPPED | RX_FLAG_IV_STRIPPED)) {
-		if (status->flag & RX_FLAG_MMIC_ERROR)
-			goto mic_fail_no_key;
-
-		if (!(status->flag & RX_FLAG_IV_STRIPPED) && rx->key &&
-		    rx->key->conf.cipher == WLAN_CIPHER_SUITE_TKIP)
-			goto update_iv;
-
-		return RX_CONTINUE;
-	}
-
-	/*
-	 * Some hardware seems to generate Michael MIC failure reports; even
-	 * though, the frame was not encrypted with TKIP and therefore has no
-	 * MIC. Ignore the flag them to avoid triggering countermeasures.
-	 */
-	if (!rx->key || rx->key->conf.cipher != WLAN_CIPHER_SUITE_TKIP ||
-	    !(status->flag & RX_FLAG_DECRYPTED))
-		return RX_CONTINUE;
-
-	if (rx->sdata->vif.type == NL80211_IFTYPE_AP && rx->key->conf.keyidx) {
-		/*
-		 * APs with pairwise keys should never receive Michael MIC
-		 * errors for non-zero keyidx because these are reserved for
-		 * group keys and only the AP is sending real multicast
-		 * frames in the BSS.
-		 */
-		return RX_DROP_UNUSABLE;
-	}
-
-	if (status->flag & RX_FLAG_MMIC_ERROR)
-		goto mic_fail;
-
-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
-	if (skb->len < hdrlen + MICHAEL_MIC_LEN)
-		return RX_DROP_UNUSABLE;
-
-	if (skb_linearize(rx->skb))
-		return RX_DROP_UNUSABLE;
-	hdr = (void *)skb->data;
-
-	data = skb->data + hdrlen;
-	data_len = skb->len - hdrlen - MICHAEL_MIC_LEN;
-	key = &rx->key->conf.key[NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY];
-	michael_mic(key, hdr, data, data_len, mic);
-	if (crypto_memneq(mic, data + data_len, MICHAEL_MIC_LEN))
-		goto mic_fail;
-
-	/* remove Michael MIC from payload */
-	skb_trim(skb, skb->len - MICHAEL_MIC_LEN);
-
-update_iv:
-	/* update IV in key information to be able to detect replays */
-	rx->key->u.tkip.rx[rx->security_idx].iv32 = rx->tkip.iv32;
-	rx->key->u.tkip.rx[rx->security_idx].iv16 = rx->tkip.iv16;
-
-	return RX_CONTINUE;
-
-mic_fail:
-	rx->key->u.tkip.mic_failures++;
-
-mic_fail_no_key:
-	/*
-	 * In some cases the key can be unset - e.g. a multicast packet, in
-	 * a driver that supports HW encryption. Send up the key idx only if
-	 * the key is set.
-	 */
-	cfg80211_michael_mic_failure(rx->sdata->dev, hdr->addr2,
-				     is_multicast_ether_addr(hdr->addr1) ?
-				     NL80211_KEYTYPE_GROUP :
-				     NL80211_KEYTYPE_PAIRWISE,
-				     rx->key ? rx->key->conf.keyidx : -1,
-				     NULL, GFP_ATOMIC);
-	return RX_DROP_UNUSABLE;
-}
-
-static int tkip_encrypt_skb(struct ieee80211_tx_data *tx, struct sk_buff *skb)
-{
-	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
-	struct ieee80211_key *key = tx->key;
-	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
-	unsigned int hdrlen;
-	int len, tail;
-	u64 pn;
-	u8 *pos;
-
-	if (info->control.hw_key &&
-	    !(info->control.hw_key->flags & IEEE80211_KEY_FLAG_GENERATE_IV) &&
-	    !(info->control.hw_key->flags & IEEE80211_KEY_FLAG_PUT_IV_SPACE)) {
-		/* hwaccel - with no need for software-generated IV */
-		return 0;
-	}
-
-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
-	len = skb->len - hdrlen;
-
-	if (info->control.hw_key)
-		tail = 0;
-	else
-		tail = IEEE80211_TKIP_ICV_LEN;
-
-	if (WARN_ON(skb_tailroom(skb) < tail ||
-		    skb_headroom(skb) < IEEE80211_TKIP_IV_LEN))
-		return -1;
-
-	pos = skb_push(skb, IEEE80211_TKIP_IV_LEN);
-	memmove(pos, pos + IEEE80211_TKIP_IV_LEN, hdrlen);
-	pos += hdrlen;
-
-	/* the HW only needs room for the IV, but not the actual IV */
-	if (info->control.hw_key &&
-	    (info->control.hw_key->flags & IEEE80211_KEY_FLAG_PUT_IV_SPACE))
-		return 0;
-
-	/* Increase IV for the frame */
-	pn = atomic64_inc_return(&key->conf.tx_pn);
-	pos = ieee80211_tkip_add_iv(pos, &key->conf, pn);
-
-	/* hwaccel - with software IV */
-	if (info->control.hw_key)
-		return 0;
-
-	/* Add room for ICV */
-	skb_put(skb, IEEE80211_TKIP_ICV_LEN);
-
-	return ieee80211_tkip_encrypt_data(&tx->local->wep_tx_ctx,
-					   key, skb, pos, len);
-}
-
-
-ieee80211_tx_result
-ieee80211_crypto_tkip_encrypt(struct ieee80211_tx_data *tx)
-{
-	struct sk_buff *skb;
-
-	ieee80211_tx_set_protected(tx);
-
-	skb_queue_walk(&tx->skbs, skb) {
-		if (tkip_encrypt_skb(tx, skb) < 0)
-			return TX_DROP;
-	}
-
-	return TX_CONTINUE;
-}
-
-
-ieee80211_rx_result
-ieee80211_crypto_tkip_decrypt(struct ieee80211_rx_data *rx)
-{
-	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) rx->skb->data;
-	int hdrlen, res, hwaccel = 0;
-	struct ieee80211_key *key = rx->key;
-	struct sk_buff *skb = rx->skb;
-	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
-
-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
-
-	if (!ieee80211_is_data(hdr->frame_control))
-		return RX_CONTINUE;
-
-	if (!rx->sta || skb->len - hdrlen < 12)
-		return RX_DROP_UNUSABLE;
-
-	/* it may be possible to optimize this a bit more */
-	if (skb_linearize(rx->skb))
-		return RX_DROP_UNUSABLE;
-	hdr = (void *)skb->data;
-
-	/*
-	 * Let TKIP code verify IV, but skip decryption.
-	 * In the case where hardware checks the IV as well,
-	 * we don't even get here, see ieee80211_rx_h_decrypt()
-	 */
-	if (status->flag & RX_FLAG_DECRYPTED)
-		hwaccel = 1;
-
-	res = ieee80211_tkip_decrypt_data(&rx->local->wep_rx_ctx,
-					  key, skb->data + hdrlen,
-					  skb->len - hdrlen, rx->sta->sta.addr,
-					  hdr->addr1, hwaccel, rx->security_idx,
-					  &rx->tkip.iv32,
-					  &rx->tkip.iv16);
-	if (res != TKIP_DECRYPT_OK)
-		return RX_DROP_UNUSABLE;
-
-	/* Trim ICV */
-	if (!(status->flag & RX_FLAG_ICV_STRIPPED))
-		skb_trim(skb, skb->len - IEEE80211_TKIP_ICV_LEN);
-
-	/* Remove IV */
-	memmove(skb->data + IEEE80211_TKIP_IV_LEN, skb->data, hdrlen);
-	skb_pull(skb, IEEE80211_TKIP_IV_LEN);
-
-	return RX_CONTINUE;
-}
-
-/*
- * Calculate AAD for CCMP/GCMP, returning qos_tid since we
- * need that in CCMP also for b_0.
- */
-static u8 ccmp_gcmp_aad(struct sk_buff *skb, u8 *aad)
-{
-	struct ieee80211_hdr *hdr = (void *)skb->data;
-	__le16 mask_fc;
-	int a4_included, mgmt;
-	u8 qos_tid;
-	u16 len_a = 22;
-
-	/*
-	 * Mask FC: zero subtype b4 b5 b6 (if not mgmt)
-	 * Retry, PwrMgt, MoreData, Order (if Qos Data); set Protected
-	 */
-	mgmt = ieee80211_is_mgmt(hdr->frame_control);
-	mask_fc = hdr->frame_control;
-	mask_fc &= ~cpu_to_le16(IEEE80211_FCTL_RETRY |
-				IEEE80211_FCTL_PM | IEEE80211_FCTL_MOREDATA);
-	if (!mgmt)
-		mask_fc &= ~cpu_to_le16(0x0070);
-	mask_fc |= cpu_to_le16(IEEE80211_FCTL_PROTECTED);
-
-	a4_included = ieee80211_has_a4(hdr->frame_control);
-	if (a4_included)
-		len_a += 6;
-
-	if (ieee80211_is_data_qos(hdr->frame_control)) {
-		qos_tid = ieee80211_get_tid(hdr);
-		mask_fc &= ~cpu_to_le16(IEEE80211_FCTL_ORDER);
-		len_a += 2;
-	} else {
-		qos_tid = 0;
-	}
-
-	/* AAD (extra authenticate-only data) / masked 802.11 header
-	 * FC | A1 | A2 | A3 | SC | [A4] | [QC] */
-	put_unaligned_be16(len_a, &aad[0]);
-	put_unaligned(mask_fc, (__le16 *)&aad[2]);
-	memcpy(&aad[4], &hdr->addrs, 3 * ETH_ALEN);
-
-	/* Mask Seq#, leave Frag# */
-	aad[22] = *((u8 *) &hdr->seq_ctrl) & 0x0f;
-	aad[23] = 0;
-
-	if (a4_included) {
-		memcpy(&aad[24], hdr->addr4, ETH_ALEN);
-		aad[30] = qos_tid;
-		aad[31] = 0;
-	} else {
-		memset(&aad[24], 0, ETH_ALEN + IEEE80211_QOS_CTL_LEN);
-		aad[24] = qos_tid;
-	}
-
-	return qos_tid;
-}
-
-static void ccmp_special_blocks(struct sk_buff *skb, u8 *pn, u8 *b_0, u8 *aad)
-{
-	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
-	u8 qos_tid = ccmp_gcmp_aad(skb, aad);
-
-	/* In CCM, the initial vectors (IV) used for CTR mode encryption and CBC
-	 * mode authentication are not allowed to collide, yet both are derived
-	 * from this vector b_0. We only set L := 1 here to indicate that the
-	 * data size can be represented in (L+1) bytes. The CCM layer will take
-	 * care of storing the data length in the top (L+1) bytes and setting
-	 * and clearing the other bits as is required to derive the two IVs.
-	 */
-	b_0[0] = 0x1;
-
-	/* Nonce: Nonce Flags | A2 | PN
-	 * Nonce Flags: Priority (b0..b3) | Management (b4) | Reserved (b5..b7)
-	 */
-	b_0[1] = qos_tid | (ieee80211_is_mgmt(hdr->frame_control) << 4);
-	memcpy(&b_0[2], hdr->addr2, ETH_ALEN);
-	memcpy(&b_0[8], pn, IEEE80211_CCMP_PN_LEN);
-}
-
-static inline void ccmp_pn2hdr(u8 *hdr, u8 *pn, int key_id)
-{
-	hdr[0] = pn[5];
-	hdr[1] = pn[4];
-	hdr[2] = 0;
-	hdr[3] = 0x20 | (key_id << 6);
-	hdr[4] = pn[3];
-	hdr[5] = pn[2];
-	hdr[6] = pn[1];
-	hdr[7] = pn[0];
-}
-
-
-static inline void ccmp_hdr2pn(u8 *pn, u8 *hdr)
-{
-	pn[0] = hdr[7];
-	pn[1] = hdr[6];
-	pn[2] = hdr[5];
-	pn[3] = hdr[4];
-	pn[4] = hdr[1];
-	pn[5] = hdr[0];
-}
-
-
-static int ccmp_encrypt_skb(struct ieee80211_tx_data *tx, struct sk_buff *skb,
-			    unsigned int mic_len)
-{
-	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
-	struct ieee80211_key *key = tx->key;
-	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
-	int hdrlen, len, tail;
-	u8 *pos;
-	u8 pn[6];
-	u64 pn64;
-	u8 aad[CCM_AAD_LEN];
-	u8 b_0[AES_BLOCK_SIZE];
-
-	if (info->control.hw_key &&
-	    !(info->control.hw_key->flags & IEEE80211_KEY_FLAG_GENERATE_IV) &&
-	    !(info->control.hw_key->flags & IEEE80211_KEY_FLAG_PUT_IV_SPACE) &&
-	    !((info->control.hw_key->flags &
-	       IEEE80211_KEY_FLAG_GENERATE_IV_MGMT) &&
-	      ieee80211_is_mgmt(hdr->frame_control))) {
-		/*
-		 * hwaccel has no need for preallocated room for CCMP
-		 * header or MIC fields
-		 */
-		return 0;
-	}
-
-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
-	len = skb->len - hdrlen;
-
-	if (info->control.hw_key)
-		tail = 0;
-	else
-		tail = mic_len;
-
-	if (WARN_ON(skb_tailroom(skb) < tail ||
-		    skb_headroom(skb) < IEEE80211_CCMP_HDR_LEN))
-		return -1;
-
-	pos = skb_push(skb, IEEE80211_CCMP_HDR_LEN);
-	memmove(pos, pos + IEEE80211_CCMP_HDR_LEN, hdrlen);
-
-	/* the HW only needs room for the IV, but not the actual IV */
-	if (info->control.hw_key &&
-	    (info->control.hw_key->flags & IEEE80211_KEY_FLAG_PUT_IV_SPACE))
-		return 0;
-
-	pos += hdrlen;
-
-	pn64 = atomic64_inc_return(&key->conf.tx_pn);
-
-	pn[5] = pn64;
-	pn[4] = pn64 >> 8;
-	pn[3] = pn64 >> 16;
-	pn[2] = pn64 >> 24;
-	pn[1] = pn64 >> 32;
-	pn[0] = pn64 >> 40;
-
-	ccmp_pn2hdr(pos, pn, key->conf.keyidx);
-
-	/* hwaccel - with software CCMP header */
-	if (info->control.hw_key)
-		return 0;
-
-	pos += IEEE80211_CCMP_HDR_LEN;
-	ccmp_special_blocks(skb, pn, b_0, aad);
-	return ieee80211_aes_ccm_encrypt(key->u.ccmp.tfm, b_0, aad, pos, len,
-					 skb_put(skb, mic_len));
-}
-
-
-ieee80211_tx_result
-ieee80211_crypto_ccmp_encrypt(struct ieee80211_tx_data *tx,
-			      unsigned int mic_len)
-{
-	struct sk_buff *skb;
-
-	ieee80211_tx_set_protected(tx);
-
-	skb_queue_walk(&tx->skbs, skb) {
-		if (ccmp_encrypt_skb(tx, skb, mic_len) < 0)
-			return TX_DROP;
-	}
-
-	return TX_CONTINUE;
-}
-
-
-ieee80211_rx_result
-ieee80211_crypto_ccmp_decrypt(struct ieee80211_rx_data *rx,
-			      unsigned int mic_len)
-{
-	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;
-	int hdrlen;
-	struct ieee80211_key *key = rx->key;
-	struct sk_buff *skb = rx->skb;
-	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
-	u8 pn[IEEE80211_CCMP_PN_LEN];
-	int data_len;
-	int queue;
-
-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
-
-	if (!ieee80211_is_data(hdr->frame_control) &&
-	    !ieee80211_is_robust_mgmt_frame(skb))
-		return RX_CONTINUE;
-
-	if (status->flag & RX_FLAG_DECRYPTED) {
-		if (!pskb_may_pull(rx->skb, hdrlen + IEEE80211_CCMP_HDR_LEN))
-			return RX_DROP_UNUSABLE;
-		if (status->flag & RX_FLAG_MIC_STRIPPED)
-			mic_len = 0;
-	} else {
-		if (skb_linearize(rx->skb))
-			return RX_DROP_UNUSABLE;
-	}
-
-	/* reload hdr - skb might have been reallocated */
-	hdr = (void *)rx->skb->data;
-
-	data_len = skb->len - hdrlen - IEEE80211_CCMP_HDR_LEN - mic_len;
-	if (!rx->sta || data_len < 0)
-		return RX_DROP_UNUSABLE;
-
-	if (!(status->flag & RX_FLAG_PN_VALIDATED)) {
-		int res;
-
-		ccmp_hdr2pn(pn, skb->data + hdrlen);
-
-		queue = rx->security_idx;
-
-		res = memcmp(pn, key->u.ccmp.rx_pn[queue],
-			     IEEE80211_CCMP_PN_LEN);
-		if (res < 0 ||
-		    (!res && !(status->flag & RX_FLAG_ALLOW_SAME_PN))) {
-			key->u.ccmp.replays++;
-			return RX_DROP_U_REPLAY;
-		}
-
-		if (!(status->flag & RX_FLAG_DECRYPTED)) {
-			u8 aad[2 * AES_BLOCK_SIZE];
-			u8 b_0[AES_BLOCK_SIZE];
-			/* hardware didn't decrypt/verify MIC */
-			ccmp_special_blocks(skb, pn, b_0, aad);
-
-			if (ieee80211_aes_ccm_decrypt(
-				    key->u.ccmp.tfm, b_0, aad,
-				    skb->data + hdrlen + IEEE80211_CCMP_HDR_LEN,
-				    data_len,
-				    skb->data + skb->len - mic_len))
-				return RX_DROP_U_MIC_FAIL;
-		}
-
-		memcpy(key->u.ccmp.rx_pn[queue], pn, IEEE80211_CCMP_PN_LEN);
-		if (unlikely(ieee80211_is_frag(hdr)))
-			memcpy(rx->ccm_gcm.pn, pn, IEEE80211_CCMP_PN_LEN);
-	}
-
-	/* Remove CCMP header and MIC */
-	if (pskb_trim(skb, skb->len - mic_len))
-		return RX_DROP_UNUSABLE;
-	memmove(skb->data + IEEE80211_CCMP_HDR_LEN, skb->data, hdrlen);
-	skb_pull(skb, IEEE80211_CCMP_HDR_LEN);
-
-	return RX_CONTINUE;
-}
-
-static void gcmp_special_blocks(struct sk_buff *skb, u8 *pn, u8 *j_0, u8 *aad)
-{
-	struct ieee80211_hdr *hdr = (void *)skb->data;
-
-	memcpy(j_0, hdr->addr2, ETH_ALEN);
-	memcpy(&j_0[ETH_ALEN], pn, IEEE80211_GCMP_PN_LEN);
-	j_0[13] = 0;
-	j_0[14] = 0;
-	j_0[AES_BLOCK_SIZE - 1] = 0x01;
-
-	ccmp_gcmp_aad(skb, aad);
-}
-
-static inline void gcmp_pn2hdr(u8 *hdr, const u8 *pn, int key_id)
-{
-	hdr[0] = pn[5];
-	hdr[1] = pn[4];
-	hdr[2] = 0;
-	hdr[3] = 0x20 | (key_id << 6);
-	hdr[4] = pn[3];
-	hdr[5] = pn[2];
-	hdr[6] = pn[1];
-	hdr[7] = pn[0];
-}
-
-static inline void gcmp_hdr2pn(u8 *pn, const u8 *hdr)
-{
-	pn[0] = hdr[7];
-	pn[1] = hdr[6];
-	pn[2] = hdr[5];
-	pn[3] = hdr[4];
-	pn[4] = hdr[1];
-	pn[5] = hdr[0];
-}
-
-static int gcmp_encrypt_skb(struct ieee80211_tx_data *tx, struct sk_buff *skb)
-{
-	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
-	struct ieee80211_key *key = tx->key;
-	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
-	int hdrlen, len, tail;
-	u8 *pos;
-	u8 pn[6];
-	u64 pn64;
-	u8 aad[GCM_AAD_LEN];
-	u8 j_0[AES_BLOCK_SIZE];
-
-	if (info->control.hw_key &&
-	    !(info->control.hw_key->flags & IEEE80211_KEY_FLAG_GENERATE_IV) &&
-	    !(info->control.hw_key->flags & IEEE80211_KEY_FLAG_PUT_IV_SPACE) &&
-	    !((info->control.hw_key->flags &
-	       IEEE80211_KEY_FLAG_GENERATE_IV_MGMT) &&
-	      ieee80211_is_mgmt(hdr->frame_control))) {
-		/* hwaccel has no need for preallocated room for GCMP
-		 * header or MIC fields
-		 */
-		return 0;
-	}
-
-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
-	len = skb->len - hdrlen;
-
-	if (info->control.hw_key)
-		tail = 0;
-	else
-		tail = IEEE80211_GCMP_MIC_LEN;
-
-	if (WARN_ON(skb_tailroom(skb) < tail ||
-		    skb_headroom(skb) < IEEE80211_GCMP_HDR_LEN))
-		return -1;
-
-	pos = skb_push(skb, IEEE80211_GCMP_HDR_LEN);
-	memmove(pos, pos + IEEE80211_GCMP_HDR_LEN, hdrlen);
-	skb_set_network_header(skb, skb_network_offset(skb) +
-				    IEEE80211_GCMP_HDR_LEN);
-
-	/* the HW only needs room for the IV, but not the actual IV */
-	if (info->control.hw_key &&
-	    (info->control.hw_key->flags & IEEE80211_KEY_FLAG_PUT_IV_SPACE))
-		return 0;
-
-	pos += hdrlen;
-
-	pn64 = atomic64_inc_return(&key->conf.tx_pn);
-
-	pn[5] = pn64;
-	pn[4] = pn64 >> 8;
-	pn[3] = pn64 >> 16;
-	pn[2] = pn64 >> 24;
-	pn[1] = pn64 >> 32;
-	pn[0] = pn64 >> 40;
-
-	gcmp_pn2hdr(pos, pn, key->conf.keyidx);
-
-	/* hwaccel - with software GCMP header */
-	if (info->control.hw_key)
-		return 0;
-
-	pos += IEEE80211_GCMP_HDR_LEN;
-	gcmp_special_blocks(skb, pn, j_0, aad);
-	return ieee80211_aes_gcm_encrypt(key->u.gcmp.tfm, j_0, aad, pos, len,
-					 skb_put(skb, IEEE80211_GCMP_MIC_LEN));
-}
-
-ieee80211_tx_result
-ieee80211_crypto_gcmp_encrypt(struct ieee80211_tx_data *tx)
-{
-	struct sk_buff *skb;
-
-	ieee80211_tx_set_protected(tx);
-
-	skb_queue_walk(&tx->skbs, skb) {
-		if (gcmp_encrypt_skb(tx, skb) < 0)
-			return TX_DROP;
-	}
-
-	return TX_CONTINUE;
-}
-
-ieee80211_rx_result
-ieee80211_crypto_gcmp_decrypt(struct ieee80211_rx_data *rx)
-{
-	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;
-	int hdrlen;
-	struct ieee80211_key *key = rx->key;
-	struct sk_buff *skb = rx->skb;
-	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
-	u8 pn[IEEE80211_GCMP_PN_LEN];
-	int data_len, queue, mic_len = IEEE80211_GCMP_MIC_LEN;
-
-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
-
-	if (!ieee80211_is_data(hdr->frame_control) &&
-	    !ieee80211_is_robust_mgmt_frame(skb))
-		return RX_CONTINUE;
-
-	if (status->flag & RX_FLAG_DECRYPTED) {
-		if (!pskb_may_pull(rx->skb, hdrlen + IEEE80211_GCMP_HDR_LEN))
-			return RX_DROP_UNUSABLE;
-		if (status->flag & RX_FLAG_MIC_STRIPPED)
-			mic_len = 0;
-	} else {
-		if (skb_linearize(rx->skb))
-			return RX_DROP_UNUSABLE;
-	}
-
-	/* reload hdr - skb might have been reallocated */
-	hdr = (void *)rx->skb->data;
-
-	data_len = skb->len - hdrlen - IEEE80211_GCMP_HDR_LEN - mic_len;
-	if (!rx->sta || data_len < 0)
-		return RX_DROP_UNUSABLE;
-
-	if (!(status->flag & RX_FLAG_PN_VALIDATED)) {
-		int res;
-
-		gcmp_hdr2pn(pn, skb->data + hdrlen);
-
-		queue = rx->security_idx;
-
-		res = memcmp(pn, key->u.gcmp.rx_pn[queue],
-			     IEEE80211_GCMP_PN_LEN);
-		if (res < 0 ||
-		    (!res && !(status->flag & RX_FLAG_ALLOW_SAME_PN))) {
-			key->u.gcmp.replays++;
-			return RX_DROP_U_REPLAY;
-		}
-
-		if (!(status->flag & RX_FLAG_DECRYPTED)) {
-			u8 aad[2 * AES_BLOCK_SIZE];
-			u8 j_0[AES_BLOCK_SIZE];
-			/* hardware didn't decrypt/verify MIC */
-			gcmp_special_blocks(skb, pn, j_0, aad);
-
-			if (ieee80211_aes_gcm_decrypt(
-				    key->u.gcmp.tfm, j_0, aad,
-				    skb->data + hdrlen + IEEE80211_GCMP_HDR_LEN,
-				    data_len,
-				    skb->data + skb->len -
-				    IEEE80211_GCMP_MIC_LEN))
-				return RX_DROP_U_MIC_FAIL;
-		}
-
-		memcpy(key->u.gcmp.rx_pn[queue], pn, IEEE80211_GCMP_PN_LEN);
-		if (unlikely(ieee80211_is_frag(hdr)))
-			memcpy(rx->ccm_gcm.pn, pn, IEEE80211_CCMP_PN_LEN);
-	}
-
-	/* Remove GCMP header and MIC */
-	if (pskb_trim(skb, skb->len - mic_len))
-		return RX_DROP_UNUSABLE;
-	memmove(skb->data + IEEE80211_GCMP_HDR_LEN, skb->data, hdrlen);
-	skb_pull(skb, IEEE80211_GCMP_HDR_LEN);
-
-	return RX_CONTINUE;
-}
-
-static void bip_aad(struct sk_buff *skb, u8 *aad)
-{
-	__le16 mask_fc;
-	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
-
-	/* BIP AAD: FC(masked) || A1 || A2 || A3 */
-
-	/* FC type/subtype */
-	/* Mask FC Retry, PwrMgt, MoreData flags to zero */
-	mask_fc = hdr->frame_control;
-	mask_fc &= ~cpu_to_le16(IEEE80211_FCTL_RETRY | IEEE80211_FCTL_PM |
-				IEEE80211_FCTL_MOREDATA);
-	put_unaligned(mask_fc, (__le16 *) &aad[0]);
-	/* A1 || A2 || A3 */
-	memcpy(aad + 2, &hdr->addrs, 3 * ETH_ALEN);
-}
-
-
-static inline void bip_ipn_set64(u8 *d, u64 pn)
-{
-	*d++ = pn;
-	*d++ = pn >> 8;
-	*d++ = pn >> 16;
-	*d++ = pn >> 24;
-	*d++ = pn >> 32;
-	*d = pn >> 40;
-}
-
-static inline void bip_ipn_swap(u8 *d, const u8 *s)
-{
-	*d++ = s[5];
-	*d++ = s[4];
-	*d++ = s[3];
-	*d++ = s[2];
-	*d++ = s[1];
-	*d = s[0];
-}
-
-
-ieee80211_tx_result
-ieee80211_crypto_aes_cmac_encrypt(struct ieee80211_tx_data *tx)
-{
-	struct sk_buff *skb;
-	struct ieee80211_tx_info *info;
-	struct ieee80211_key *key = tx->key;
-	struct ieee80211_mmie *mmie;
-	u8 aad[20];
-	u64 pn64;
-
-	if (WARN_ON(skb_queue_len(&tx->skbs) != 1))
-		return TX_DROP;
-
-	skb = skb_peek(&tx->skbs);
-
-	info = IEEE80211_SKB_CB(skb);
-
-	if (info->control.hw_key &&
-	    !(key->conf.flags & IEEE80211_KEY_FLAG_GENERATE_MMIE))
-		return TX_CONTINUE;
-
-	if (WARN_ON(skb_tailroom(skb) < sizeof(*mmie)))
-		return TX_DROP;
-
-	mmie = skb_put(skb, sizeof(*mmie));
-	mmie->element_id = WLAN_EID_MMIE;
-	mmie->length = sizeof(*mmie) - 2;
-	mmie->key_id = cpu_to_le16(key->conf.keyidx);
-
-	/* PN = PN + 1 */
-	pn64 = atomic64_inc_return(&key->conf.tx_pn);
-
-	bip_ipn_set64(mmie->sequence_number, pn64);
-
-	if (info->control.hw_key)
-		return TX_CONTINUE;
-
-	bip_aad(skb, aad);
-
-	/*
-	 * MIC = AES-128-CMAC(IGTK, AAD || Management Frame Body || MMIE, 64)
-	 */
-	ieee80211_aes_cmac(key->u.aes_cmac.tfm, aad,
-			   skb->data + 24, skb->len - 24, mmie->mic);
-
-	return TX_CONTINUE;
-}
-
-ieee80211_tx_result
-ieee80211_crypto_aes_cmac_256_encrypt(struct ieee80211_tx_data *tx)
-{
-	struct sk_buff *skb;
-	struct ieee80211_tx_info *info;
-	struct ieee80211_key *key = tx->key;
-	struct ieee80211_mmie_16 *mmie;
-	u8 aad[20];
-	u64 pn64;
-
-	if (WARN_ON(skb_queue_len(&tx->skbs) != 1))
-		return TX_DROP;
-
-	skb = skb_peek(&tx->skbs);
-
-	info = IEEE80211_SKB_CB(skb);
-
-	if (info->control.hw_key)
-		return TX_CONTINUE;
-
-	if (WARN_ON(skb_tailroom(skb) < sizeof(*mmie)))
-		return TX_DROP;
-
-	mmie = skb_put(skb, sizeof(*mmie));
-	mmie->element_id = WLAN_EID_MMIE;
-	mmie->length = sizeof(*mmie) - 2;
-	mmie->key_id = cpu_to_le16(key->conf.keyidx);
-
-	/* PN = PN + 1 */
-	pn64 = atomic64_inc_return(&key->conf.tx_pn);
-
-	bip_ipn_set64(mmie->sequence_number, pn64);
-
-	bip_aad(skb, aad);
-
-	/* MIC = AES-256-CMAC(IGTK, AAD || Management Frame Body || MMIE, 128)
-	 */
-	ieee80211_aes_cmac_256(key->u.aes_cmac.tfm, aad,
-			       skb->data + 24, skb->len - 24, mmie->mic);
-
-	return TX_CONTINUE;
-}
-
-ieee80211_rx_result
-ieee80211_crypto_aes_cmac_decrypt(struct ieee80211_rx_data *rx)
-{
-	struct sk_buff *skb = rx->skb;
-	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
-	struct ieee80211_key *key = rx->key;
-	struct ieee80211_mmie *mmie;
-	u8 aad[20], mic[8], ipn[6];
-	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
-
-	if (!ieee80211_is_mgmt(hdr->frame_control))
-		return RX_CONTINUE;
-
-	/* management frames are already linear */
-
-	if (skb->len < 24 + sizeof(*mmie))
-		return RX_DROP_UNUSABLE;
-
-	mmie = (struct ieee80211_mmie *)
-		(skb->data + skb->len - sizeof(*mmie));
-	if (mmie->element_id != WLAN_EID_MMIE ||
-	    mmie->length != sizeof(*mmie) - 2)
-		return RX_DROP_U_BAD_MMIE; /* Invalid MMIE */
-
-	bip_ipn_swap(ipn, mmie->sequence_number);
-
-	if (memcmp(ipn, key->u.aes_cmac.rx_pn, 6) <= 0) {
-		key->u.aes_cmac.replays++;
-		return RX_DROP_U_REPLAY;
-	}
-
-	if (!(status->flag & RX_FLAG_DECRYPTED)) {
-		/* hardware didn't decrypt/verify MIC */
-		bip_aad(skb, aad);
-		ieee80211_aes_cmac(key->u.aes_cmac.tfm, aad,
-				   skb->data + 24, skb->len - 24, mic);
-		if (crypto_memneq(mic, mmie->mic, sizeof(mmie->mic))) {
-			key->u.aes_cmac.icverrors++;
-			return RX_DROP_U_MIC_FAIL;
-		}
-	}
-
-	memcpy(key->u.aes_cmac.rx_pn, ipn, 6);
-
-	/* Remove MMIE */
-	skb_trim(skb, skb->len - sizeof(*mmie));
-
-	return RX_CONTINUE;
-}
-
-ieee80211_rx_result
-ieee80211_crypto_aes_cmac_256_decrypt(struct ieee80211_rx_data *rx)
-{
-	struct sk_buff *skb = rx->skb;
-	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
-	struct ieee80211_key *key = rx->key;
-	struct ieee80211_mmie_16 *mmie;
-	u8 aad[20], mic[16], ipn[6];
-	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
-
-	if (!ieee80211_is_mgmt(hdr->frame_control))
-		return RX_CONTINUE;
-
-	/* management frames are already linear */
-
-	if (skb->len < 24 + sizeof(*mmie))
-		return RX_DROP_UNUSABLE;
-
-	mmie = (struct ieee80211_mmie_16 *)
-		(skb->data + skb->len - sizeof(*mmie));
-	if (mmie->element_id != WLAN_EID_MMIE ||
-	    mmie->length != sizeof(*mmie) - 2)
-		return RX_DROP_UNUSABLE; /* Invalid MMIE */
-
-	bip_ipn_swap(ipn, mmie->sequence_number);
-
-	if (memcmp(ipn, key->u.aes_cmac.rx_pn, 6) <= 0) {
-		key->u.aes_cmac.replays++;
-		return RX_DROP_U_REPLAY;
-	}
-
-	if (!(status->flag & RX_FLAG_DECRYPTED)) {
-		/* hardware didn't decrypt/verify MIC */
-		bip_aad(skb, aad);
-		ieee80211_aes_cmac_256(key->u.aes_cmac.tfm, aad,
-				       skb->data + 24, skb->len - 24, mic);
-		if (crypto_memneq(mic, mmie->mic, sizeof(mmie->mic))) {
-			key->u.aes_cmac.icverrors++;
-			return RX_DROP_U_MIC_FAIL;
-		}
-	}
-
-	memcpy(key->u.aes_cmac.rx_pn, ipn, 6);
-
-	/* Remove MMIE */
-	skb_trim(skb, skb->len - sizeof(*mmie));
-
-	return RX_CONTINUE;
-}
-
-ieee80211_tx_result
-ieee80211_crypto_aes_gmac_encrypt(struct ieee80211_tx_data *tx)
-{
-	struct sk_buff *skb;
-	struct ieee80211_tx_info *info;
-	struct ieee80211_key *key = tx->key;
-	struct ieee80211_mmie_16 *mmie;
-	struct ieee80211_hdr *hdr;
-	u8 aad[GMAC_AAD_LEN];
-	u64 pn64;
-	u8 nonce[GMAC_NONCE_LEN];
-
-	if (WARN_ON(skb_queue_len(&tx->skbs) != 1))
-		return TX_DROP;
-
-	skb = skb_peek(&tx->skbs);
-
-	info = IEEE80211_SKB_CB(skb);
-
-	if (info->control.hw_key)
-		return TX_CONTINUE;
-
-	if (WARN_ON(skb_tailroom(skb) < sizeof(*mmie)))
-		return TX_DROP;
-
-	mmie = skb_put(skb, sizeof(*mmie));
-	mmie->element_id = WLAN_EID_MMIE;
-	mmie->length = sizeof(*mmie) - 2;
-	mmie->key_id = cpu_to_le16(key->conf.keyidx);
-
-	/* PN = PN + 1 */
-	pn64 = atomic64_inc_return(&key->conf.tx_pn);
-
-	bip_ipn_set64(mmie->sequence_number, pn64);
-
-	bip_aad(skb, aad);
-
-	hdr = (struct ieee80211_hdr *)skb->data;
-	memcpy(nonce, hdr->addr2, ETH_ALEN);
-	bip_ipn_swap(nonce + ETH_ALEN, mmie->sequence_number);
-
-	/* MIC = AES-GMAC(IGTK, AAD || Management Frame Body || MMIE, 128) */
-	if (ieee80211_aes_gmac(key->u.aes_gmac.tfm, aad, nonce,
-			       skb->data + 24, skb->len - 24, mmie->mic) < 0)
-		return TX_DROP;
-
-	return TX_CONTINUE;
-}
-
-ieee80211_rx_result
-ieee80211_crypto_aes_gmac_decrypt(struct ieee80211_rx_data *rx)
-{
-	struct sk_buff *skb = rx->skb;
-	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
-	struct ieee80211_key *key = rx->key;
-	struct ieee80211_mmie_16 *mmie;
-	u8 aad[GMAC_AAD_LEN], *mic, ipn[6], nonce[GMAC_NONCE_LEN];
-	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
-
-	if (!ieee80211_is_mgmt(hdr->frame_control))
-		return RX_CONTINUE;
-
-	/* management frames are already linear */
-
-	if (skb->len < 24 + sizeof(*mmie))
-		return RX_DROP_UNUSABLE;
-
-	mmie = (struct ieee80211_mmie_16 *)
-		(skb->data + skb->len - sizeof(*mmie));
-	if (mmie->element_id != WLAN_EID_MMIE ||
-	    mmie->length != sizeof(*mmie) - 2)
-		return RX_DROP_U_BAD_MMIE; /* Invalid MMIE */
-
-	bip_ipn_swap(ipn, mmie->sequence_number);
-
-	if (memcmp(ipn, key->u.aes_gmac.rx_pn, 6) <= 0) {
-		key->u.aes_gmac.replays++;
-		return RX_DROP_U_REPLAY;
-	}
-
-	if (!(status->flag & RX_FLAG_DECRYPTED)) {
-		/* hardware didn't decrypt/verify MIC */
-		bip_aad(skb, aad);
-
-		memcpy(nonce, hdr->addr2, ETH_ALEN);
-		memcpy(nonce + ETH_ALEN, ipn, 6);
-
-		mic = kmalloc(GMAC_MIC_LEN, GFP_ATOMIC);
-		if (!mic)
-			return RX_DROP_UNUSABLE;
-		if (ieee80211_aes_gmac(key->u.aes_gmac.tfm, aad, nonce,
-				       skb->data + 24, skb->len - 24,
-				       mic) < 0 ||
-		    crypto_memneq(mic, mmie->mic, sizeof(mmie->mic))) {
-			key->u.aes_gmac.icverrors++;
-			kfree(mic);
-			return RX_DROP_U_MIC_FAIL;
-		}
-		kfree(mic);
-	}
-
-	memcpy(key->u.aes_gmac.rx_pn, ipn, 6);
-
-	/* Remove MMIE */
-	skb_trim(skb, skb->len - sizeof(*mmie));
-
-	return RX_CONTINUE;
-}
-- 
2.34.1

